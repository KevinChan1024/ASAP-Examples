<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<Scripts>

  <script ID="1" category="Isolated Command" name="ABEL_INVERSE.inr" title="Using ABEL with INVERSE for a 3D Source from 2D Bitmap">
    <description>
      Similar file to Simple Arc demo project.
      Shows how to apply ABEL INVERSE to make a 3D source from
      a bitmap (BMP) image if the source is axially symmetric.
      Before running this script, you must copy the ARCPICT.BMP
      file from the Projects\Samples\SimpleArc folder and the BMP2DIS.exe
      file from the ASAP\Bin folder to the Working Directory.
    </description>
    <keyword>ABEL</keyword>
    <keyword>arcsource</keyword>
    <keyword>BMP2DIS</keyword>
    <keyword>EMITTING DATA</keyword>
    <keyword>$SYS</keyword>
    <application/>
  </script>

  <script ID="2" category="Simple Problem" name="absorbing_media01.inr" title="Tracing in Absorbing Media">
    <description>
      Shows how an absorbing media can stop
      the ray trace part way through. This generates an
      "Absorbed After" ray trace cessation warning in the
      output console.
    </description>
    <keyword>Tracing</keyword>
    <keyword>MEDIA</keyword>
    <keyword>ABSORB</keyword>
    <application/>
  </script>

  <script ID="3" category="Simple Problem" name="absorbing_media02.inr" title="Defining Absorbing Media">
    <description>
      Demonstrates the two different methods
      of inputing the absorption index of a media.
      Equal  results are obtained whether given as a complex index
      of refraction or as an absorption coefficient with  the ABSORB option
      Note that the complex index  method requires specifying the wavelength. Data for
      acrylic was taken from the The Handbook of Plastic
      Optics by U.S. Precision Lens, Inc. pg 19.
    </description>
    <keyword>Interfaces</keyword>
    <keyword>MEDIA</keyword>
    <keyword>ABSORB</keyword>
    <keyword>acrylic</keyword>
    <application/>
  </script>

  <script ID="4" category="Simple Problem" name="absorbing_media03.inr" title="Defining Absorbing Media">
    <description>
      These two definitions are equivalent in the example
      given, in which only a single wavelength is present.
      The second  form, using ABSORB, is independent of wavelength.
      The first form  becomes wavelength-dependent
      if dispersion data are specified, i.e.
      if multiple WAVELENGTHS are specified with corresponding complex
      refractive indices.
      In the latter case, ASAP interpolates among
      the given indices to compute the complex index and the absorption
      coefficient.
      ASAP does not impose the Kramers-Kronig relation upon refractive
      indices specified for multiple wavelengths, viz. the indices need
      not be consistent with causality.
    </description>
    <keyword>Interfaces</keyword>
    <keyword>MEDIA</keyword>
    <keyword>ABSORB</keyword>
    <keyword>aluminum</keyword>
    <application/>
  </script>

  <script ID="5" category="Isolated Command" name="afocal01.inr" title="Afocal Telescope">
    <description>
      Defines a Catadioptric afocal
      telescope consisting of a singlet composed
      of Schott BK7 and a mirror. The axial
      separation of the elements is 5. The
      input beam diameter is 1.5; the output
      beam diameter is 8.
    </description>
    <keyword>AFOCAL</keyword>
    <keyword>LENSES</keyword>
    <keyword>telescope</keyword>
    <application/>
  </script>

  <script ID="6" category="Isolated Command" name="afocal02.inr" title="Afocal Lens">
    <description>
      Defines an afocal telescope
      composed of mirrors. The axial separation
      of the mirrors is 5. The input beam diameter
      is 1.5; the output beam diameter is 8.
    </description>
    <keyword>AFOCAL</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="7" category="Isolated Command" name="afocal03.inr" title="Afocal Lens">
    <description>An afocal lens with a single ray plot.</description>
    <keyword>AFOCAL</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="8" category="Simple Problem" name="airy_amplitude.inr" title="Airy Rings in Amplitude">
    <description>
      The Airy disk plotted in amplitude.
      A SPREAD NORMAL is performed on a Gaussian plane
      wave after passing through an ideal lens to simulate
      a circular aperture.
    </description>
    <keyword>Wave</keyword>
    <keyword>SPREAD</keyword>
    <keyword>Airy</keyword>
    <keyword>diffraction</keyword>
    <application/>
  </script>

  <script ID="9" category="Simple Problem" name="airy_cross_section.inr" title="Airy Rings Cross section">
    <description>
      Airy rings produced by diffraction
      through a circular aperture simulated by an ideal
      lens and a truncated plane wave. The "depth"
      coordinate of the FIELD command is used to show
      ring separation and intensities at locations
      leading up to the detector. Finally, a cross-section
      picture is shown of the rings at the detector plane.
    </description>
    <keyword>Wave</keyword>
    <keyword>FIELD</keyword>
    <keyword>ENERGY</keyword>
    <keyword>Airy</keyword>
    <keyword>diffraction</keyword>
    <application/>
  </script>

  <script ID="10" category="Simple Problem" name="airy_cross_section_dmap.inr" title="Airy Rings Cross section">
    <description>
      Airy rings produced by diffraction
      through a circular aperture simulated by an ideal
      lens and a truncated plane wave. The "depth"
      coordinate of the FIELD command is used to show
      ring separation and intensities at ONLY the detector.
    </description>
    <keyword>Wave</keyword>
    <keyword>FIELD</keyword>
    <keyword>ENERGY</keyword>
    <keyword>Airy</keyword>
    <keyword>diffraction</keyword>
    <keyword>DMAP</keyword>
    <application/>
  </script>

  <script ID="11" category="Isolated Command" name="ALLOWED01.inr" title="Use of the ALLOWED command">
    <description>ALLOWED command with first 2 elements of Cooke Triplet</description>
    <keyword>ALLOWED</keyword>
    <keyword>triplet</keyword>
    <application/>
  </script>

  <script ID="12" category="Isolated Command" name="ALLOWED02.inr" title="Simple Demo of ALLOWED command">
    <description>
      ALLOWED determines what object rays can
      hit from each object. This requires a direct intersection
      with no intervening objects. Thus, if 'c' is allowed
      from 'a', but 'b' is between them and not allowed,
      then rays will stop at 'a'.
      This contrasts with SEARCH, which can let rays "skip"
      an intervening object.
    </description>
    <keyword>ALLOWED</keyword>
    <keyword>Tracing</keyword>
    <application/>
  </script>

  <script ID="13" category="Isolated Command" name="ALTER01.inr" title="Use of the ALTER command">
    <description>Using ALTER to modify an EDGE with a function.</description>
    <keyword>ALTER</keyword>
    <application/>
  </script>

  <script ID="14" category="Simple Problem" name="altered_lens.inr" title="Altering Lens Conicoids">
    <description>Altering conicoids of lenses. The ALTER  command is used as a lens modifier.</description>
    <keyword>Geometry</keyword>
    <keyword>ALTER</keyword>
    <keyword>SINGLET</keyword>
    <keyword>LENSES</keyword>
    <keyword>SEQUENCE</keyword>
    <keyword>RADI</keyword>
    <application/>
  </script>

  <script ID="15" category="Simple Problem" name="amici_prism.inr" title="Amici Roof Prism">
    <description>
      Tracing polarized beams through an
      Amici Roof Prism to show pupil polarization effects.
      Polarization is plotted at prism output and psf
      performed at detector.
    </description>
    <keyword>Geometry</keyword>
    <keyword>POINTS</keyword>
    <keyword>prism</keyword>
    <keyword>COHERENT</keyword>
    <keyword>macro</keyword>
    <keyword>$IO PLOT</keyword>
    <keyword>FIELD</keyword>
    <keyword>REPLOT</keyword>
    <keyword>SELECT</keyword>
    <keyword>POLARIZ</keyword>
    <keyword>INTERFACE REPEAT</keyword>
    <keyword>psf</keyword>
    <application/>
  </script>

  <script ID="16" category="Simple Problem" name="ANALYZE_SINGLET.inr" title="Optimizing a Singlet Lens with ANALYZE">
    <description>
      Optimization of singlet lens bending factor.
      Finds the minimum rms spot size on axis.
      Field points are  adjusted with ANALYZE.
      A comparison of plots shows how the
      bending factor changes the performance of the lens.
    </description>
    <keyword>Analysis</keyword>
    <keyword>Optimization</keyword>
    <keyword>singlet</keyword>
    <keyword>Lenses</keyword>
    <keyword>ABERRATIONS</keyword>
    <keyword>VARIABLES</keyword>
    <keyword>MINIMIZE</keyword>
    <keyword>ANALYZE</keyword>
    <keyword>tolerancing</keyword>
    <application/>
  </script>

  <script ID="17" category="Isolated Command" name="ANGLES_RADIANCE_01.inr" title="Comparing ANGLES with ANGLES RADIANCE">
    <description>
      Comparing ANGLES using RADIANCE to just
      ANGLES, showing that for narrow source cones RADIANCE
      produces projected intensity which is the same as
      ANGLES divided by the cosign obliquity.
    </description>
    <keyword>ANGLES RADIANCE</keyword>
    <keyword>DIRECTION</keyword>
    <keyword>Analysis</keyword>
    <keyword>ANGLES</keyword>
    <application/>
  </script>

  <script ID="18" category="Simple Problem" name="Aniso_Coat_Models01.inr" title="Anisotropic COATING MODELS Polarized">
    <description>
      Making anisotropic scatter models with RAWDATA ANGLES
      to model anisotropic reflectance and transmittance. In this case, four
      models are provided using the same anisotropic parametric direction 'U'
      (or local x) for R and T at both s and p polarizations. Transmittance
      is calculated over the hemisphere using a $ITER to trace a single ray
      over 51 alpha by 51 beta steps. The result is the PICTURE plot.
      ASAP linearly interpolate in amplitude space to get coefficients between
      the rough angle data given here.  The first number in the RAWDATA ANGLES
      list is the angle in  degrees from the surface normal.  The second is the azimuth angle.
      The third number determines the flux scaling. Here, the numbers are
      scaled relative to normal incidence. This is not really necessary as
      ASAP will rescale the values to the 0 0 value for you.  This means
      the R and T values in the COATING MODELS statement ("0 1") are
      multiplied by the "0 0" value given as a starting point in the list.  Other angle values will decrease based by the specified relative amount  to this normalized value. Since both S and P data are the same, no
      difference will be seen using POLAR X or Y.
    </description>
    <keyword>Interfaces</keyword>
    <keyword>COATINGS</keyword>
    <keyword>MODELS</keyword>
    <keyword>RAWDATA</keyword>
    <keyword>POLARIZ</keyword>
    <keyword>anisotropic</keyword>
    <keyword>$ITER</keyword>
    <application/>
  </script>

  <script ID="19" category="Simple Problem" name="Aperture_Sampling.inr" title="Properly Sampling an Aperture">
    <description>
      Shows the right way and several wrong ways
      to sample an aperture.
      Clearly shows how Gaussian beams are
      handled in ASAP.
      The parabasals always follow the base ray.
      Therefore if the beam set is smaller than the aperture, they
      will go straight through with no truncation.  Even a single
      beam with a wide divergence angle will go through with no
      truncation of energy, as if the aperture was not there.
    </description>
    <keyword>Wave</keyword>
    <keyword>sampling</keyword>
    <keyword>beams</keyword>
    <keyword>aperture</keyword>
    <keyword>Gaussian</keyword>
    <keyword>SPREAD</keyword>
    <keyword>$ASK</keyword>
    <keyword>WIDTHS</keyword>
    <application/>
  </script>

  <script ID="20" category="Simple Problem" name="aperture_sampling02.inr" title="A Spatial Filter">
    <description>Simulating a spatial filter by sampling an aperture using gaussian beams.</description>
    <keyword>Wave</keyword>
    <keyword>psf</keyword>
    <keyword>aperture</keyword>
    <keyword>beams</keyword>
    <keyword>SPREAD</keyword>
    <keyword>filter</keyword>
    <keyword>sampling</keyword>
    <application/>
  </script>

  <script ID="21" category="Simple Problem" name="Apodize_By_Hand.inr" title="Apodizing with Hand-Made Display File">
    <description>
      How to create a display file with user
      supplied data. The format shown below must be followed
      exactly.
      The "DISPLAY -9" tells ASAP to rewind the BRO009.DAT
      file and begin writing with the following format and data.
      In the example, since X is given first, the display data
      will be in the Window of Y-Z. The value of X is then irrelevant.
      The data that follows may be replaced with a $READ command
      followed by the file name containing the data.
    </description>
    <keyword>Radiometry</keyword>
    <keyword>apodizing</keyword>
    <keyword>hand</keyword>
    <keyword>COMBINE</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>distribution</keyword>
    <keyword>SPOTS</keyword>
    <keyword>WRITE</keyword>
    <application/>
  </script>

  <script ID="22" category="Simple Problem" name="Apodize_By_Hand_DIR.inr" title="Apodizing a 2D source in Direction with User Data">
    <description>
      How to create a directional display file with user
      supplied data. Then multiply this by a 2D source file to apply
      apodization in direction. The format shown below must be followed
      exactly.
      The "DISPLAY -9" tells ASAP to rewind the BRO009.DAT
      file and begin writing with the following format and data.
      In the example, since X is given first, the display data
      will be in the Window of Y-Z. The value of X is then irrelevant.
      The data that follows may be replaced with a $READ command
      followed by the file name containing the data.
    </description>
    <keyword>Radiometry</keyword>
    <keyword>apodizing</keyword>
    <keyword>hand</keyword>
    <keyword>COMBINE</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>distribution</keyword>
    <keyword>SPOTS</keyword>
    <keyword>WRITE</keyword>
    <application/>
  </script>

  <script ID="23" category="Simple Problem" name="Apod_Angles01.inr" title="Apodizing with USERAPOD and $FCN">
    <description>
      Apodizing in angle space using a simple
      user-defined function. The mesh plot displays the effects.
    </description>
    <keyword>Sources</keyword>
    <keyword>apodizing</keyword>
    <keyword>APODIZE</keyword>
    <keyword>ANGLES</keyword>
    <keyword>$FCN</keyword>
    <keyword>MESH</keyword>
    <application/>
  </script>

  <script ID="24" category="Simple Problem" name="Apod_Angles02.inr" title="Apodizing a Spheroid by Angles">
    <description>
      Modifying an isotropic source by apodizing
      it in angle space using a function. An emitting spheroid
      is created using CLIP DIR to keep rays on the +Z side,
      and then apodized. The emitter is isotropic by default.
      Ray directions for both the original isotropic source
      and the Lambertian apodized source are plotted.  No
      tracing is performed.
    </description>
    <keyword>Sources</keyword>
    <keyword>apodizing</keyword>
    <keyword>APODIZE</keyword>
    <keyword>ANGLES</keyword>
    <keyword>$FCN</keyword>
    <keyword>CLIP</keyword>
    <application/>
  </script>

  <script ID="25" category="Simple Problem" name="apod_angles03.inr" title="Apodizing by Angles on Multiple Sources">
    <description>
      Apodizing in angle space on multiple
      sources, using a user-defined function. This file
      demonstrates how to simulate an angularly dependent
      filter using the ray modifier APODIZE.
    </description>
    <keyword>Sources</keyword>
    <keyword>apodizing</keyword>
    <keyword>APODIZE</keyword>
    <keyword>ANGLES</keyword>
    <keyword>$FCN</keyword>
    <keyword>SPECTRUM</keyword>
    <keyword>IMMERSE</keyword>
    <keyword>macro</keyword>
    <keyword>$DO</keyword>
    <application/>
  </script>

  <script ID="26" category="Simple Problem" name="Apod_Angles04.inr" title="Apodizing by Angles using $FCN">
    <description>
      A more complex demonstration of
      Apodizing in angle space using a user-defined
      function after source creation.
      Uses user-defined macros for analysis.
    </description>
    <keyword>Sources</keyword>
    <keyword>apodizing</keyword>
    <keyword>APODIZE</keyword>
    <keyword>ANGLES</keyword>
    <keyword>$FCN</keyword>
    <keyword>RADIAL</keyword>
    <keyword>ANGLES</keyword>
    <keyword>macro</keyword>
    <application/>
  </script>

  <script ID="27" category="Simple Problem" name="Apod_Dir01.inr" title="Apodizing in Direction">
    <description>
      A simple example of USERAPOD DIR applied
      to an emitting disk.  The center column in the list is
      the direction-cosine coordinate for either adjacent
      value in the other two columns. These outer columns
      contain the relative flux intensity values projected
      onto the axes orthoganol to the axis of propagation.
      This means if the emitting disk, as we have here, is
      propagating down the Z axis, then the first column is
      the intensity projected onto the X axis, and the 3rd
      is the intensity projected onto the Y axis.  Note that
      in the following example, data points are given
      only for one side of the hemisphere (0 to 90). When this
      occurs, ASAP will automatically rotates the data
      symmetrically about both sides of each axis. This can be
      seen in the plots.
      In addition, if the X and Y slices are also identical,
      you can leave out the right-hand column and ASAP will
      assume orthoganol slices to be symmetrical.
      Therefore, the right-hand column in this example is redundant.
    </description>
    <keyword>Sources</keyword>
    <keyword>apodizing</keyword>
    <keyword>USERAPOD</keyword>
    <keyword>DIR</keyword>
    <keyword>EMITTING</keyword>
    <application/>
  </script>

  <script ID="28" category="Simple Problem" name="Apod_Dir02.inr" title="Apodizing in Direction with PROD">
    <description>
      A more advanced look at USERAPOD DIR
      using the PROD modifier. In this example, no rotational
      symmetry is performed by ASAP, since different flux
      values are given for each quadrant of the hemisphere.
      Note that PROD is used when both sides are asymmetrical,
      but it is still only optional.  Without PROD, ASAP will
      interpolate along an arc between the two orthogonal axis
      values at each dir-cosine given.
    </description>
    <keyword>Sources</keyword>
    <keyword>apodizing</keyword>
    <keyword>USERAPOD</keyword>
    <keyword>DIR</keyword>
    <keyword>PROD</keyword>
    <keyword>EMITTING</keyword>
    <application/>
  </script>

  <script ID="29" category="Simple Problem" name="Apod_Dir03.inr" title="Apodizing in Direction after Source Creation">
    <description>
      Demonstrates applying an apodization in direction
      after a source is created using the APODIZE command.
    </description>
    <keyword>Sources</keyword>
    <keyword>APODIZE</keyword>
    <keyword>ANGLES</keyword>
    <keyword>RADIAL</keyword>
    <keyword>GRID</keyword>
    <application/>
  </script>

  <script ID="30" category="Simple Problem" name="apod_dir_fcn.inr" title="Apodizing in Direction using $FCN">
    <description>
      How to apodize a source in direction with a user
      defined function. Uses USERAPOD with a $FCN that describes a
      gaussian function. Since USERAPOD is used in direction space,
      the function variables _1 and _2 are the dir-cosines for X and
      Y respectively.
    </description>
    <keyword>Sources</keyword>
    <keyword>USERAPOD</keyword>
    <keyword>apodizing</keyword>
    <keyword>function</keyword>
    <keyword>$FCN</keyword>
    <keyword>Gaussian</keyword>
    <application/>
  </script>

  <script ID="31" category="Simple Problem" name="apod_pos_fcn.inr" title="Apodizing in Position using $FCN">
    <description>
      Apodizing a source with a user defined function.
      Uses USERAPOD POSITION with a $FCN that describes a linear gradiant.
      Since USERAPOD is used in Cartesian space, the function variable
      _1 represents X. Y is rotationally symmetric by default.
    </description>
    <keyword>Sources</keyword>
    <keyword>USERAPOD</keyword>
    <keyword>POSITION</keyword>
    <keyword>apodizing</keyword>
    <keyword>function</keyword>
    <keyword>$FCN</keyword>
    <application/>
  </script>

  <script ID="32" category="Simple Problem" name="apod_pos_list.inr" title="Apodizing Position with List Data">
    <description>Apodizing a source in position using in-line data.</description>
    <keyword>Sources</keyword>
    <keyword>apodizing</keyword>
    <keyword>USERAPOD</keyword>
    <keyword>POS</keyword>
    <application/>
  </script>

  <script ID="33" category="Simple Problem" name="apod_pos_list_linear.inr" title="Linear Apodizing in Position with List Data">
    <description>
      Linear apodization of source in position
      with in-line data. Here, Y is kept constant and the Y
      scale factor (c') increased, forcing ASAP to stretch
      the apodization in Y to make more linear rather than
      circularly symmetric. This makes it similar to
      apod_pos_fcn.inr but uses in-line data.
    </description>
    <keyword>Sources</keyword>
    <keyword>apodizing</keyword>
    <keyword>USERAPOD</keyword>
    <keyword>POS</keyword>
    <application/>
  </script>

  <script ID="34" category="Isolated Command" name="arc01.inr" title="A Simple Arc Edge">
    <description>A simple 270° ARC edge displayed with PLOT EDGES.</description>
    <keyword>ARC</keyword>
    <keyword>EDGES</keyword>
    <application/>
  </script>

  <script ID="35" category="Isolated Command" name="arc02.inr" title="Arc Edges Extruded">
    <description>Extruding two arc edges into a surface.</description>
    <keyword>ARC</keyword>
    <keyword>EDGES</keyword>
    <keyword>extrude</keyword>
    <application/>
  </script>

  <script ID="36" category="Simple Problem" name="ARRAY_Bounded_Hex_Pack_Lens_01.inr" title="Close-Packed Hexagonal Lens Array Bounded">
    <description>
      A closely packed array of biconvex lenses
      bounded by a tube to form the sides.  The arrays must be
      made oversized in order for the bounding to work.
    </description>
    <keyword>Bounds</keyword>
    <keyword>lens</keyword>
    <keyword>ARRAY</keyword>
    <keyword>hex</keyword>
    <keyword>OPTICAL</keyword>
    <application/>
  </script>

  <script ID="37" category="Simple Problem" name="array_bounding01.inr" title="Surface Bounded to Ellipsoids">
    <description>
      An array of dimples in a surface
      created by bounding an array of ellipsoids with
      a plane and vice-versa. This shows the method of
      boolean OR bounding with an array using the BOUNDS
      option on the ARRAY command. Only two objects are
      needed.
    </description>
    <keyword>Geometry</keyword>
    <keyword>ARRAY</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>ELLIPSOID</keyword>
    <keyword>backlight</keyword>
    <keyword>diffuser</keyword>
    <application/>
  </script>

  <script ID="38" category="Simple Problem" name="Array_Bounding02.inr" title="Bounding Arrays with Arrays">
    <description>
      Making an array of planes, each
      with a hole in the center.  An array of planes
      is bounded to an array of tubes.
    </description>
    <keyword>Geometry</keyword>
    <keyword>ARRAY</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>TUBE</keyword>
    <application/>
  </script>

  <script ID="39" category="Simple Problem" name="ARRAY_RANDOM01.inr" title="Random Array of Ellipsoids Bounded to Plane">
    <description>
      An array of dimples in a surface
      created by bounding an array of ellipsoids with
      a plane and vice-versa. This version uses the RAN
      option on ARRAY to vary the placement of each element
      combined with varying the 2-dimensional row spacing
      using EXPonent. Also shows boolean OR bounding with
      an array using the BOUNDS option.
    </description>
    <keyword>Geometry</keyword>
    <keyword>ARRAY</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>RAN</keyword>
    <keyword>random</keyword>
    <keyword>blu</keyword>
    <keyword>backlight</keyword>
    <keyword>diffuser</keyword>
    <keyword>dots</keyword>
    <keyword>bumps</keyword>
    <application/>
  </script>

  <script ID="40" category="Isolated Command" name="ARRAY_SEARCH.inr" title="Making Tiled ARRAY's Trace Faster">
    <description>
      An array of pyramids, which are traced
      using the SEARCH option.  This option limits object
      search of adjacent elements of the array.  An
      optional "k" (default=0) may come after SEARCH to
      specify how many adjacent "rings" of objects ASAP
      must search, going outward from the ray's intersection
      with the plane of the array.  The higher this number,
      the slower the trace becomes.  Without SEARCH, ASAP
      looks at ALL elements of the ARRAY to see which object
      it could hit next after intersecting with the plane of
      the array.  This is slowest.  In the case of pyramids
      or corner cubes, a ray would have a slim chance of
      seeing any other objects than the one it is currently
      intersecting with.  This option allows much faster
      (orders of magnitude) raytracing for these conditions.
      Test this by removing SEARCH below and watching the
      TIC counter output.
    </description>
    <keyword>ARRAY</keyword>
    <keyword>Tracing</keyword>
    <keyword>SEARCH</keyword>
    <application/>
  </script>

  <script ID="41" category="Simple Problem" name="Array_Square_Holes.inr" title="Cutting an Array of Square Holes">
    <description>
      Cutting out an array of square holes using ARRAY
      and BOUNDS MULTIPLE. Based on the Prisms and Peens example
      from LCDbacklight project.
    </description>
    <keyword>Geometry</keyword>
    <keyword>ARRAY</keyword>
    <keyword>SOLID</keyword>
    <keyword>holes</keyword>
    <keyword>pipe</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>backlight</keyword>
    <application/>
  </script>

  <script ID="42" category="Isolated Command" name="asym_modifier.inr" title="ASYM as a Surface Modifier">
    <description>ASYM used as a modifier for surfaces.</description>
    <keyword>ASYM</keyword>
    <keyword>OPTICAL</keyword>
    <keyword>TUBE</keyword>
    <application/>
  </script>

  <script ID="43" category="Simple Problem" name="AXIS_Cylindrical.inr" title="Selecting Rays by AXIS Cylindrical Coordinates">
    <description>
      Shows how to use AXIS to SELECT rays
      by their cylindrical coordinates, or the distance from
      the AXIS specified.
    </description>
    <keyword>Analysis</keyword>
    <keyword>AXIS</keyword>
    <keyword>SPOTS</keyword>
    <keyword>SELECT</keyword>
    <keyword>cylindrical</keyword>
    <application/>
  </script>

  <script ID="44" category="Simple Problem" name="AXIS_LOCAL01.inr" title="Creating Distribution at Arbitrary Window Plane">
    <description>
      Shows feature for specifying a local
      arbitrary window plane to create a SPOTS distribution.
      The AXIS LOCAL command references an object that has
      an arbitrary orientation. The window override option on
      the SPOTS command (YX, YZ, etc.) enables ASAP to use
      this local window.
    </description>
    <keyword>Analysis</keyword>
    <keyword>AXIS</keyword>
    <keyword>LOCAL</keyword>
    <keyword>SPOTS</keyword>
    <application/>
  </script>

  <script ID="45" category="Simple Problem" name="Axis_Local_Coherent01.inr" title="Analyizing Coherent Beams on Skewed Surfaces">
    <description>
      Illustrate coherent beam measurement and
      decomposition of a beam traveling along the +Z axis,
      encountering surfaces that are skewed relative to the
      global axes.
    </description>
    <keyword>Analysis</keyword>
    <keyword>AXIS</keyword>
    <keyword>FIELD</keyword>
    <keyword>CONSIDER</keyword>
    <keyword>LOCAL</keyword>
    <keyword>DECOMPOSE</keyword>
    <keyword>BEAMS</keyword>
    <keyword>XY[Z]</keyword>
    <application/>
  </script>

  <script ID="46" category="Simple Problem" name="Axis_Local_Coherent02.inr" title="Analyizing Skewed Coherent Beams on Skewed Surfaces">
    <description>
      Illustrate coherent beam measurement and
      decomposition of a beam traveling along a skew axis,
      encountering surfaces that are skewed relative to the
      global axes.
    </description>
    <keyword>Analysis</keyword>
    <keyword>AXIS</keyword>
    <keyword>FIELD</keyword>
    <keyword>CONSIDER</keyword>
    <keyword>LOCAL</keyword>
    <keyword>DECOMPOSE</keyword>
    <keyword>BEAMS</keyword>
    <keyword>XY[Z]</keyword>
    <application/>
  </script>

  <script ID="47" category="Simple Problem" name="babinet_principle.inr" title="Babinet's Principle">
    <description>
      Babinet's principle of spider diffraction.
      Babinet's Principle is for modeling tricky diffraction
      problems. Set the amplitudes of certain beams to be of
      opposite sign from other beams, so beam amplitudes are
      in effect subtracted from one another. In this Example
      of Babinet's Principle, thin spider vanes and a central
      obscuration are modeled with sources whose amplitudes are
    </description>
    <keyword>Wave</keyword>
    <keyword>Babinet</keyword>
    <keyword>spider</keyword>
    <keyword>diffraction</keyword>
    <keyword>SHAPE MODE</keyword>
    <keyword>FIELD MODULUS</keyword>
    <keyword>psf</keyword>
    <application/>
  </script>

  <script ID="48" category="Simple Problem" name="beam_expander.inr" title="Anamorphic Scaling with PIXELS">
    <description>
      A model of a 10:1 beam expander.
      The first plot is done at normal aspect ratio.
      The second plot uses the FILL option of the PIXELS
      command to expand the plot in both dimensions.
    </description>
    <keyword>Analysis</keyword>
    <keyword>PIXELS</keyword>
    <keyword>FILL</keyword>
    <keyword>OPTICAL</keyword>
    <keyword>expander</keyword>
    <application/>
  </script>

  <script ID="49" category="Isolated Command" name="BEND01.inr" title="A Bent Tube">
    <description>
      BEND a tube by replacing the given coordinate
      in the command with a quadratic in the other 2 coordinates.
      The bent surface does not mesh; use PROFILES and/or RENDER.
    </description>
    <keyword>TUBE</keyword>
    <keyword>BEND</keyword>
    <application/>
  </script>

  <script ID="50" category="Isolated Command" name="BEZIER01.inr" title="A Bezier Edge">
    <description>A Bezier edge displayed with PLOT EDGES.</description>
    <keyword>EDGES</keyword>
    <keyword>BEZIER</keyword>
    <application/>
  </script>

  <script ID="51" category="Isolated Command" name="BILATERAL01.inr" title="Use of the BILATERAL command">
    <description>BILATERAL command with first element of Cooke Triplet</description>
    <keyword>BILATERAL</keyword>
    <keyword>triplet</keyword>
    <application/>
  </script>

  <script ID="52" category="Isolated Command" name="BILATERAL02.inr" title="Using SCALE to Mirror a Rayset">
    <description>
      A simple example to show a BILATERAL flip of
      half a rayset about an axis using BILATERAL.
      Source and  mirrored rays were shifted to show operation clearer in 3D
      viewer.
    </description>
    <keyword>BILATERAL</keyword>
    <keyword>RAYSET</keyword>
    <keyword>rays</keyword>
    <keyword>mirroring</keyword>
    <application/>
  </script>

  <script ID="53" category="Isolated Command" name="blackbody.inr" title="Emitting Object as Blackbody">
    <description>
      Simulating the thermal emission
      from an object of a given temperature.
    </description>
    <keyword>FBI</keyword>
    <keyword>LPW</keyword>
    <keyword>EMITTING OBJECT</keyword>
    <keyword>blackbody</keyword>
    <keyword>THERMAL</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="54" category="Simple Problem" name="BMP_to_Source01.inr" title="Converting a BMP to Source">
    <description>
      This is a simple example using a macro
      that converts a normal 24 bit 3-color BMP file to MONO
      and uses it to create a single source. This could be
      modified to use R, G and B (instead of MONO) to create
      three sources at RGB wavelengths.
    </description>
    <keyword>Sources</keyword>
    <keyword>Tracing</keyword>
    <keyword>BMP2DIS</keyword>
    <keyword>Macros_user</keyword>
    <keyword>$SYS</keyword>
    <application/>
  </script>

  <script ID="55" category="Simple Problem" name="bounded_lens.inr" title="Lens by Bounded Surfaces">
    <description>
      Making a lens with only
      three surfaces bounded together.
    </description>
    <keyword>Bounds</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>lens</keyword>
    <application/>
  </script>

  <script ID="56" category="Simple Problem" name="bounded_tube.inr" title="Bounding Long Tube with Opticals">
    <description>
      Shows solution to bounding a
      long tube at both ends with an optical
      surface. There can be a problem when the
      radius of curvature is such that there are
      alternate surfaces bounding to the tube.
      This can appear in the form of a shortened tube.
      The fix is to use the EXPAND option on the
      OPTICAL command. This changes the surface from
      implicit to explicit which makes a cleaner bounds
      by removing the alternate branch. The number of
      0's before hand determines the accuracy. Using
      EXPAND will slow raytrace time somewhat.
    </description>
    <keyword>Bounds</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>EXPAND</keyword>
    <application/>
  </script>

  <script ID="57" category="Simple Problem" name="Bounding_Distrib.inr" title="Bounding a Distribution as Source">
    <description>
      Shows how to analyze an area
      on a 2D distribution, as defined by an EDGE
      of any arbitrary shape. First the distribution
      is turned into a source and the source is "clipped"
      to the EDGE using BOUNDS.
    </description>
    <keyword>Bounds</keyword>
    <keyword>POS</keyword>
    <keyword>Sources</keyword>
    <keyword>apodizing</keyword>
    <keyword>Gaussian</keyword>
    <keyword>distribution</keyword>
    <application/>
  </script>

  <script ID="58" category="Simple Problem" name="Bounding_Sources.inr" title="Bounding a Volume Source">
    <description>
      An emitting spheroid is bounded with three
      planes and a tube. The tube is a positive bounder,
      so all rays created outside the tube are kept.
      The planes are multiple bounded in a positive way
      so that all rays are kept outside the intersection
      of all three planes.  In other words, the corner of
      the spheroid at that intersection is removed.
    </description>
    <keyword>Sources</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>SPHEROID</keyword>
    <application/>
  </script>

  <script ID="59" category="Simple Problem" name="Bounding_SWEEP_POS.inr" title="Bounding to Edge Swept in Position">
    <description>
      A method to make a square tube that
      can be used for bounding. It is made from a swept
      square edge using SWEEP POS. This example shows a
      practical application where it is bounded to an
      OPTICAL surface. This is a good alternative to
      using a square TUBE, where innacurate results can
      occur at the corners.
    </description>
    <keyword>Bounds</keyword>
    <keyword>SWEEP</keyword>
    <keyword>EDGES</keyword>
    <keyword>OPTICAL</keyword>
    <application/>
  </script>

  <script ID="60" category="Isolated Command" name="bounds01.inr" title="Bounding a Tube">
    <description>
      A bounded tube. A tube made
      by extruding two edges is bounded to an
      ellipse on one side and a tilted plane on
      the other.
    </description>
    <keyword>BOUNDS</keyword>
    <application/>
  </script>

  <script ID="61" category="Isolated Command" name="bounds02.inr" title="Bounded Tube PRINT Output">
    <description>
      Output from the PRINT command
      describing a bounded tube.
    </description>
    <keyword>BOUNDS</keyword>
    <keyword>PRINT</keyword>
    <application/>
  </script>

  <script ID="62" category="Simple Problem" name="bounds03.inr" title="Bounded Complex Aperture">
    <description>
      Bounding with a complex aperture.
      Both negative and positive bounding is
      demonstrated.
      A macro is used for graphics  generation.
    </description>
    <keyword>Edges</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>POINTS</keyword>
    <keyword>macro</keyword>
    <keyword>TITLE</keyword>
    <keyword>CONSIDER</keyword>
    <application/>
  </script>

  <script ID="63" category="Isolated Command" name="bounds04.inr" title="Multiple Bounding">
    <description>
      Bounding using the MULTIPLE
      option. A tilted plane is 'AND' bounded with
      a tube and 'OR' bounded with multiple planes.
    </description>
    <keyword>BOUNDS</keyword>
    <keyword>MULTIPLE</keyword>
    <application/>
  </script>

  <script ID="64" category="Simple Problem" name="Bounds_Edge_Tube.inr" title="Bounding Extruded Edge with Tube">
    <description>
      Extrude (or loft) two edges
      together to make a surface and then bound this
      with a tube. The edges are lofted together using
      the second form of the OBJECT command.  The surface
      is intersected with a large tube on one side and
      only the inside portion is kept ("-" bounds).
    </description>
    <keyword>Bounds</keyword>
    <keyword>EDGES</keyword>
    <keyword>POINTS</keyword>
    <keyword>OBJECT</keyword>
    <keyword>TUBE</keyword>
    <application/>
  </script>

  <script ID="65" category="Simple Problem" name="bounds_ellipse_multiple.inr" title="Multiple Bounding an Ellipsoid">
    <description>
      An ellipsoid is bounded with three
      planes and a tube. The tube is a positive bounder,
      so everything outside of the tube is kept.
      The planes are multiple bounded in a positive way
      so that everything is kept outside the intersection
      of all three planes.  In other words, the corner of
      the egg at that intersection is removed.
    </description>
    <keyword>Bounds</keyword>
    <keyword>MULTIPLE</keyword>
    <keyword>TUBE</keyword>
    <keyword>ELLIPSOID</keyword>
    <application/>
  </script>

  <script ID="66" category="Simple Problem" name="Bounds_Hex_Lens.inr" title="Hex Lens Array">
    <description>
      A Hex-pack micro-lens array made
      by bounding a series of EDGES to ARRAYs of OPTICALs.
      Rows of EDGEs are made, each offset from each other,
      describing the top and bottom edges of the hex pattern.
      ARRAYs of OPTICALs are made row by row (one dimensional
      array), each offset from each other to match the edge
      patterns above.  Each row (ARRAY) is BOUNDed to the
      corresponding EDGEs (top and bottom) to make the
      hexagonal lenses.  The result is an array of hex
      lenses packed together edge to edge.
      You can remove the comments at the end to see how
      the edges were made.
      The special $DO which makes the edges was done to
      make the code more compact.  This could be replaced
      with a long-hand version.
    </description>
    <keyword>Bounds</keyword>
    <keyword>lens</keyword>
    <keyword>ARRAY</keyword>
    <keyword>hex</keyword>
    <keyword>Edges</keyword>
    <keyword>OPTICAL</keyword>
    <keyword>$DO</keyword>
    <application/>
  </script>

  <script ID="67" category="Simple Problem" name="BOUNDS_Mutual_01.inr" title="Mutual Bounding to get Media right">
    <description>
      Bounding intersecting objects where two
      different media meet, in order to avoid wrong side warnings.
      A new object must be created at the intersection which has
      the two media assigned.  The remaining objects can have AIR
      on one side.
    </description>
    <keyword>Geometry</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>mutual</keyword>
    <keyword>MEDIA</keyword>
    <application/>
  </script>

  <script ID="68" category="Simple Problem" name="bounds_surf_edge.inr" title="Bounding Surface with an Edge">
    <description>
      Bounding a surface with an edge
      that is off the plane of the surface.  The edge
      extends forever in both directions along the normal
      to its plane and can be used to bound any surfaces
      in its projected path. In this case it intersects
      the ellipse.  A positive bounds keeps the outer
      portion of the surface.
    </description>
    <keyword>Bounds</keyword>
    <keyword>EDGES</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>ELLIPSE</keyword>
    <application/>
  </script>

  <script ID="69" category="Simple Problem" name="BpmEWaveCouplerUsingGeom.inr" title="Evanescent wave coupling between fibers">
    <description>
      This file demonstrates the use of  ASAP's Beam Propagation Method (BPM) to propagate
      through a system with two cores of varying
      separation.  A fiber mode is sent into the top
      core, and couples partially into the bottom  core.
      The distance where the cores are near
      is chosen to produce a roughly 50% energy split
      between them.  The cores in this example
      are produced by extruding a circular cross
      section along another curve.  The CONDUIT
      command is an alternative way to create this
      geometry.  The example can be run in either 2
      or 3 dimensions.  In 2d, this models two slab
      waveguides coming together.  In 3d, it's two fibers.
    </description>
    <keyword>Wave</keyword>
    <keyword>bpm</keyword>
    <keyword>FIELD</keyword>
    <keyword>COUPLE</keyword>
    <keyword>extrude</keyword>
    <keyword>$COPY</keyword>
    <keyword>evanescent</keyword>
    <application/>
  </script>

  <script ID="70" category="Simple Problem" name="BpmEWaveCouplerUsingGrin.inr" title="Evanescent wave coupling with GRINs">
    <description>
      This file demonstrates the use of
      ASAP's Beam Propagation Method (BPM) to propagate
      through a system with two cores of varying
      separation.  A fiber mode is sent into the top
      core, and couples partially into the bottom  core.
      The distance where the cores are near
      is chosen to produce a roughly 50% energy split
      between them.  The cores in this example
      are produced using a grin with discrete steps
      in index.  This approach leads to longer
      calculation times than if geometry is used, but
      allows the two branches to overlap, if desired.
      The example can be run in either 2 or 3 dimensions.
      In 2d, this models two slab waveguides coming
      together.  In 3d, it's two fibers.
    </description>
    <keyword>Wave</keyword>
    <keyword>bpm</keyword>
    <keyword>FIELD</keyword>
    <keyword>COUPLE</keyword>
    <keyword>extrude</keyword>
    <keyword>evanescent</keyword>
    <application/>
  </script>

  <script ID="71" category="Simple Problem" name="BpmLaser_Coupling.inr" title="Laser Coupling with BPM">
    <description>
      This file demonstrates the use of
      ASAP for calculating the coupling efficiency
      of a laser diode to a single-mode fiber.  It uses
      gaussian beams to propagate from the laser, through
      a ball lens, to just before the fiber's entrance.
      It propagates through the entrance and a short distance
      along the fiber using the beam propagation method (BPM).
    </description>
    <keyword>Wave</keyword>
    <keyword>bpm</keyword>
    <keyword>FIELD</keyword>
    <keyword>COUPLE</keyword>
    <keyword>DECOMPOSE</keyword>
    <application/>
  </script>

  <script ID="72" category="Simple Problem" name="BpmLaser_Coupling2.inr" title="Laser Coupling with BPM II">
    <description>
      This file demonstrates the use of
      ASAP for calculating the coupling efficiency  of a
      laser diode to a single-mode fiber.  It propagates
      laser diode output through a hemispherical lens
      attached to the fiber entrance, and a short distance
      along the fiber using the beam propagation method (BPM).
      It then projects the field onto the fiber mode to
      determine the overall coupling efficiency.
    </description>
    <keyword>Wave</keyword>
    <keyword>laser</keyword>
    <keyword>coupling</keyword>
    <keyword>bpm</keyword>
    <keyword>FIELD</keyword>
    <keyword>COUPLE</keyword>
    <keyword>DECOMPOSE</keyword>
    <application/>
  </script>

  <script ID="73" category="Simple Problem" name="BpmPropAlongFiber.inr" title="Propagation along a fiber using BPM">
    <description>
      This file demonstrates the use of
      ASAP's Beam Propagation Method (BPM) to propagate
      an input field along a stretch of single mode fiber.
      The result of propagation is compared against
      the expected fiber mode.
    </description>
    <keyword>Wave</keyword>
    <keyword>bpm</keyword>
    <keyword>FIELD</keyword>
    <keyword>COUPLE</keyword>
    <keyword>fiber</keyword>
    <keyword>radial-symmetry</keyword>
    <application/>
  </script>

  <script ID="74" category="Simple Problem" name="BpmRibbedWaveguide.inr" title="Propagation down ribbed waveguide">
    <description>
      This file demonstrates the use of
      ASAP's Beam Propagation Method (BPM) to propagate
      an input field down a simple ribbed waveguide.
    </description>
    <keyword>Wave</keyword>
    <keyword>bpm</keyword>
    <keyword>FIELD</keyword>
    <application/>
  </script>

  <script ID="75" category="Simple Problem" name="BpmYBranch.inr" title="Y Branch with Square Cross-section">
    <description>
      This file demonstrates the use of
      ASAP's Beam Propagation Method (BPM) for calculating
      the field propagated along a Y Branch with
      square cross-section channels.  The overall
      efficiency of the branch is also calculated.
    </description>
    <keyword>Wave</keyword>
    <keyword>coupling</keyword>
    <keyword>bpm</keyword>
    <keyword>FIELD</keyword>
    <keyword>COUPLE</keyword>
    <application/>
  </script>

  <script ID="76" category="Simple Problem" name="Bumpy_Tube.inr" title="Bumpy Tube made with User-defined Curve">
    <description>
      This creates a squiggly curve edge by calling
      a sine function from USERCURV.  It is then swept in direction
      to make a bumpy tube.
    </description>
    <keyword>Geometry</keyword>
    <keyword>USERCURVE</keyword>
    <keyword>bumpy</keyword>
    <keyword>$FCN</keyword>
    <keyword>SMOOTH</keyword>
    <keyword>SWEEP</keyword>
    <keyword>corrugated</keyword>
    <application/>
  </script>

  <script ID="77" category="Isolated Command" name="cad01.inr" title="Exporting Geometry in IGES">
    <description>
      Create 8 ASAP objects and export
      them to an IGES format file for use in a CAD
      program.
    </description>
    <keyword>CADEXPORT</keyword>
    <keyword>iges</keyword>
    <keyword>Geometry</keyword>
    <keyword>output</keyword>
    <application/>
  </script>

  <script ID="78" category="Isolated Command" name="character01.inr" title="A Simple Character Edge">
    <description>
      A Character edge made into
      the word "ASAP." A 3-D effect is produced
      by extruding two similar edges with the
      OBJECT command.
    </description>
    <keyword>CHARACTER</keyword>
    <keyword>EDGES</keyword>
    <application/>
  </script>

  <script ID="79" category="Isolated Command" name="Chart_Template.inr" title="Chart Template Control">
    <description>
      Demonstrates the ability to control chart templates from
      an inr script. Note that templates can not be saved from an inr script.
      This must be done through the "Load/Save Config" button in the Chart Viewer
      toolbar.  Use the "Edit Chart Properties" button to make changes to the
      current chart, including the title desired (Titles tab) before saving to
    </description>
    <keyword>$GUI</keyword>
    <keyword>APPLYCHARTTEMPLATE</keyword>
    <keyword>SETCHARTTEMPLATE</keyword>
    <keyword>GRAPH</keyword>
    <keyword>ISOMETRIC</keyword>
    <application/>
  </script>

  <script ID="80" category="Simple Problem" name="CIE10D.inr" title="Companion File for PHOTOMETRY.INR">
    <description>
      Color matching functions for CIE 1964
      standard observer (10 degrees). Must be placed in same
      Working Directory as Photometry.inr file.  This file is
      not meant to be run by itself.
    </description>
    <keyword>Radiometry</keyword>
    <application/>
  </script>

  <script ID="81" category="Simple Problem" name="Clip_Volume_Emitter_01.inr" title="Clipping a Volume Emitter">
    <description>
      A simple model of clipping a volume emitter
      to create an alternative shape for the volume of rays.
    </description>
    <keyword>Sources</keyword>
    <keyword>clipping</keyword>
    <keyword>volume</keyword>
    <keyword>EMITTING</keyword>
    <keyword>CLIP</keyword>
    <application/>
  </script>

  <script ID="82" category="Simple Problem" name="Clip_Volume_Emitter_02.inr" title="Complex Clipping and Bounding of a Volume Emitter">
    <description>
      A model demonstrating more complex positional clipping
      of a volume emitter using the BOUNDS option with CLIP.
    </description>
    <keyword>Sources</keyword>
    <keyword>clipping</keyword>
    <keyword>EMITTING</keyword>
    <keyword>CLIP</keyword>
    <keyword>volume</keyword>
    <application/>
  </script>

  <script ID="83" category="Isolated Command" name="COARSEN.INR" title="Coarsening the edges of an ellipse">
    <description>
      Altering the number of points used to plot a curve.
      The command is used as an edge modifier
    </description>
    <keyword>Geometry</keyword>
    <keyword>COARSEN</keyword>
    <keyword>OVAL</keyword>
    <keyword>REPEAT</keyword>
    <keyword>EDGES</keyword>
    <application/>
  </script>

  <script ID="84" category="Simple Problem" name="COATINGS_LAYERS_Comparison.inr" title="COATINGS LAYERS With or Without Wavelength Option">
    <description>
      A comparison of COATINGS LAYERS using the wavelength option
      and without.  Demostrates how the wavelegngth option requires coating
      thickness in waves in the medium and not a vacuum. Therefore, multiply
      the thickness in a vacuum by the real part of the index at the reference
      wavelength.
    </description>
    <keyword>Analysis</keyword>
    <keyword>COATINGS LAYERS</keyword>
    <keyword>WAVELENGTH</keyword>
    <application/>
  </script>

  <script ID="85" category="Isolated Command" name="Coating_Layers01.inr" title="COATING LAYERS for Applying Thin Film Coatings">
    <description>
      Using COATING LAYERS to apply
      user-defined thin film coatings. Thicknesses are in
      wavelength units, since no wavelength modifier is used.
    </description>
    <keyword>COATINGS</keyword>
    <keyword>LAYERS</keyword>
    <keyword>Interfaces</keyword>
    <keyword>films</keyword>
    <keyword>thin</keyword>
    <application/>
  </script>

  <script ID="86" category="Isolated Command" name="coating_layers02.inr" title="Coating Layers in Reflection">
    <description>COATING LAYERS in reflection.</description>
    <keyword>LAYERS</keyword>
    <keyword>COATINGS</keyword>
    <application/>
  </script>

  <script ID="87" category="Isolated Command" name="coating_layers03.inr" title="Fabry-Perot Filter">
    <description>
      COATING LAYERS in transmission.
      Fabry-Perot filter constructed from quarterwave
      layers of zinc sulfide (h) and magnesium
    </description>
    <keyword>LAYERS</keyword>
    <keyword>COATINGS</keyword>
    <keyword>Fabry-Perot</keyword>
    <keyword>filter</keyword>
    <application/>
  </script>

  <script ID="88" category="Simple Problem" name="COATING_LAYER_Analysis.inr" title="Checking a Coating Layer prescription with $ITER">
    <description>
      How to plot Irradiance in transmision vs. wavelength
      for a lens with coating layers applied.  Uses $ITER to run
      raytraces at wavelength intervals over the selected range,
      saving the irradiance results to the iter.dis display file.
    </description>
    <keyword>Analysis</keyword>
    <keyword>COATINGS</keyword>
    <keyword>LAYERS</keyword>
    <keyword>WAVELENGTH</keyword>
    <keyword>irradiance</keyword>
    <keyword>$ITER</keyword>
    <application/>
  </script>

  <script ID="89" category="Simple Problem" name="Coating_Models01.inr" title="COATING MODELS Non-polarized">
    <description>In this file, BSDFDATA ANGLES is used to provide two  models of data at different incident angles. This is a simpler  case where polarization will be ignored. Each model will represent  both s and p polarizations. Results are printed out at the end  for the various input angles.  Note that ASAP will linearly  interpolate in log amplitude space to get coefficients between  the given angle data in the BSDFDATA ANGLES.   The first number in the BSDFDATA ANGLES list is the angle in  degrees from the surface normal.  The second is the azimuth angle.  These are all 0. COATING MODELS assumes the coating behavior is  independent of azimuth angle. The third number determines the flux  scaling. Here, the numbers are scaled relative to normal incidence.  This is not really necessary as ASAP will rescale the values  to the 0 0 value for you.  This means the R and T values in  the COATING MODELS statement ("0.5 0.5") are multiplied by the  "0 0" value given as a starting point in the list. Other angle  values will increase or decrease based on the specified relative  amount to this normalized value. In this example, for reflected  values, Normal incidence gives 0.5 (0.5*1), and then at 10° from  Normal it will be 5% higher in reflection (1.05).</description>
    <keyword>Interfaces</keyword>
    <keyword>COATINGS</keyword>
    <keyword>MODELS</keyword>
    <keyword>BSDFDATA</keyword>
    <keyword>NUMBERS</keyword>
    <application/>
  </script>

  <script ID="90" category="Simple Problem" name="Coating_Models02.inr" title="COATING MODELS Polarized">
    <description>
      BSDFDATA ANGLES is used to provide R and T
      values at different incident angles.  In this case the two models
      are reversed for R and T to account for s and p polarization. Results
      are printed for the various input angles.  ASAP will linearly
      interpolate in log amplitude space to get coefficients between
      the given angle data in the BSDFDATA ANGLES.
      The first number in the BSDFDATA ANGLES list is the angle in
      degrees from the surface normal.  The second is the azimuth angle.
      These are all 0. COATING MODELS assumes the coating behavior is
      independent of azimuth angle. The third number determines the flux
      scaling. Here, the numbers are scaled relative to normal incidence.
      This is not really necessary as ASAP will rescale the values
      to the 0 0 value for you.  This means the R and T values in
      the COATING MODELS statement ("0.5 0.5") are multiplied by the
      "0 0" value given as a starting point in the list. Other angle
      values will increase or decrease based by the specified relative
      amount to this normalized value. In this example, for reflected
      values, Normal incidence gives 0.5, and then at 25° it will be
      60% higher in reflection (1.6).  The BK7 and IMMERSE may be used
      as an option.
    </description>
    <keyword>Interfaces</keyword>
    <keyword>COATINGS</keyword>
    <keyword>MODELS</keyword>
    <keyword>BSDFDATA</keyword>
    <keyword>NUMBERS</keyword>
    <keyword>POLARIZ</keyword>
    <keyword>ACCURACY</keyword>
    <keyword>XMEMORY FULL</keyword>
    <application/>
  </script>

  <script ID="91" category="Simple Problem" name="Coating_Models03.inr" title="Polarizing Beam Splitter using COATING MODELS">
    <description>
      Uses BSDFDATA ANGLES to make a polarizing
      beam splitter for a 45° incident angle.  Four sets of angle
      data are provided for s and p polarization in R and T.  A
      coating called 'PBS' is created with a 50% split between
      R and T. At 45° R is mainly s-polarized and T is mainly
      p-polarized. This coating is applied to the beam splitter
      surface which is situated at 45° to the incident beam.
      You may rerun the file using the alternate coating,
      'PBS2' (with s and p reversed), applied to 'POLARIZER_2'
      and view the results.   Note that the second pair of models are duplicated for  clarity, but could have been left out.  Model numbers  may be specified more than once in the COATING MODELS
      command.
    </description>
    <keyword>Interfaces</keyword>
    <keyword>COATINGS</keyword>
    <keyword>MODELS</keyword>
    <keyword>BSDFDATA</keyword>
    <keyword>NUMBERS</keyword>
    <keyword>POLARIZ</keyword>
    <keyword>splitter</keyword>
    <keyword>pbs</keyword>
    <application/>
  </script>

  <script ID="92" category="Simple Problem" name="coating_models04.inr" title="Multi-Wavelength Coating Model">
    <description>How to define a multiple wavelength  coating on a surface using COATING MODELS. A   three color source is traced through a lens with two  surfaces having this coating applied. The flux of  the rays are plotted on each surface after the trace.  The front surface is allowed to split to see   differences in the reflected flux.  The back of the  lens only allows transmission for simplicity.  Look  at the STATS output to see actual flux levels for  each wavelength which is controlled by the coating  definitions.</description>
    <keyword>Geometry</keyword>
    <keyword>COATINGS</keyword>
    <keyword>MODELS</keyword>
    <keyword>WAVELENGTHS</keyword>
    <keyword></keyword>
    <application/>
  </script>

  <script ID="93" category="Isolated Command" name="coating_prop01.inr" title="S20 Photocathode Model">
    <description>
      Model of filter with S20 photocathode
      transmission response. Defines the transmission curve
      as a function of wavelength of an S20 photocathode.
      ASAP will linearly interpolate, if necessary, to
      obtain the transmission, at intermediate wavelengths.
      When the coating is assigned to an OBJECT, ASAP will
      calculate the normal reflection/transmission coefficient
      at the specified wavelength and apply those coefficients
      to all rays at that OBJECT regardless of angle of
      incidence unless a FRESNEL command is first executed.
    </description>
    <keyword>COATINGS</keyword>
    <keyword>photocathode</keyword>
    <keyword>filter</keyword>
    <keyword>Interfaces</keyword>
    <application/>
  </script>

  <script ID="94" category="Isolated Command" name="COLLECTION01.inr" title="Calculating Percent Efficiency of a Rayset">
    <description>
      Using COLLECTION to analyze percent efficiency
      of a source within a certain angular range and window.
      The emitting disk is 10 by 10 units. The collection area
      is controlled by the window setting, which is 12 by 12.
      This will be sure to collect all of the source spatially.
      There are 25 spatial samples and 30 direction samples up
      to an angle of 60 degrees.  The results of collection are
      written to the BRO009.dat file. These can be processed by
      any of the display commands.  The initial results plotted are
      spatial.  Use the TRANSPOSE command to show the directional  results.
    </description>
    <keyword>COLLECTION</keyword>
    <keyword>TRANSPOSE</keyword>
    <keyword>Analysis</keyword>
    <application/>
  </script>

  <script ID="95" category="Isolated Command" name="colors_modifier.inr" title="Tracing in Different Colors">
    <description>
      How to trace three sources in
      Red, Green, and Blue. ASAP automatically plots
      different sources using different colors, but
      if you want to control and specify the colors used
      (for example R, G, and B), this example shows you how.
    </description>
    <keyword>COLORS</keyword>
    <keyword>Analysis</keyword>
    <keyword>Tracing</keyword>
    <keyword>ATTRIBUTE</keyword>
    <application/>
  </script>

  <script ID="96" category="Simple Problem" name="Combining_Distrib.inr" title="Combining Spots Distributions">
    <description>
      This is a demonstration of how to simulate a row of
      identical LED's used as a multiple source without having to trace
      geometry and the source more than once.  It creates a single LED used
      as an emitting object which is traced to a target plane.  Normally,
      there would be an optic or some local geometry in front of the LED,
      as well.  A SPOTS distribution on the target is saved to a file.
      This is then duplicated, shifted and combined to a file a number
      of times to represent multiple sources and geometry.  This could
      save much time over recreating the entire geometry set, and then
      creating, shifting and retracing the source many times, especially
      if there is a large array or complex geometry involved.  Of course,
      be aware that the single trace method would not show
      effects of ray interaction with adjacent geometry that is not there.
    </description>
    <keyword>Sources</keyword>
    <keyword>Tracing</keyword>
    <keyword>COMBINE</keyword>
    <keyword>SHIFT</keyword>
    <keyword>SPOTS</keyword>
    <keyword>iges</keyword>
    <keyword>WRITE</keyword>
    <keyword>SUM</keyword>
    <keyword>IMMERSE</keyword>
    <keyword>SUBSET</keyword>
    <application/>
  </script>

  <script ID="97" category="Simple Problem" name="Combining_Distrib02.inr" title="Combining Angular Distributions">
    <description>
      Combine two different SPOTS DIR
      distributions with different averaging applied.
      Each distribution is converted to angles and then the
      appropriate areas in each are cleared so that there will
      be no overlap when they are added together. MODIFY is
      used to clear specific pixel ranges to zero so that
      COMBINE can add the two cleanly. The overall WINDOW must
      remain the same between the two.
    </description>
    <keyword>Analysis</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>COMBINE</keyword>
    <keyword>MODIFY</keyword>
    <keyword>CONTOUR</keyword>
    <application/>
  </script>

  <script ID="98" category="Simple Problem" name="Complex_Field_Import_Export.inr" title="Complex Field I/O">
    <description>
      A way to import large complex fields made externally as
      Real and Imaginary pairs avoiding the need to add tick symbols.
      This also shows how to extract individual complex components for possible
      manipulation by external programs. Note, the syntax below the DISPLAY -29
      uses an arbitrary optical axis position of 0.  the important numbers are the
      window extents of the field and number of pixels or values entered.
      In the following case, since Z is first, the FIELD (at Z=0) will
      be in the plane (Window) of X-Y.  $READ is generally used to
      import data from large files. They are in-line here to avoid multiple files.
      Also note, the first number in the set was changed to avoid the Warning
      about no variation in data.
    </description>
    <keyword>Wave</keyword>
    <keyword>Gaussian</keyword>
    <keyword>FIELD</keyword>
    <keyword>complex</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>hand</keyword>
    <keyword>$FAST</keyword>
    <keyword>import</keyword>
    <keyword>export</keyword>
    <application/>
  </script>

  <script ID="99" category="Simple Problem" name="CONDUIT.inr" title="Creating a conduit (sweeping a circle along a planar cubic)">
    <description>
      Creates conduit objects on axis and displaced from
      the axis.
    </description>
    <keyword>Geometry</keyword>
    <keyword>CONDUIT</keyword>
    <application/>
  </script>

  <script ID="100" category="Simple Problem" name="conduit_wire_wrapping.inr" title="Wrapping wires with a conduit">
    <description>
      Creates 4 wires out of tubes and then wraps
      them with a conduit
    </description>
    <keyword>Geometry</keyword>
    <keyword>CONDUIT</keyword>
    <keyword>TUBE</keyword>
    <keyword>REPEAT</keyword>
    <keyword>wire</keyword>
    <keyword>tube</keyword>
    <application/>
  </script>

  <script ID="101" category="Isolated Command" name="conic01.inr" title="Create a Conic Surface with SWEEP">
    <description>
      Use the SWEEP command on
      a CONIC edge for the equivalent of a
      classical optical conicoid.
    </description>
    <keyword>CONIC</keyword>
    <keyword>EDGES</keyword>
    <keyword>SWEEP</keyword>
    <application/>
  </script>

  <script ID="102" category="Isolated Command" name="contour01.inr" title="CONTOUR Display Command">
    <description>
      Create a CONTOUR plot with and
      without tic marks using 10 contour levels.
    </description>
    <keyword>CONTOUR</keyword>
    <keyword>DISPLAY</keyword>
    <application/>
  </script>

  <script ID="103" category="Isolated Command" name="contour02.inr" title="Plotting Iso-Luminance">
    <description>
      Iso-luminance plots of SPOTS POS
      and RADIANT distributions using CONTOUR.
    </description>
    <keyword>CONTOUR</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>Radiometry</keyword>
    <keyword>radiance</keyword>
    <application/>
  </script>

  <script ID="104" category="Simple Problem" name="cony_2.inr" title="CAD Element used for SURF_SAMPLED_ARRAY_OF_CAD_ELEMENT.INR">
    <description>
      Companion translated CAD file (a sample bump) to use
      with SURF_SAMPLED_ARRAY_OF_CAD_ELEMENT.INR.
    </description>
    <keyword>Arrays</keyword>
    <application/>
  </script>

  <script ID="105" category="Simple Problem" name="CORNER_ARRAY_01.inr" title="ARRAY of Corner Triangles">
    <description>
      This demonstrates an area-filling array of CORNER
      surfaces. Two corner triangles are paired so they can
      be arrayed to fill an area, then they are arrayed.
      The corner cubes are packed so the neighboring corners
      just touch, with no space between them.
      The ARRAY ... SEARCH parameter is set to 1, so
      attempts to raytrace these objects will be done
      more efficiently by avoiding intersections to other
      locations in the array. This can be important in very large
      arrays, especially in light pipes and guides. It must be
      used with due attention to the view factor of surrounding
      array rows, but it is very useful.
      This example builds only a small array for demonstration
      purposes, but the technique may be extended to millions of
      regardless of the number of repetitions of the elements.
    </description>
    <keyword>Geometry</keyword>
    <keyword>ARRAY</keyword>
    <keyword>triangle</keyword>
    <keyword>corner</keyword>
    <keyword>backlight</keyword>
    <keyword>light pipe</keyword>
    <application/>
  </script>

  <script ID="106" category="Simple Problem" name="corner_cube.inr" title="Corner Cube with POINTS">
    <description>A cube corner made with POINTS.</description>
    <keyword>Edges</keyword>
    <keyword>POINTS</keyword>
    <keyword>cube</keyword>
    <keyword>corner</keyword>
    <keyword>CONSIDER</keyword>
    <application/>
  </script>

  <script ID="107" category="Simple Problem" name="CPC_AXICONIC_INTERACTIVE.inr" title="AXICONIC CPC Using User Inputs with Export">
    <description>
      This file creates a cpc based on user inputs.
      If the length of the CPC entered by the user is shorter or longer
      than the calculated maximum, the user is notified and given a choice
      whether to truncate or add a tube to the end of the cpc. If it is too long
      or if it is too short, the user can force it to its maximum length or
      create a truncated CPC.
      Lastly, at the very end, is code that will create a separate file entitled
      cpc_output.inr that contains all the geometry necessary to recreate the cpc
      created while running this file.
    </description>
    <keyword>Macros_user</keyword>
    <keyword>cpc</keyword>
    <keyword>AXICONIC</keyword>
    <application/>
  </script>

  <script ID="108" category="Simple Problem" name="CPC_BY_BEZIER_EDGES.inr" title="Non-AXICONIC CPC">
    <description>
      CPC or other type concentrator made with
      bezier connected edge points.
    </description>
    <keyword>Macros_user</keyword>
    <keyword>cpc</keyword>
    <keyword>cec</keyword>
    <keyword>chc</keyword>
    <keyword>bezier</keyword>
    <keyword>Edges</keyword>
    <application/>
  </script>

  <script ID="109" category="Simple Problem" name="Crossed_Gratings.inr" title="Crossed Gratings using MULTIPLE and DIFFRACT">
    <description>
      Crossed gratings made with MULTIPLE and DIFFRACT modifiers.
      Two parallel planes are made very close together in the same axis.
      Each one is assigned a coating with diffractive components orthogonal
      to each other.
    </description>
    <keyword>Gratings</keyword>
    <keyword>MULTIPLE</keyword>
    <keyword>DIFFRACT</keyword>
    <keyword>linear</keyword>
    <keyword>crossed</keyword>
    <application/>
  </script>

  <script ID="110" category="Simple Problem" name="Cross_Prisms.inr" title="Array of Crossed Prisms">
    <description>
      The following example shows a simple method of
      creating the geometry of a cross striped prism film of similar
      material using the second form of the second syntax of the
      OBJECT command which lets you combine a large number of edge
      entities. This way the object number is kept low for a large
      matrix. The entities are extruded together according to the
      switches given on the command line.  In this case, -n 1 0 0
      which means n = number of entities total, 1 = Odd number
      entities are connected to Even number entities in the order
      created. 0 = Even to Odd entity connections are NOT made.
      0 = Last entity to First entity are NOT connected.  See Help
      for details.
      The edges were all created with points to make the example
      simple.  One could create one edge and angle them properly
      with the SHIFT and ROTATE commands.
      The distance of the edges in the triangles below = 5.
      This could be designated as a variable, of course.
      The bottom of the prisms are left open in order to sit on
      a plane surface of same material. With this method, there
      should be no "wrong side" errors, due to intersections
      of refractive material inside other refractive material.
    </description>
    <keyword>Geometry</keyword>
    <keyword>Arrays</keyword>
    <keyword>prism</keyword>
    <keyword>OBJECT</keyword>
    <keyword>EDGES</keyword>
    <keyword>diffuser</keyword>
    <application/>
  </script>

  <script ID="111" category="Simple Problem" name="crystal_interference.inr" title="Birefringence of a Uniaxial Crystal">
    <description>
      In the following example, we create
      an interference pattern with ordinary and extraordinary
      rays out of a uniaxial crystal. Light from a point source,
      horizontally polarized (along the y axis), propagates
      through the crystal. Propagation through the crystal
      generates extraordinary rays for rays not propagating
      directly along the y axis. The reason extraordinary rays
      are not generated along this axis is that the polarization
      is everywhere perpendicular to the optical axis of the
      crystal (along the z axis). After propagating through the
      crystal the ordinary and extraordinary rays propagate
      through a vertical linear polarizer (along the y axis)
      where only vertically polarized components of the ordinary
      and extraordinary rays interfere at the detector.
    </description>
    <keyword>Polarization</keyword>
    <keyword>CRYSTAL</keyword>
    <keyword>interference</keyword>
    <keyword>POLARIZ</keyword>
    <keyword>IDEAL</keyword>
    <keyword>FIELD</keyword>
    <application/>
  </script>

  <script ID="112" category="Simple Problem" name="Cube_Object.inr" title="A Cube as Single Object">
    <description>
      Making a cube solid using second
      syntax of OBJECT command. The result is treated
      as one object.  SURFACES must be used.
    </description>
    <keyword>Geometry</keyword>
    <keyword>OBJECT</keyword>
    <keyword>solid</keyword>
    <keyword>cube</keyword>
    <application/>
  </script>

  <script ID="113" category="Simple Problem" name="Custom_Spaced_Array01.inr" title="Making Custom-Spaced Arrays">
    <description>
      An ARRAY of disks with custom spacing
      of rows using macros.
    </description>
    <keyword>Arrays</keyword>
    <keyword>ARRAY</keyword>
    <keyword>Macros_user</keyword>
    <keyword>custom</keyword>
    <application/>
  </script>

  <script ID="114" category="Isolated Command" name="CUTOFF.inr" title="Use of the CUTOFF command">
    <description>Adjust level of CUTOFF command to see where rays terminate.</description>
    <keyword>CUTOFF</keyword>
    <application/>
  </script>

  <script ID="115" category="Simple Problem" name="Cylindrical_Lens.inr" title="Various Cylindrical Lens Methods">
    <description>
      Creates an identical cylindrical lens using
      some of the many methods available.
    </description>
    <keyword>Geometry</keyword>
    <keyword>cylindrical</keyword>
    <keyword>lens</keyword>
    <keyword>USERSAG</keyword>
    <keyword>OPTICAL</keyword>
    <keyword>POINTS</keyword>
    <keyword>TUBE</keyword>
    <keyword>SWEEP</keyword>
    <application/>
  </script>

  <script ID="116" category="Simple Problem" name="Data_Load01.inr" title="Importing Data Set into Variables">
    <description>
      A macro which reads in an external file of data
      values, and assigns each number to a variable.
      Two  arguments are passed to the macro -- the number of data points, and
      the name of the file containing the data.  The data file should be
      a single column of values, and should have a name with a .INR
      extension. See description at end of file.  Do not run this script
      without first creating such a file in the Working Directory, named
      DATA.inr
    </description>
    <keyword>Macros_pre</keyword>
    <keyword>variable</keyword>
    <keyword>VALUES</keyword>
    <keyword>$REG</keyword>
    <keyword>import</keyword>
    <keyword>data</keyword>
    <keyword>macro</keyword>
    <application/>
  </script>

  <script ID="117" category="Simple Problem" name="Data_Load02.inr" title="Importing Large Arrays of Data into Variables using SECTION">
    <description>
      How to input external data to be assigned to individual
      variables in ASAP.  The "DISPLAY -9" tells ASAP to rewind the BRO009.DAT
      file and begin writing with the following format and data. This can be read
      in with $READ instead of in line as shown here. See comments below.
      The formatting of the display file regarding window orientation and range
      is strictly arbitrary.  What is important is the number of pixels specified.
      This  should match the data given below or in the external file.  The first window
      dimension gives the number of rows and the second is columns.
      The command SECTION is used to extract each "pixel" value that is stored in
      distribution file and assign it to a variable name.
    </description>
    <keyword>Scripts</keyword>
    <keyword>input</keyword>
    <keyword>SECTION</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>data</keyword>
    <keyword>variable</keyword>
    <keyword>external</keyword>
    <keyword>import</keyword>
    <application/>
  </script>

  <script ID="118" category="Simple Problem" name="decomp_pos.inr" title="Decomposing in Position">
    <description>Demonstration of decomposing in position.</description>
    <keyword>Wave</keyword>
    <keyword>DECOMPOSE</keyword>
    <keyword>FIELD</keyword>
    <keyword>ENERGY</keyword>
    <keyword>TRACE STEP</keyword>
    <keyword>CLIP</keyword>
    <application/>
  </script>

  <script ID="119" category="Simple Problem" name="decomp_pos02.inr" title="Decomposing in Position #2">
    <description>
      Demonstration of decomposing in position.
      A slightly different version from the original   decomp_pos.inr.
    </description>
    <keyword>Wave</keyword>
    <keyword>DECOMPOSE</keyword>
    <keyword>FIELD</keyword>
    <keyword>ENERGY</keyword>
    <keyword>TRACE STEP</keyword>
    <keyword>CLIP</keyword>
    <application/>
  </script>

  <script ID="120" category="Simple Problem" name="DEFORMed_trough_01.inr" title="Sinusoidal Deformation of a Parabolic Trough Reflector">
    <description>
      This example shows relatively large
      deformations easily seen in PLOT FACETS and the 3D Viewer.
    </description>
    <keyword>Geometry</keyword>
    <keyword>DEFORM</keyword>
    <keyword>ASYM</keyword>
    <keyword>$FCN</keyword>
    <keyword>trough</keyword>
    <keyword>parabolic</keyword>
    <keyword>reflector</keyword>
    <application/>
  </script>

  <script ID="121" category="Simple Problem" name="DEFORMed_trough_MAP_01.inr" title="Deformation of a Parabolic Trough Reflector">
    <description>
      This example shows relatively small
      deformations that are not easily seen in
      PLOT FACETS and the 3D Viewer. Therefore, MAP is
      used to show the base surface, perturbed
      surface, and the calculated difference
      between them as a check on the deformation process.
    </description>
    <keyword>Geometry</keyword>
    <keyword>DEFORM</keyword>
    <keyword>MAP</keyword>
    <keyword>$FCN</keyword>
    <keyword>$EVAL</keyword>
    <keyword>ASYM</keyword>
    <keyword>trough</keyword>
    <keyword>reflector</keyword>
    <keyword>COMBINE</keyword>
    <application/>
  </script>

  <script ID="122" category="Simple Problem" name="DEFORMed_trough_MAP_02.inr" title="Complex Deformation of a Parabolic Trough Reflector">
    <description>
      This example shows relatively small
      deformations that are not easily seen in
      PLOT FACETS and the 3D Viewer. Therefore, MAP is
      used to show the base surface, perturbed
      surface, and the calculated difference
      between them as a check on the deformation process.
      The deformation is sinusoidal across the figured
      direction, and exponential along the trough's length.
      Similar to DEFORMED_TROUGH_MAP01.INR but more complex
      deformation is applied.
    </description>
    <keyword>Geometry</keyword>
    <keyword>DEFORM</keyword>
    <keyword>MAP</keyword>
    <keyword>trough</keyword>
    <keyword>reflector</keyword>
    <application/>
  </script>

  <script ID="123" category="Simple Problem" name="deform_array.inr" title="Deforming To An Arrayed Sampled Surface">
    <description>Deforming to an arrayed sampled surface.</description>
    <keyword>SAMPLED</keyword>
    <keyword>DEFORM</keyword>
    <keyword>Geometry</keyword>
    <keyword>ARRAY</keyword>
    <keyword>MAP</keyword>
    <application/>
  </script>

  <script ID="124" category="Simple Problem" name="deform_aspheric.inr" title="Default Aspheric Deformation">
    <description>Deforming with default aspheric deformation.</description>
    <keyword>Geometry</keyword>
    <keyword>DEFORM</keyword>
    <keyword>aberration</keyword>
    <keyword>Zernike</keyword>
    <application/>
  </script>

  <script ID="125" category="Simple Problem" name="deform_explicit.inr" title="Deforming To An Explicit Surface">
    <description>Deforming to a general explicit surface.</description>
    <keyword>Geometry</keyword>
    <keyword>DEFORM</keyword>
    <keyword>GENERAL</keyword>
    <keyword>EXPLICIT</keyword>
    <keyword>ALIGN</keyword>
    <application/>
  </script>

  <script ID="126" category="Simple Problem" name="Deform_Sampled.inr" title="Deforming using Sampled Surface">
    <description>
      Deforming a plane surface with a sampled
      surface made with a $ITER. Using a beam splitter,
      rays reflected from the deformed surface interfere with
      rays from a reference surface and the fringe pattern is
      examined.
    </description>
    <keyword>Geometry</keyword>
    <keyword>DEFORM</keyword>
    <keyword>SAMPLED</keyword>
    <keyword>deforming</keyword>
    <keyword>$ITER</keyword>
    <keyword>POLAR</keyword>
    <keyword>WIDTHS</keyword>
    <application/>
  </script>

  <script ID="127" category="Simple Problem" name="DEFORM_SAMPLED02.inr" title="Deforming by Sampled Surface using $FCN">
    <description>
      An INR file that generates a deformed hexagonal surface.
      This application is useful for modelling mirror support
      print-through on the mirror reflecting surface.
      The print-through is introduced as a surface deformation
      using DEFORM.  The deformation is calculated from a user
      defined $FCN that is used to generate a DIS file containing
      the function data.  The deformation is introduced onto the
      reflecting surface by defining a sampled surface and using
      DEFORM.  Credit goes to Robert Upton at NOAO for submitting this example.
    </description>
    <keyword>Geometry</keyword>
    <keyword>DEFORM</keyword>
    <keyword>SAMPLED</keyword>
    <keyword>deforming</keyword>
    <keyword>$FCN</keyword>
    <keyword>USERFUNC</keyword>
    <keyword>FMAP</keyword>
    <application/>
  </script>

  <script ID="128" category="Simple Problem" name="DEFORM_SAMPLED03.inr" title="Deforming by Sampled Surface using $FCN">
    <description>
      An INR file that generates a deformed hexagonal surface.
      This application is useful for modelling mirror support
      print-through on the mirror reflecting surface.
      The print-through is introduced as a surface deformation
      using DEFORM.  The deformation is calculated from a user
      defined $FCN that is used to generate a DIS file containing
      the function data.  The deformation is introduced onto the
      reflecting surface by defining a sampled surface and using
      DEFORM.  Credit goes to Robert Upton at NOAO for submitting this example.
    </description>
    <keyword>Geometry</keyword>
    <keyword>DEFORM</keyword>
    <keyword>SAMPLED</keyword>
    <keyword>deforming</keyword>
    <keyword>$FCN</keyword>
    <keyword>USERFUNC</keyword>
    <keyword>FMAP</keyword>
    <application/>
  </script>

  <script ID="129" category="Simple Problem" name="Diffract_Apert.inr" title="Aperture Diffraction">
    <description>Aperture diffraction using a plane wave front.</description>
    <keyword>Wave</keyword>
    <keyword>diffraction</keyword>
    <keyword>aperture</keyword>
    <keyword>FIELD</keyword>
    <keyword>phase</keyword>
    <keyword>PARABASAL</keyword>
    <application/>
  </script>

  <script ID="130" category="Simple Problem" name="DIFFSHEET.inr" title="Using Pre-defined diffuser Sheets">
    <description>
      This is a similar file to that shown in the
      Feature Note called "Predefined Diffuser Models in ASAP."
      Please refer to this note for full description.  This
      basically shows how to use SEARCH to apply a diffuser sheet
      that has different reflective and transmissive properties.
      This particular file goes a step further to compare calculated
      results with the model plots (at 60°).
    </description>
    <keyword>Scatter</keyword>
    <keyword>SCATTER</keyword>
    <keyword>MODELS</keyword>
    <keyword>Diffuser</keyword>
    <keyword>SEARCH</keyword>
    <application/>
  </script>

  <script ID="131" category="Simple Problem" name="diff_grating.inr" title="Circular Diffraction Grating">
    <description>
      A circular diffraction grating using
      the DIFFRACT option on the INTERFACE command.
      A circular diffraction grating has equally
      spaced grating rings that extend radially outward.
    </description>
    <keyword>Geometry</keyword>
    <keyword>DIFFRACT</keyword>
    <keyword>GENERAL</keyword>
    <keyword>MULTIPLE</keyword>
    <keyword>EXPONENT</keyword>
    <application/>
  </script>

  <script ID="132" category="Isolated Command" name="dimension.inr" title="DIMENSION Command">
    <description>DIMENSION Command Output.</description>
    <keyword>DIMENSION</keyword>
    <application/>
  </script>

  <script ID="133" category="Simple Problem" name="DIN_Recover.inr" title="Making a New Display File from a Saved DIN File">
    <description>
      How to recover a display file from a saved DIN file.
      A DIN (name.din) file is a text version of the binary dis file.
      It is  created using the WRITE command. WRITE is used to save a SPOTS or other
      distribution file to another name using the dis or din extension (See Help),
      If a dis file is accidentally deleted, but the din equivelent remains, then this
      method may be used to recover the original dis file to be used again with
      the various DISPLAY commands, or saved again to a dis file.
    </description>
    <keyword>Radiometry</keyword>
    <keyword>din</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>distribution</keyword>
    <keyword>SPOTS</keyword>
    <keyword>WRITE</keyword>
    <keyword>$READ</keyword>
    <application/>
  </script>

  <script ID="134" category="Simple Problem" name="Diode_Bar.inr" title="Coherent array of laser diodes">
    <description>
      Create an array of diode lasers
      using DECOMPOSE DIRECTION.
    </description>
    <keyword>Wave</keyword>
    <keyword>GAUSSIAN</keyword>
    <keyword>DECOMPOSE</keyword>
    <keyword>diode</keyword>
    <keyword>laser</keyword>
    <application/>
  </script>

  <script ID="135" category="Simple Problem" name="directional.inr" title="DIRECTIONAL Display Command">
    <description>
      Create a DIRECTIONAL plot of selected
      rayset created from SPOTS DIRECTION. A polar and
      cartesian plot is demonstrated.
    </description>
    <keyword>Analysis</keyword>
    <keyword>DIRECTIONAL</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>SELECT</keyword>
    <keyword>SPOTS</keyword>
    <application/>
  </script>

  <script ID="136" category="Isolated Command" name="DIRECTIONAL02.inr" title="DIRECTIONAL Display Command">
    <description>
      A DIRECTIONAL plot of a radially averaged
      emitting source showing ISO or Lambertian variation.
      $GUI is used to show chart using original display viewer
      which shows 0 180° hemisphere only.
    </description>
    <keyword>DIRECTIONAL</keyword>
    <keyword>Analysis</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>$GUI</keyword>
    <application/>
  </script>

  <script ID="137" category="Simple Problem" name="DIRECTIONAL03.inr" title="Overlaying DIRECTIONAL UNWRAP Plots">
    <description>
      How to overlay DIRECTIONAL UNWRAP plots using
      original display viewer.
    </description>
    <keyword>Analysis</keyword>
    <keyword>DIRECTIONAL</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>$GUI</keyword>
    <keyword>OVERLAY</keyword>
    <application/>
  </script>

  <script ID="138" category="Isolated Command" name="DIRECTIONAL04.inr" title="DIRECTIONAL Display Command">
    <description>
      A DIRECTIONAL plot of an isotropic radially averaged
      emitting source comparing with or without using the RADIANCE
      option.
      $GUI is used to show chart with original display viewer
      which shows 0 180° hemisphere only.
    </description>
    <keyword>DIRECTIONAL</keyword>
    <keyword>Analysis</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>RADIANCE</keyword>
    <keyword>$GUI</keyword>
    <application/>
  </script>

  <script ID="139" category="Simple Problem" name="doe_lens.inr" title="DOE Lens">
    <description>
      A DOE lens example.  Multiple
      Surfaces are created with the MULTIPLE command
      whose intersection with the base surface
      defines the gratings lines. These lines are
      in 2PI phase steps. An F/5 DOE lens is created
      with on and off-axis irradiance distribution
      analyzed.
    </description>
    <keyword>Lenses</keyword>
    <keyword>doe</keyword>
    <keyword>GENERAL</keyword>
    <keyword>MULTIPLE</keyword>
    <keyword>SPREAD</keyword>
    <application/>
  </script>

  <script ID="140" category="Isolated Command" name="DOMACROS_01.inr" title="DOMACROS using FIRST, LAST and NEVER Options">
    <description>
      Controlling execution of user-defined macro having
      identical name to ASAP command.
    </description>
    <keyword>DOMACROS</keyword>
    <keyword>FLUX</keyword>
    <keyword>integral</keyword>
    <keyword>macros-user</keyword>
    <application/>
  </script>

  <script ID="141" category="Isolated Command" name="DOME_01.inr" title="Making Bumps using DOME">
    <description>
      The following example shows construction of bumps
      made with the DOME entity on a glass plate, shifted
      individually to specific locations.
    </description>
    <keyword>DOME</keyword>
    <keyword>diffuser</keyword>
    <keyword>lcd</keyword>
    <keyword>backlight</keyword>
    <keyword>dots</keyword>
    <keyword>bumps</keyword>
    <application/>
  </script>

  <script ID="142" category="Isolated Command" name="doublet01.inr" title="DOUBLET Lens">
    <description>A simple doublet lens.</description>
    <keyword>DOUBLET</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="143" category="Simple Problem" name="Do_Trick01.inr" title="Multiple Media Indices using $DO">
    <description>
      Setting up a large number of wavelengths
      and media using $DO rather than typing it all by hand.
    </description>
    <keyword>Scripts</keyword>
    <keyword>MEDIA</keyword>
    <keyword>WAVELENGTHS</keyword>
    <keyword>$DO</keyword>
    <application/>
  </script>

  <script ID="144" category="Simple Problem" name="Do_Trick02.inr" title="Multiple Sources using $DO">
    <description>
      Making multiple oval emitting spheroids
      that get expanded and shifted by the loop counter.
    </description>
    <keyword>Scripts</keyword>
    <keyword>$DO</keyword>
    <keyword>EMITTING</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="145" category="Simple Problem" name="Do_Trick03.inr" title="Multiple Source Directions using $DO">
    <description>
      Making multiple grid sources or
      single ray sources incremented in direction
      using the loop counter. Saves entering an entire
      list of direction vectors by hand.
    </description>
    <keyword>Sources</keyword>
    <keyword>$DO</keyword>
    <keyword>direction</keyword>
    <application/>
  </script>

  <script ID="146" category="Simple Problem" name="Do_Trick04.inr" title="Array of Sources using $DO">
    <description>
      Making multiple EMITTING DATA sources
      in an array format but reducing the source count.
    </description>
    <keyword>Scripts</keyword>
    <keyword>$DO</keyword>
    <keyword>EMITTING</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="147" category="Simple Problem" name="Dual_GRIN_Coupling.inr" title="Coupling with Dual GRIN Fibers">
    <description>
      A model of two GRIN fibers on either side
      of an optic, in this case a glass slab. Shows how to
      determine the coupling efficiencies from input to
      output of the two-fiber system.  The first fiber mode is
      created using the FIBR shape option on the RAYSET command.
      [See SHAPE command in Help which describes the RAYSET  optional k and s parameters]
      This must be decomposed into a new set of Gaussian beams
      that describe this mode shape in order to trace it through
      the system. When it reaches the output of the second fiber,
      a FIELD is calculated and COUPLEd to the second fiber's
      mode to determine the overall coupling efficiency.
    </description>
    <keyword>Wave</keyword>
    <keyword>GRIN</keyword>
    <keyword>COUPLE</keyword>
    <keyword>DECOMPOSE</keyword>
    <keyword>FIELD</keyword>
    <keyword>FIBR</keyword>
    <keyword>RAYSET</keyword>
    <keyword>fiber</keyword>
    <application/>
  </script>

  <script ID="148" category="Isolated Command" name="dump01.inr" title="DUMP Rayset to File">
    <description>
      Dump the rayset on a rectangular
      detector coming from an emitting spheroid to
      a distribution file, TESTDUMP.DIS.
    </description>
    <keyword>DUMP</keyword>
    <keyword>rays</keyword>
    <keyword>output</keyword>
    <application/>
  </script>

  <script ID="149" category="Simple Problem" name="DVD_Player.inr" title="DVD Player">
    <description>
      DVD optical system illustrates method of
      exporting complex vector field measured at DVD
      landing to Lumerical FDTD Solutions file format.
      This example requires the OPTICAL module.
    </description>
    <keyword>Wave</keyword>
    <keyword>FIELD</keyword>
    <keyword>cvf</keyword>
    <keyword>laser</keyword>
    <application/>
  </script>

  <script ID="150" category="Isolated Command" name="edges01.inr" title="Simple Edge Aperture">
    <description>
      A rectangular aperture made
      from two EDGEs.
    </description>
    <keyword>EDGES</keyword>
    <keyword>aperture</keyword>
    <application/>
  </script>

  <script ID="151" category="Isolated Command" name="edges02.inr" title="Five Rectangular Edges">
    <description>
      5 different ways to enter
      the same rectangular edge with a width  of 2 and a height of 4.
    </description>
    <keyword>EDGES</keyword>
    <keyword>Edges</keyword>
    <application/>
  </script>

  <script ID="152" category="Isolated Command" name="edges03.inr" title="Flat Ring Baffle">
    <description>
      Two elliptical edges extruded together
      using second folrm of OBJECT command.
    </description>
    <keyword>EDGES</keyword>
    <keyword>ring</keyword>
    <keyword>baffle</keyword>
    <keyword>OBJECT</keyword>
    <application/>
  </script>

  <script ID="153" category="Simple Problem" name="EDGES_Corner.inr" title="Making Curved Sides with Corner">
    <description>
      Using $GRAB and the second form of OBJECT
      to make a seemless corner that joines two orthoganol
      sides made with bounded TUBEs. $GRAB is used to get
      point information from a base curve describing the
      rounded corner of the flat top.  New curves are generated
      that connect those grabbed points to the lower corner.
      The OBJECT command smoothly joines each curve to make
      a surface that fills in the corner. An emitter is used
      to check for leaks at the seams.
      Use the PRINT EDGES or ENTITIES to see the curves
      and bounding planes for the sides.
      Credit goes to Eric (JS) Hong) of I&amp;A Technology for submitting this example.
    </description>
    <keyword>Edges</keyword>
    <keyword>EDGES</keyword>
    <keyword>POINTS</keyword>
    <keyword>OBJECT</keyword>
    <keyword>corner</keyword>
    <keyword>$IF</keyword>
    <keyword>PRINT</keyword>
    <keyword>$GRAB</keyword>
    <keyword>TUBE</keyword>
    <application/>
  </script>

  <script ID="154" category="Isolated Command" name="EDGES_Extrude01.inr" title="Making a Semi-Circle Surface">
    <description>
      Extruding a LINE edge to an
      ARC edge, to make a semi-circular surface.
      A COMPOSITE could also be used, instead of
      using the second form of OBJECT.
    </description>
    <keyword>OBJECT</keyword>
    <keyword>LINE</keyword>
    <keyword>ARC</keyword>
    <keyword>EDGES</keyword>
    <keyword>COMPOSITE</keyword>
    <application/>
  </script>

  <script ID="155" category="Simple Problem" name="EDGES_Extrude02.inr" title="Extruding Two Non-Planar Edges">
    <description>
      Extrude two non-planar edges together to
      show that extrusion of edges does not require that
      the edges are planar.
    </description>
    <keyword>Edges</keyword>
    <keyword>extrude</keyword>
    <keyword>EDGES</keyword>
    <keyword>POINTS</keyword>
    <keyword>OBJECT</keyword>
    <application/>
  </script>

  <script ID="156" category="Simple Problem" name="Edge_Aperture.inr" title="Annular Ring Aperture">
    <description>
      Annular aperture made by bounding an Edge
      to an infinite plane and then adding an absorbing
      ellipse at center to result in a annular ring
      aperture.
    </description>
    <keyword>Edges</keyword>
    <keyword>aperture</keyword>
    <keyword>annular</keyword>
    <keyword>EDGES</keyword>
    <keyword>circular</keyword>
    <keyword>BOUNDS</keyword>
    <application/>
  </script>

  <script ID="157" category="Simple Problem" name="edge_circles.inr" title="Five Circle Methods">
    <description>
      A circle is made five different ways using
      EDGES. The first four circles produce identical points and connection
      factors as seen from the PRINT statement.
    </description>
    <keyword>Edges</keyword>
    <keyword>EDGES</keyword>
    <keyword>circle</keyword>
    <keyword>RACETRACK</keyword>
    <keyword>CURVES</keyword>
    <keyword>ARC</keyword>
    <keyword>POINTS</keyword>
    <keyword>SEGMENTS</keyword>
    <keyword>SMOOTH</keyword>
    <keyword>PRINT</keyword>
    <application/>
  </script>

  <script ID="158" category="Simple Problem" name="Edge_Composite.inr" title="COMPOSITE for Attaching Edges">
    <description>
      Shows how to attach several edges
      together to make one object, using the COMPOSITE
      command.
    </description>
    <keyword>Edges</keyword>
    <keyword>EDGES</keyword>
    <keyword>COMPOSITE</keyword>
    <keyword>ARC</keyword>
    <keyword>LINE</keyword>
    <application/>
  </script>

  <script ID="159" category="Simple Problem" name="Edge_Curve_Lofted.inr" title="One User-defined Edge Extruded along Another">
    <description>
      A somewhat complex task of producing a surface made
      from two orthoganol sine functions. The end result appears as if
      a sinusoidal edge was dragged perpendicularly along another sinusoidal
      edge. Using a tricky combination of ALIGN and PLACE in a loop, one edge is
      recreated multiple times to follow the path of the edge in the
      orthoganol direction. All of the edges are then extruded together
      with the OBJECT command to produce a single wavy surface.
    </description>
    <keyword>Edges</keyword>
    <keyword>EDGES</keyword>
    <keyword>USERCURVE</keyword>
    <keyword>$FCN</keyword>
    <keyword>extrude</keyword>
    <keyword>curve</keyword>
    <keyword>OBJECT</keyword>
    <keyword>ALIGN</keyword>
    <keyword>PLACE</keyword>
    <keyword>MAP</keyword>
    <keyword>SLOPES</keyword>
    <application/>
  </script>

  <script ID="160" category="Isolated Command" name="edge_line02.inr" title="Extruded Line Edges">
    <description>
      Extruding two line edges to
      make an odd-shaped surface.
    </description>
    <keyword>LINE</keyword>
    <keyword>EDGES</keyword>
    <keyword>OBJECT</keyword>
    <application/>
  </script>

  <script ID="161" category="Isolated Command" name="Edge_Patches.inr" title="The PATCHES Command">
    <description>
      This example shows how to use the
      PATCHES command to determine surface meshing.
    </description>
    <keyword>PATCHES</keyword>
    <keyword>EDGES</keyword>
    <keyword>POINTS</keyword>
    <application/>
  </script>

  <script ID="162" category="Simple Problem" name="Edge_Points_Bezier.inr" title="Control Vertex Weighting Factors">
    <description>
      Various results obtained by different control
      vertex weighting values, using the quadratic bezier connection
      parameter of 2.
    </description>
    <keyword>Edges</keyword>
    <keyword>POINTS</keyword>
    <keyword>EDGES</keyword>
    <keyword>quadratic</keyword>
    <keyword>Bezier</keyword>
    <keyword>weighting</keyword>
    <application/>
  </script>

  <script ID="163" category="Simple Problem" name="EDGE_Surfaces01.inr" title="Surfaces Made from Edges">
    <description>
      Attaching a LINE edge to an
      ARC edge with COMPOSITE makes a semi-circular
      surface, unless a SWEEP command is used as
      shown.  Now it becomes a ribbon or tube-like
      surface in the perpendicular direction.
    </description>
    <keyword>Edges</keyword>
    <keyword>COMPOSITE</keyword>
    <keyword>LINE</keyword>
    <keyword>ARC</keyword>
    <keyword>SWEEP</keyword>
    <application/>
  </script>

  <script ID="164" category="Simple Problem" name="Edge_Sweep_Bezier.inr" title="Swept Bezier Edge">
    <description>
      A Bezier edge is created with EDGE POINTS and
      swept 360° into a conic section. It is then compared with
      a standard OPTICAL surface using the same parameters.
    </description>
    <keyword>Edges</keyword>
    <keyword>EDGES</keyword>
    <keyword>POINTS</keyword>
    <keyword>Bezier</keyword>
    <keyword>SWEEP</keyword>
    <keyword>AXIS</keyword>
    <keyword>OPTICAL</keyword>
    <application/>
  </script>

  <script ID="165" category="Simple Problem" name="edge_sweep_points.inr" title="Making a Lens Cell">
    <description>
      A lens cell is created with EDGE POINTS
      escribing the local cross section. Using SWEEP
      AXIS, it is swept into a 3-dimensional holder for  a lens.
    </description>
    <keyword>Edges</keyword>
    <keyword>EDGES</keyword>
    <keyword>POINTS</keyword>
    <keyword>3d</keyword>
    <keyword>SWEEP</keyword>
    <keyword>AXIS</keyword>
    <keyword>lens</keyword>
    <keyword>cell</keyword>
    <application/>
  </script>

  <script ID="166" category="Simple Problem" name="Edge_Swept_Along_USERCURV_01.inr" title="Sawtooth Edge Swept along USERCURVE Ellipse Function">
    <description>
      A somewhat complex usage of ALIGN, PLACE and the OBJECT command
      to sweep a sawtooth edge made from POINTS along a USERCURVE function. In this
      case, the fuction is a simple ellipse. The end result is that the sawtooth
      follows around the curve keeping its plane perpendicular at all times to the
      ellipse. With ALIGN and PLACE in a loop, the edge is recreated multiple times
      to follow the entire path of the ellipse. The edges are then extruded together
      with the OBJECT command to produce a single continuous grooved surface.
    </description>
    <keyword>Edges</keyword>
    <keyword>EDGES</keyword>
    <keyword>USERCURVE</keyword>
    <keyword>$FCN</keyword>
    <keyword>extrude</keyword>
    <keyword>curve</keyword>
    <keyword>OBJECT</keyword>
    <keyword>ALIGN</keyword>
    <keyword>PLACE</keyword>
    <application/>
  </script>

  <script ID="167" category="Isolated Command" name="ellipse01.inr" title="A Glass Plate">
    <description>
      A glass plate made with
      ELLIPSE edges. The edge is made by extruding
      the two with the OBJECT command.
    </description>
    <keyword>ELLIPSE</keyword>
    <keyword>EDGES</keyword>
    <application/>
  </script>

  <script ID="168" category="Isolated Command" name="ellipse02.inr" title="A Partial Ellipse">
    <description>
      A partial ellipse shown
      with PLOT EDGES command. A similar
      result could be had using ARC.
    </description>
    <keyword>ELLIPSE</keyword>
    <keyword>EDGES</keyword>
    <application/>
  </script>

  <script ID="169" category="Isolated Command" name="ellipse03.inr" title="A Faceted Tube">
    <description>
      An extrusion of two ellipse
      edges. The resulting tube has 16 facets
      due to the default 16 segments for each
      ellipse.
    </description>
    <keyword>ELLIPSE</keyword>
    <keyword>EDGES</keyword>
    <keyword>extrude</keyword>
    <application/>
  </script>

  <script ID="170" category="Isolated Command" name="EMITTING_BOX.inr" title="Emitting Box">
    <description>
      Demonstration of an EMITTING
      BOX. A volume emitter.
    </description>
    <keyword>EMITTING</keyword>
    <keyword>BOX</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="171" category="Isolated Command" name="emitting_cone.inr" title="Emitting Cone">
    <description>
      Demonstration of EMITTING CONE.
      A surface emitter which is Lambertian by
      default.
    </description>
    <keyword>EMITTING CONE</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="172" category="Simple Problem" name="EMITTING_DATA.inr" title="Using the EMITTING DATA Command">
    <description>
      An emitting spheroid surrounded by an
      absorbing sphere at which the rayset is saved and then
      in a separate action, the rayset is re-emitted using the
      EMITTING DATA command
    </description>
    <keyword>Sources</keyword>
    <keyword>EMITTING DATA</keyword>
    <keyword>Tracing</keyword>
    <keyword>DUMP</keyword>
    <keyword>PLOT RAYS</keyword>
    <application/>
  </script>

  <script ID="173" category="Simple Problem" name="Emitting_Dir_Clipping.inr" title="Clipping Emitting Surfaces">
    <description>
      Simple demo of how emitting surfaces work in
      direction space.  Allows easy viewing of effects from
      different half-angle clipping entries.
    </description>
    <keyword>Sources</keyword>
    <keyword>EMITTING</keyword>
    <keyword>clipping</keyword>
    <keyword>direction</keyword>
    <keyword>PLOT</keyword>
    <keyword>RAYS</keyword>
    <keyword>ARROWS</keyword>
    <application/>
  </script>

  <script ID="174" category="Isolated Command" name="EMITTING_ENTITY.inr" title="Emitting ENTITY">
    <description>
      Demonstration of an EMITTING
      ENTITY. A surface emitter.
    </description>
    <keyword>EMITTING</keyword>
    <keyword>ENTITY</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="175" category="Isolated Command" name="EMITTING_IES.inr" title="Emitting IES File">
    <description>
      Demonstration of making an emitter from
      an IES distribution file.  IES.
    </description>
    <keyword>EMITTING</keyword>
    <keyword>IES</keyword>
    <keyword>BILATERAL</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="176" category="Simple Problem" name="EMITTING_OBJECT01.inr" title="Emitting Half Cylinder">
    <description>
      Basic example of a bounded emitting  object.  Creating an emitter from a half tube.
      Only half of rays asked for are created due  to ray number being relative to the base entity
      being bounded.
    </description>
    <keyword>Sources</keyword>
    <keyword>cylinder</keyword>
    <keyword>EMITTING OBJECT</keyword>
    <application/>
  </script>

  <script ID="177" category="Simple Problem" name="EMITTING_OBJECT_About_Normal.inr" title="Defining Cone Angle of Emitting Object About Normal">
    <description>
      How to define a conical emission of emitting object about
      the surface Normal. The cone is defined by a scattering cone about the
      surface normal, which works for a non-planar object. A low density
      sampling of the surface is used here to show the individual ray cones,
      but increasing the number of source rays can quickly make it dense.
      Increasing scattered rays makes the rays in the individual cones more dense.
      It may be easier to see if you try it with the plane source by changing the
      object command to reference .3 rather than .2. You should see a well-defined
      conical output.
    </description>
    <keyword>Sources</keyword>
    <keyword>EMITTING OBJECT</keyword>
    <keyword>direction</keyword>
    <keyword>cone-angle</keyword>
    <keyword>emission</keyword>
    <application/>
  </script>

  <script ID="178" category="Simple Problem" name="EMITTING_OBJECT_Into_Angle.inr" title="Defining Angular Direction of Emitting Object">
    <description>
      Making an emitting object emit
      towards an angular direction.
    </description>
    <keyword>Sources</keyword>
    <keyword>EMITTING OBJECT</keyword>
    <keyword>direction</keyword>
    <keyword>cone-angle</keyword>
    <keyword>emission</keyword>
    <application/>
  </script>

  <script ID="179" category="Isolated Command" name="EMITTING_PYRAMID.inr" title="Emitting Pyramid">
    <description>
      Demonstration of an EMITTING
      PYRAMID. A volume emitter.
    </description>
    <keyword>EMITTING</keyword>
    <keyword>PYRAMID</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="180" category="Simple Problem" name="EMITTING_RAYS.inr" title="Using the EMITTING RAYS Command">
    <description>
      A single or multiple rays can be created
      with this command. In this example, an absorbing
      plane is placed to collect the emitted rays.
    </description>
    <keyword>Sources</keyword>
    <keyword>EMITTING RAYS</keyword>
    <keyword>Tracing</keyword>
    <keyword>PLOT RAYS</keyword>
    <application/>
  </script>

  <script ID="181" category="Isolated Command" name="emitting_rect.inr" title="Emitting Rectangle">
    <description>
      Demonstration of EMITTING RECT.
      A surface emitter which is Lambertian by
      default.
    </description>
    <keyword>EMITTING</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="182" category="Isolated Command" name="emit_spheroid01.inr" title="Emitting Spheroid">
    <description>
      Demonstration of an EMITTING
      SPHEROID. A volume emitter.
    </description>
    <keyword>EMITTING</keyword>
    <keyword>SPHEROID</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="183" category="Isolated Command" name="emit_spheroid02.inr" title="Composite Emitters">
    <description>How to make multiple composite emitters.</description>
    <keyword>EMITTING</keyword>
    <keyword>SPHEROID</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="184" category="Isolated Command" name="enclosed01.inr" title="Plotting Enclosed Energy">
    <description>
      Plot a Display file with the
      ENCLOSED command. The plot is of encircled energy vs.
      the radius of enclosing circle. In this example, a
      small emitting spheroid is inside an absorbing ellipsoid.
      Two plots compare ENCLOSED centered on the centroid
      and at the edge of the ellipsoid.
    </description>
    <keyword>ENCLOSED</keyword>
    <keyword>DISPLAY</keyword>
    <application/>
  </script>

  <script ID="185" category="Simple Problem" name="energy_conserv01.inr" title="Specular/Scatter Energy Conservation">
    <description>
      Conserving beam energy between
      specular and scattered rays using ROUGHNESS.
    </description>
    <keyword>Scatter</keyword>
    <keyword>ROUGHNESS</keyword>
    <keyword>SCATTER</keyword>
    <keyword>energy</keyword>
    <application/>
  </script>

  <script ID="186" category="Simple Problem" name="energy_conserv02.inr" title="Energy Conservation Output">
    <description>
      Output from Energy Conservation
      with ROUGHNESS example.
    </description>
    <keyword>Scatter</keyword>
    <keyword>STATS</keyword>
    <keyword>energy</keyword>
    <application/>
  </script>

  <script ID="187" category="Isolated Command" name="explode.inr" title="Exploding a Lens Sequence">
    <description>
      Exploding a lens sequence
      into separate surface objects.
    </description>
    <keyword>EXPLODE</keyword>
    <keyword>LENSES</keyword>
    <keyword>SEQUENCE</keyword>
    <application/>
  </script>

  <script ID="188" category="Simple Problem" name="Extended_Source_From_Data.inr" title="Source from User Data">
    <description>
      How to create an extended source with user data
      The "DISPLAY -9" tells ASAP to rewind the BRO009.DAT
      file and begin writing with the following format and data.
      In the example, since Z is given first, the display data
      will be in the Window of Y-X. Z will be starting position of
      extended source.
      The data that follows may be replaced with a $READ command
      followed by the file name containing much larger amounts of data
      data for much smoother results.
      The small data set here produces very low resolution results,
      but shows clearly how data is converted and distributed.
    </description>
    <keyword>Sources</keyword>
    <keyword>hand</keyword>
    <keyword>user data</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>SPOTS</keyword>
    <keyword>WRITE</keyword>
    <keyword>data</keyword>
    <keyword>input</keyword>
    <application/>
  </script>

  <script ID="189" category="Isolated Command" name="EXTREMES_POSITION_Radial_01.inr" title="Using EXTREMES POSITION Local to a Radial AXIS">
    <description>
      Demonstrate a source with obvious boundaries
      in the radial, tangential space produced by EXTREMES POSITION
      with an AXIS command. Show SPOTS POSITION for both Y,X
      position and for T, R, and output the latter's EXTREMES
      POSITION in R, T (cylindrical) coordinates.
    </description>
    <keyword>EXTREMES POSITION</keyword>
    <keyword>AXIS</keyword>
    <keyword>radial</keyword>
    <keyword>cylindrical</keyword>
    <keyword>Analysis</keyword>
    <application/>
  </script>

  <script ID="190" category="Simple Problem" name="fabry_perot.inr" title="Fabry-Perot Interferometer">
    <description>
      A simple Fabry-Perot interferometer showing
      the variation of throughput with wavelength. Takes some
      time to run.
    </description>
    <keyword>Wave</keyword>
    <keyword>Fabry-Perot</keyword>
    <keyword>diffraction</keyword>
    <keyword>$ITER</keyword>
    <application/>
  </script>

  <script ID="191" category="Isolated Command" name="facets01.inr" title="FACETS Object Modifier">
    <description>
      The FACETS command as an OBJECT
      modifier.
    </description>
    <keyword>FACETS</keyword>
    <keyword>OBJECT</keyword>
    <application/>
  </script>

  <script ID="192" category="Isolated Command" name="ffad01.inr" title="Full Field Aberration">
    <description>
      Full field aberration analysis
      of an f/1 mirror. A perturbed conic is used
      to generate spherical aberration. A grid of
      polar grids are sent toward the conic, each with
      a spread as determined by the GRID RECT below.
      The aberration across the entire field is analyzed
      at object 2, using two versions of FFAD.
    </description>
    <keyword>FFAD</keyword>
    <keyword>Analysis</keyword>
    <keyword>GRID</keyword>
    <keyword>aberration</keyword>
    <application/>
  </script>

  <script ID="193" category="Simple Problem" name="Fiber_Cone.inr" title="Tapered Fiber Cone">
    <description>
      This file shows how to create a tapered fiber cone using
      the TUBE command.  One cone makes the inner core and the other adds
      the cladding thickness.  End caps are made to cover the core and the
      cladding using surfaces bounded by the ends of tubes themselves.
      A grid of rays was added inside the big end of the core, to see the
      effects on the rays for different indices.
    </description>
    <keyword>Bounds</keyword>
    <keyword>fiber</keyword>
    <keyword>cone</keyword>
    <keyword>TUBE</keyword>
    <keyword>Interfaces</keyword>
    <keyword>BOUNDS</keyword>
    <application/>
  </script>

  <script ID="194" category="Simple Problem" name="Fiber_Mode.inr" title="Setting Fiber Mode with FIBR">
    <description>
      How to set a fiber mode using
      a single beam with a shape determined by the
      k and s parameters of the RAYSET command. Here,
      the FIBR shape option is used for a circular fiber
      and the normalized frequency (vn) is calculated from
      fiber's indices and the wavelength. The complex file
      created by the FIELD command may be used for laser
      coupling applications.
    </description>
    <keyword>Wave</keyword>
    <keyword>fiber</keyword>
    <keyword>mode</keyword>
    <keyword>shape</keyword>
    <keyword>FIBR</keyword>
    <keyword>RAYSET</keyword>
    <application/>
  </script>

  <script ID="195" category="Simple Problem" name="fiber_pipe.inr" title="Fiber Light Pipe">
    <description>
      A fiber light pipe made with
      TORUS and PLANE surfaces. The LIMITS command
      specifies which half of each torus to keep.
    </description>
    <keyword>Geometry</keyword>
    <keyword>TORUS</keyword>
    <keyword>LIMITS</keyword>
    <keyword>fiber</keyword>
    <keyword>pipe</keyword>
    <application/>
  </script>

  <script ID="196" category="Simple Problem" name="Fiber_Tapered.inr" title="Tapered Fiber as One Object">
    <description>
      This creates a tapered fiber as one object
      using a set of EDGE POINTS at equal angular separation,
      which are extruded together using the second form of
      the OBJECT command.  Note that the corners of the taper can have a tendency
      to leak if rays hit there exactly on axis from a grid.
      Avoid this by using a random set of rays.
    </description>
    <keyword>Edges</keyword>
    <keyword>fiber</keyword>
    <keyword>taper</keyword>
    <keyword>EDGES</keyword>
    <keyword>POINTS</keyword>
    <keyword>OBJECT</keyword>
    <application/>
  </script>

  <script ID="197" category="Isolated Command" name="field01.inr" title="Simple Diffraction Analysis">
    <description>
      Simple diffraction calculation
      of a plane wave in energy and amplitude.
    </description>
    <keyword>FIELD</keyword>
    <keyword>Wave</keyword>
    <keyword>diffraction</keyword>
    <application/>
  </script>

  <script ID="198" category="Isolated Command" name="field02.inr" title="Slicing Irradiance with FIELD">
    <description>
      Slicing an irradiance pattern
      using the FIELD command.
    </description>
    <keyword>FIELD</keyword>
    <keyword>irradiance</keyword>
    <keyword>psf</keyword>
    <application/>
  </script>

  <script ID="199" category="Simple Problem" name="field_display_options.inr" title="FIELD Display Options">
    <description>
      Shows all options available for
      displaying FIELD generated distribution data.
      Various DISPLAY options allow extraction of the
      different complex field components.
    </description>
    <keyword>Wave</keyword>
    <keyword>FIELD</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>ENERGY</keyword>
    <application/>
  </script>

  <script ID="200" category="Simple Problem" name="field_modulus.inr" title="FIELD MODULUS of Aberrated System">
    <description>
      Performing a FIELD MODULUS of an
      aberrated optical system. The analysis is contained
      in a macro which is called four times.
    </description>
    <keyword>Wave</keyword>
    <keyword>FIELD</keyword>
    <keyword>MODULUS</keyword>
    <keyword>diffraction</keyword>
    <keyword>macro</keyword>
    <keyword>aberrated</keyword>
    <keyword>UPDATE</keyword>
    <application/>
  </script>

  <script ID="201" category="Isolated Command" name="filament.inr" title="Filament Emitters">
    <description>
      Two filament emitters. One defined by a
      curve and the other by a function.
    </description>
    <keyword>FILAMENT</keyword>
    <keyword>EMITTING</keyword>
    <keyword>CURVES</keyword>
    <keyword>CHARACTER</keyword>
    <keyword>$FCN</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="202" category="Simple Problem" name="Fluorescence_Refl01.inr" title="Modeling Fluorescence in Reflection">
    <description>
      A model of fluorescence microscopy to show a new
      fluorescent source being born from volume absorption.  The
      Absorption data is stored to a file using the VOXELS command.
      The voxel region matches the size of the slab that is intended
      to fluoresce.
      It is illuminated by a source at one wavelength,
      and then re-emits at a new wavelength where there is less or no
      absorption.  Only the rays in the reverse direction are created
      using CLIP and a scattering diffuser is used to direct those rays
      more eficiently through the microscope.
    </description>
    <keyword>Interfaces</keyword>
    <keyword>Scatter</keyword>
    <keyword>diffuser</keyword>
    <keyword>MEDIA</keyword>
    <keyword>CLIP</keyword>
    <keyword>VOXELS</keyword>
    <keyword>ABSORBED</keyword>
    <keyword>fluorescence</keyword>
    <application/>
  </script>

  <script ID="203" category="Simple Problem" name="Fluorescence_Trans01.inr" title="Modeling Fluorescence in Transmission">
    <description>
      A model of a fluorescent slab that fluoresces  in transmission.
      The voxel region is set up to match the
      size of the slab.  The slab is illuminated by a Lambertian
      source at one wavelength, and then re-emits isotropically at
      a new wavelength, where there is less or no absorption. Some
      of the initial rays survive the transit through the material
      and this distribution is stored.  Only the +Z rays of the new
      source are created for tracing.  The result of this fluorescent
      source is added to the previous trace to show the combined
      result at the output of the slab.
    </description>
    <keyword>Interfaces</keyword>
    <keyword>MEDIA</keyword>
    <keyword>CLIP</keyword>
    <keyword>VOXELS</keyword>
    <keyword>ABSORBED</keyword>
    <keyword>COMBINE</keyword>
    <keyword>fluorescence</keyword>
    <application/>
  </script>

  <script ID="204" category="Isolated Command" name="FLUX_COHERENT.inr" title="Setting Coherent Source Flux">
    <description>
      Setting the flux of coherent sources
      based on the initial total "integral" of the FIELD.
      Flux is set on a per-ray basis.  It may be checked
      by performing another FIELD, as illustrated.
    </description>
    <keyword>FLUX</keyword>
    <keyword>Sources</keyword>
    <keyword>COHERENT</keyword>
    <keyword>FIELD</keyword>
    <application/>
  </script>

  <script ID="205" category="Isolated Command" name="FLUX_INCOHERENT.inr" title="Setting Incoherent Source Flux">
    <description>
      Setting the flux of incoherent sources
      based on their initial irradiance setting.
      Flux may be set on a per-ray basis or on the
      total of rays in the source.
    </description>
    <keyword>FLUX</keyword>
    <keyword>Sources</keyword>
    <keyword>INCOHERENT</keyword>
    <application/>
  </script>

  <script ID="206" category="Isolated Command" name="FLUX_Spectral.inr" title="Spectral Weighting of Flux">
    <description>
      Setting the flux of sources
      at different wavelengths to match a spectral
      curve. This uses the method of setting
      flux on a per-ray basis. FLUX TOTAL may
      be used as an alternative.
    </description>
    <keyword>FLUX</keyword>
    <keyword>Sources</keyword>
    <keyword>spectral</keyword>
    <keyword>INCOHERENT</keyword>
    <application/>
  </script>

  <script ID="207" category="Simple Problem" name="FLUX_Spectral02.inr" title="Assigning Flux to Separate Source Groups">
    <description>
      Assigning a total flux to individually apodized
      source groups, which have their own spectral response.  In
      this example, two groups of sources over the same wavelengths
      are apodized with a different thermal temperature using the
      SPECTRUM command.  FLUX TOTAL works after the first group is
      created, but the second group must be selected out separately
      in order to assign its own flux. ASAP weights the component
      fluxes of each group according to the spectral response at
      each wavelength.  A method for checking the spectral response
      of the sources, using $ITER, is shown.
    </description>
    <keyword>Sources</keyword>
    <keyword>SPECTRUM</keyword>
    <keyword>THERMAL</keyword>
    <keyword>FLUX</keyword>
    <keyword>SELECT</keyword>
    <keyword>$ITER</keyword>
    <keyword>$REG</keyword>
    <keyword>GET</keyword>
    <application/>
  </script>

  <script ID="208" category="Isolated Command" name="fmap01.inr" title="FMAP of FITTED Random Data">
    <description>
      Performing an FMAP of FITTED
      random data. A macro is used to generate the random points.
      A surface is created from a curve fitted explicitely to
      those points.  A contour slice of the surface is taken
      and stored in a display file. An isometric plot is shown
      of the data.  An alternative version of creating the fmap
      display file is given, using the hand-made method.
    </description>
    <keyword>FMAP</keyword>
    <keyword>FITTED</keyword>
    <keyword>EXPLICIT</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>hand</keyword>
    <keyword>macro</keyword>
    <application/>
  </script>

  <script ID="209" category="Isolated Command" name="focus01.inr" title="FOCUS Command Options">
    <description>
      Various options for using the
      FOCUS command. See below for explanations.
    </description>
    <keyword>FOCUS</keyword>
    <keyword>POSITION</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="210" category="Isolated Command" name="FOLD01.inr" title="Use of the FOLD command">
    <description>FOLD command with first element of Cooke Triplet</description>
    <keyword>FOLD</keyword>
    <keyword>DISPLAY</keyword>
    <application/>
  </script>

  <script ID="211" category="Isolated Command" name="form01.inr" title="Modifying Display Data with FORM">
    <description>
      Shows two uses for the FORM command
      to either take the square root of the display
      data or the square. An EMITTING DISK traces to
      a detector with an obscuring disk in between.
      An ISOMETRIC plot of the detector is shown for
      each FORM version.
    </description>
    <keyword>FORM</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>ISOMETRIC</keyword>
    <keyword>AVERAGE</keyword>
    <application/>
  </script>

  <script ID="212" category="Simple Problem" name="fresnel_elliptical01.inr" title="Multi-Object Elliptical Fresnel">
    <description>
      An elliptical Fresnel lens made with EDGE
      ELLIPSE's and the first form of the OBJECT command
      which extrudes two edges together. This makes the ring
      surfaces and walls seen in the 3D viewer as separate
      objects.  A center ellipse is made separately
      with a SWEEP POSITION in order to get the final cone in the
      center. See Fresnel_Elliptical02 for a better way to
      to make this using only two objects.
    </description>
    <keyword>Edges</keyword>
    <keyword>Fresnel</keyword>
    <keyword>ELLIPSE</keyword>
    <keyword>EDGES</keyword>
    <keyword>SMOOTH</keyword>
    <keyword>OBJECT</keyword>
    <application/>
  </script>

  <script ID="213" category="Simple Problem" name="fresnel_elliptical02.inr" title="Simple Elliptical Fresnel">
    <description>
      An elliptical Fresnel lens made with EDGE
      ELLIPSE's and the second form of the OBJECT command.
      This creates all the ring surfaces and walls seen in
      the 3D viewer.  A center ellipse is made separately
      with a SWEEP POSITION in order to get the final cone in the
      center.
    </description>
    <keyword>Edges</keyword>
    <keyword>Fresnel</keyword>
    <keyword>ELLIPSE</keyword>
    <keyword>EDGES</keyword>
    <keyword>SMOOTH</keyword>
    <keyword>OBJECT</keyword>
    <application/>
  </script>

  <script ID="214" category="Simple Problem" name="Fresnel_Lens01.inr" title="Fresnel Lens by Redefining Normal">
    <description>
      This shows how to simulate a Fresnel lens by redefining
      the Normal of a plane surface with a USERSAG TORIC surface.
    </description>
    <keyword>Geometry</keyword>
    <keyword>Fresnel</keyword>
    <keyword>lens</keyword>
    <keyword>REDEFINE</keyword>
    <keyword>NORMAL</keyword>
    <keyword>USERSAG</keyword>
    <keyword>TORIC</keyword>
    <application/>
  </script>

  <script ID="215" category="Simple Problem" name="Fresnel_Lens02.inr" title="Fresnel Lens Using EDGE POINTS">
    <description>
      Making a Fresnel lens with EDGE POINTS
      in 2D form. A profile is made of one half of the
      back side of the lens which is then swept about
      the center to make the surface. This is combined
      with a tube for the outer edge and a plane for the
      front side.
    </description>
    <keyword>Edges</keyword>
    <keyword>Fresnel</keyword>
    <keyword>POINTS</keyword>
    <keyword>EDGES</keyword>
    <keyword>2d</keyword>
    <application/>
  </script>

  <script ID="216" category="Simple Problem" name="Fresnel_Lens03.inr" title="Create Your Own Fresnel Lens">
    <description>
      This file will ask the user for inputs
      about a fresnel lens.  A fresnel lens with zones of
      equal frequency or zones of equal depth can be created.
    </description>
    <keyword>Edges</keyword>
    <keyword>Fresnel</keyword>
    <keyword>POINTS</keyword>
    <keyword>EDGES</keyword>
    <keyword>lens</keyword>
    <keyword>Macros_user</keyword>
    <keyword>$SCR</keyword>
    <keyword>$IF</keyword>
    <application/>
  </script>

  <script ID="217" category="Simple Problem" name="FTIR.inr" title="Frustrated Total Internal Reflectance">
    <description>
      Simulates the reflectance at a thin airgap interface
      between two BK7 prisms. Air gap is defined as a COATING LAYER.
      The second syntax of the $ITER command is used to find the gap
      for a desired reflectance. Edit file for different glass types.
    </description>
    <keyword>Tracing</keyword>
    <keyword>tir</keyword>
    <keyword>COATINGS</keyword>
    <keyword>LAYERS</keyword>
    <keyword>$ITER</keyword>
    <keyword>PATHS</keyword>
    <keyword>$SCR</keyword>
    <application/>
  </script>

  <script ID="218" category="Isolated Command" name="Gamma_Distribution.inr" title="Creating a Gamma Distribution Function">
    <description>
      Creates the standard Gamma distribution using
      $FCN, then plots the distribution using $EVAL.  This could
      be applied to a MIE particle size distribution, for example.
    </description>
    <keyword>$EVAL</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>distribution</keyword>
    <keyword>FACT</keyword>
    <keyword>$FCN</keyword>
    <keyword>gamma</keyword>
    <application/>
  </script>

  <script ID="219" category="Isolated Command" name="gaussian01.inr" title="The GAUSSIAN Command">
    <description>A simple look at the GAUSSIAN command output.</description>
    <keyword>GAUSSIAN</keyword>
    <keyword>Wave</keyword>
    <keyword>BEAMS</keyword>
    <keyword>FIELD</keyword>
    <application/>
  </script>

  <script ID="220" category="Simple Problem" name="Gaussian_Phase_Hand.inr" title="Hand-made Complex Field">
    <description>
      Make a complex field "by hand" by placing the
      amplitude and phase values into BRO029.DAT.
      In  this case we want the amplitude to be one (1) so
      we can multiply one field by another without
      changing the amplitude.  We only want to
      offset the phase.  For this example, the phase
      offset is a constant stored in the variable
      named "P".  The second line after the DISPLAY command
      sets up the data format.  Since Z is first, the FIELD
      (at Z=0) will be in the plane (Window) of X-Y.
      $READ  may be used to import data from a file rather than being
      in line.
    </description>
    <keyword>Wave</keyword>
    <keyword>Gaussian</keyword>
    <keyword>FIELD</keyword>
    <keyword>DECOMPOSE</keyword>
    <keyword>phase</keyword>
    <keyword>complex</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>hand</keyword>
    <application/>
  </script>

  <script ID="221" category="Simple Problem" name="gaussian_rays.inr" title="Gaussian Distribution of Rays">
    <description>
      A function acts as a gaussian
      random number generator, used to make a set of
      rays with a Gaussian spatial distribution.
    </description>
    <keyword>Sources</keyword>
    <keyword>Gaussian</keyword>
    <keyword>random</keyword>
    <keyword>rays</keyword>
    <application/>
  </script>

  <script ID="222" category="Simple Problem" name="Gaussian_Waist_Find.inr" title="Finding the Gaussian Waist">
    <description>A Method for finding the Gaussian waist of a beam.</description>
    <keyword>Wave</keyword>
    <keyword>GAUSSIAN</keyword>
    <keyword>WAIST</keyword>
    <keyword>FIELD ENERGY</keyword>
    <keyword>FIELD</keyword>
    <keyword>beam waist</keyword>
    <keyword>LIT</keyword>
    <application/>
  </script>

  <script ID="223" category="Isolated Command" name="get01.inr" title="GETing Ray Data">
    <description>How to GET ray data.</description>
    <keyword>GET</keyword>
    <keyword>rays</keyword>
    <application/>
  </script>

  <script ID="224" category="Simple Problem" name="Ghost_Analysis.inr" title="Ghost Analysis Showing Multiple Paths">
    <description>
      A Triplet lens system is used to demonstrate
      real ghost image analysis. Initially a plot of the lens system
      is shown with an on-axis and off-axis source. Then SPLIT
      is set to 2 and a single source is traced.
      Children and grandchildren rays are produced and generate
      alternate paths to the target. A spread function of
      imaged and ghost rays is performed showing radial
      distance using THE COLENGTH modifier or by SHAPEing the
      ghost rays first. Finally, individual ghost paths are traced
      using SAVEd HISTORY file.
    </description>
    <keyword>Lenses</keyword>
    <keyword>ghost</keyword>
    <keyword>LENSES</keyword>
    <keyword>triplet</keyword>
    <keyword>SPREAD</keyword>
    <keyword>COLENGTH</keyword>
    <keyword>PATHS</keyword>
    <keyword>HISTORY</keyword>
    <application/>
  </script>

  <script ID="225" category="Isolated Command" name="glass_plate01.inr" title="Glass Plate Using SURFACE">
    <description>A Glass plate made with surfaces.</description>
    <keyword>SURFACE</keyword>
    <keyword>PLANE</keyword>
    <keyword>TUBE</keyword>
    <keyword>glass</keyword>
    <application/>
  </script>

  <script ID="226" category="Isolated Command" name="glass_plate02.inr" title="Glass Plate Using LENSES">
    <description>A Glass plate made with a lens sequence.</description>
    <keyword>LENSES</keyword>
    <keyword>SEQUENCE</keyword>
    <keyword>glass</keyword>
    <application/>
  </script>

  <script ID="227" category="Isolated Command" name="graph.inr" title="GRAPH Display Command">
    <description>
      The GRAPH command for plotting
      a 2-dimensional slice of the distribution.
      Performed in DISPLAY mode.  It does not modify
      display data.
    </description>
    <keyword>GRAPH</keyword>
    <keyword>DISPLAY</keyword>
    <application/>
  </script>

  <script ID="228" category="Simple Problem" name="grating_linear.inr" title="Simple Linear Grating">
    <description>
      Simple grating made with a single
      MULTIPLE surface to create the diffractive lines.
      Two orders of diffraction and their efficiencies
      are specified. The trace plot shows the second
      order rays produced.
    </description>
    <keyword>Gratings</keyword>
    <keyword>doe</keyword>
    <keyword>DIFFRACT</keyword>
    <keyword>MULTIPLE</keyword>
    <keyword>diffraction</keyword>
    <application/>
  </script>

  <script ID="229" category="Simple Problem" name="grating_linear02.inr" title="Linear Diffraction with R and T">
    <description>
      Linear grating made with a single
      MULTIPLE surface to create the diffractive lines.
      Three orders of diffraction and their efficiencies
      are specified. The trace plot shows the three orders
      in reflection and transmission.
    </description>
    <keyword>Gratings</keyword>
    <keyword>doe</keyword>
    <keyword>DIFFRACT</keyword>
    <keyword>MULTIPLE</keyword>
    <keyword>linear</keyword>
    <keyword>diffraction</keyword>
    <application/>
  </script>

  <script ID="230" category="Simple Problem" name="grating_shearing.inr" title="Grating Shearing Interferometer Analysis">
    <description>
      Single beam analysis of a Grating
      Shearing Interferometer. Two pairs of diffraction gratings
      are placed at the focus of a parabolic mirror under test.
      Each pair of gratings consists of two gratings with slightly
      different periods; these are located a short distance apart.
      ASAP is instructed to generate +1, -1, and 0 diffracted orders.
      SPLIT is defaulted to 1 so that the diffracted orders are not
      additionally diffracted. When light reflected from the parabolic
      mirror intersects the gratings, 12 diffracted diverging beams
      are generated. These beams interfere at the detector plane to
      create a fringe pattern. The contours of the fringe pattern are
      an indication of the aberrations caused by the mirror.
    </description>
    <keyword>Gratings</keyword>
    <keyword>Analysis</keyword>
    <keyword>psf</keyword>
    <keyword>aperture</keyword>
    <keyword>beams</keyword>
    <keyword>SPREAD</keyword>
    <keyword>filter</keyword>
    <keyword>sampling</keyword>
    <application/>
  </script>

  <script ID="231" category="Isolated Command" name="grid_elliptic01.inr" title="Elliptical Grid: Equally Spaced">
    <description>
      Defines a grid of rays
      in the yz plane at x=10. The extent of
      the grid in the y direction is 4 to 14;
      the extent in the z direction is -5 to 5.
      Eighty rays are generated. The grid is
      contained within a circular aperture.
    </description>
    <keyword>GRID</keyword>
    <keyword>ELLIPTIC</keyword>
    <application/>
  </script>

  <script ID="232" category="Isolated Command" name="grid_elliptic02.inr" title="Elliptical Grid: Non-equally Spaced">
    <description>
      Defines a grid of rays
      in the yz plane at x = 10. The extent
      of the grid in the y direction is -2 to 2;
      the extent in the z direction is -5 to 5.
      One hundred and sixty rays are generated.
      The grid is contained within an elliptical
      aperture.
    </description>
    <keyword>GRID</keyword>
    <keyword>ELLIPTIC</keyword>
    <application/>
  </script>

  <script ID="233" category="Isolated Command" name="grid_object.inr" title="Object-based Ray Grid">
    <description>
      Defines a uniform grid of rays
      on an object. In the case of an edge object,
      the rays lie at the center of each facet.
      The number of rays can be controlled by the
      FACETS modifier.
    </description>
    <keyword>GRID</keyword>
    <keyword>OBJECT</keyword>
    <application/>
  </script>

  <script ID="234" category="Isolated Command" name="grid_polar01.inr" title="Hexapolar Grid of Rays">
    <description>
      Defines a hexapolar grid
      of rays in the z plane at z = 5. This
      uses the short form of the command.
      The extent of the grid in the radial
      direction is 0 to 3. The extent in the
      azimuthal direction is 0 to 360 degrees.
      There are five rays in the radial direction
      and six rays in the first ring, thereby making
      the grid hexapolar. Ninety-one rays are
      generated.
    </description>
    <keyword>GRID</keyword>
    <keyword>POLAR</keyword>
    <application/>
  </script>

  <script ID="235" category="Isolated Command" name="grid_polar02.inr" title="Polar Grid of Rays">
    <description>
      Defines a polar grid of
      rays in the xz plane at y=1. The extent
      of the grid in the radial direction is 0 to 5.
      The extent in the azimuthal direction 0 to
      360 degrees. There are 10 rays in the radial
      direction and 15 rays in the first ring about
      the center. One hundred and fifty-one rays
      are generated. This is the long form of the
      command which gives a straight spoked pattern.
    </description>
    <keyword>GRID</keyword>
    <keyword>POLAR</keyword>
    <application/>
  </script>

  <script ID="236" category="Isolated Command" name="grid_rect01.inr" title="Rectangular Grid: Equally Spaced">
    <description>
      Defines a grid of rays in
      the yz plane at x=10. The extent of the
      grid in the y direction is 4 to 14;
      the extent in the z direction is -5 to 5.
      One hundred rays are generated. The grid
      is equally spaced in both dimensions.
    </description>
    <keyword>GRID</keyword>
    <keyword>RECT</keyword>
    <application/>
  </script>

  <script ID="237" category="Isolated Command" name="grid_rect02.inr" title="Rectangular Grid: Non-equally Spaced">
    <description>
      Defines a grid of rays in
      the yz plane at x=10. The extent of the
      grid in the y direction is -2 to 2; the
      extent in the z direction is -5 to 5.
      Two hundred rays are generated. This is
      a non-equally spaced grid.
    </description>
    <keyword>GRID</keyword>
    <keyword>RECT</keyword>
    <application/>
  </script>

  <script ID="238" category="Simple Problem" name="GRID_WINDOW.inr" title="Using the GRID WINDOW Command">
    <description>
      Creates a rectangular raster-type ray grid
      using the current WINDOW and PIXELS settings.
    </description>
    <keyword>Sources</keyword>
    <keyword>GRID WINDOW</keyword>
    <keyword>PLOT RAYS</keyword>
    <application/>
  </script>

  <script ID="239" category="Isolated Command" name="GRIN_ARRAY01.inr" title="Array of GRINs">
    <description>
      Example of a GRIN lens array. Features
      a bi-planer lens where the GRIN is actually doing
      the focusing.
    </description>
    <keyword>GRIN</keyword>
    <keyword>FUNCTION</keyword>
    <keyword>GENERAL</keyword>
    <keyword>ARRAY</keyword>
    <application/>
  </script>

  <script ID="240" category="Isolated Command" name="grin_dispersive.inr" title="Dispersive GRIN Systems">
    <description>
      Modeling a dispersive GRIN  system.
      In this case, it's a gradient index
      photographic lens (polychromatic version). This
      is only a partial file.
    </description>
    <keyword>GRIN</keyword>
    <keyword>MEDIA</keyword>
    <keyword>FUNCTION</keyword>
    <keyword>GENERAL</keyword>
    <application/>
  </script>

  <script ID="241" category="Simple Problem" name="grin_lens01.inr" title="Grin Lens Optimization">
    <description>A GRIN lens optimized for best focus.</description>
    <keyword>Interfaces</keyword>
    <keyword>GRIN</keyword>
    <keyword>$ITER</keyword>
    <keyword>macro</keyword>
    <keyword>$DO</keyword>
    <keyword>FUNCTION</keyword>
    <application/>
  </script>

  <script ID="242" category="Isolated Command" name="grin_lens02.inr" title="GRIN Photographic Lens">
    <description>Gradient index photographic lens.</description>
    <keyword>GRIN</keyword>
    <keyword>MEDIA</keyword>
    <keyword>FUNCTION</keyword>
    <keyword>lens</keyword>
    <application/>
  </script>

  <script ID="243" category="Isolated Command" name="grin_radial01.inr" title="GRIN Medium with Radial Variation">
    <description>
      Example of a GRIN refractive material.
      Trace a collimated source of rays through the material
      and display the TRACE, SPOTS, and ISOMETRIC graphics.
      Show the results in the 3D-Viewer.
    </description>
    <keyword>GRIN</keyword>
    <keyword>MEDIA</keyword>
    <keyword>FUNCTION</keyword>
    <keyword>radial</keyword>
    <application/>
  </script>

  <script ID="244" category="Isolated Command" name="grin_radial02.inr" title="Radial GRIN Fiber">
    <description>
      Example of a GRIN refractive material.
      Trace a collimated source of rays through the material
      and do various plots of fiber and rays.
    </description>
    <keyword>GRIN</keyword>
    <keyword>MEDIA</keyword>
    <keyword>FUNCTION</keyword>
    <keyword>radial</keyword>
    <keyword>fiber</keyword>
    <application/>
  </script>

  <script ID="245" category="Isolated Command" name="grin_radial03.inr" title="Radial GRIN Using a SECH Function">
    <description>
      Example of a GRIN fiber using a Hyperbolic Secant function.
      Traces a collimated source of rays through the material
      and plots slices through the rod.
    </description>
    <keyword>GRIN</keyword>
    <keyword>MEDIA</keyword>
    <keyword>FUNCTION</keyword>
    <keyword>radial</keyword>
    <keyword>fiber</keyword>
    <keyword>SECH</keyword>
    <keyword>hyperbolic</keyword>
    <application/>
  </script>

  <script ID="246" category="Isolated Command" name="GRIN_Test.inr" title="GRIN Media">
    <description>
      A demonstration of light bending
      through a gradient index material. Change the GRIN
      thickness or the step size to see the different
      effects in the plot.
    </description>
    <keyword>GRIN</keyword>
    <keyword>MEDIA</keyword>
    <keyword>axial</keyword>
    <keyword>index</keyword>
    <keyword>step</keyword>
    <keyword>GENERAL</keyword>
    <application/>
  </script>

  <script ID="247" category="Isolated Command" name="group01.inr" title="Grouping Objects">
    <description>Various ways of GROUPing objects.</description>
    <keyword>GROUP</keyword>
    <keyword>Manipulating</keyword>
    <application/>
  </script>

  <script ID="248" category="Isolated Command" name="group02.inr" title="Grouping Objects for Shifting/Rotating">
    <description>
      Select groups of objects to
      shift and/or rotate. Nine elliptical surfaces
      are created. The first 3 are shifted and rotated.
      The second 3 are shifted and rotated. The last 3
      are shifted. The plot shows the before and after.
    </description>
    <keyword>GROUP</keyword>
    <keyword>Manipulating</keyword>
    <application/>
  </script>

  <script ID="249" category="Simple Problem" name="grouping01.inr" title="Grouping Objects with Sources">
    <description>
      How to group selected objects and sources
      so that they may be rotated and shifted together.  This
      uses the SOURCES modifier of the GROUP command to add
      the desired sources to the group.
    </description>
    <keyword>Manipulating</keyword>
    <keyword>GROUP</keyword>
    <keyword>Sources</keyword>
    <keyword>ROTATE</keyword>
    <keyword>SHIFT</keyword>
    <application/>
  </script>

  <script ID="250" category="Isolated Command" name="harvey_plot.inr" title="HARVEY PLOT Display">
    <description>
      How to use PLOT option on
      HARVEY model and call up the display data
      for further analysis. The PIXELS command
      sets the resolution for these plots and
      the display data.
    </description>
    <keyword>HARVEY</keyword>
    <keyword>PLOT</keyword>
    <keyword>MODELS</keyword>
    <keyword>PIXELS</keyword>
    <application/>
  </script>

  <script ID="251" category="Simple Problem" name="header_change.inr" title="Changing a Dump File Wavelength">
    <description>
      Shows how to modify a display file header
      to change the wavelength setting.  A ray file created
      with a DUMP command has the wavelength of the source
      saved in the header of the file.  If these rays are
      used again for further ray tracing, they will remain
      at that wavelength.  A new WAVELENGTH command before
      EMITTING DATA will not change that.  The Header of the
      file needs modified to place a 0 in the first wavelength
      number.  This allows the wavelength to be changed by
      the next WAVELENGTHS command.  Of course the wavelength
      could be specified directly, but the former method
      allows the option of automating the process with a macro.
    </description>
    <keyword>Tracing</keyword>
    <keyword>HEADER</keyword>
    <keyword>WAVELENGTH</keyword>
    <keyword>EMITTING</keyword>
    <keyword>DUMP</keyword>
    <keyword>GET</keyword>
    <keyword>WRITE</keyword>
    <application/>
  </script>

  <script ID="252" category="Simple Problem" name="Header_Change02.inr" title="Changing Title of Field Plot or Picture">
    <description>
      How to write a new sub-title to the current
      display file for subsequent plotting or for the PICTURE
    </description>
    <keyword>Wave</keyword>
    <keyword>HEADER</keyword>
    <keyword>FIELD</keyword>
    <keyword>title</keyword>
    <keyword>plot</keyword>
    <application/>

  </script>

  <script ID="253" category="Simple Problem" name="Heliostat_Scatter_01.inr" title="Scatter Towards Array of Heliostats">
    <description>
      The following script locates a source and specularly
      scatters light towards an array of heliostat mirrors.
      The position of the mirrors is located by x,y,z coordinates.
      Coordinates can be read from a text file or read in-line (currently).
      With the 4th data column, the mirrors are rotated about the Y-axis
      (easily modified for rotating about other axes).
    </description>
    <keyword>Scatter</keyword>
    <keyword>SCATTER</keyword>
    <keyword>TOWARDS</keyword>
    <keyword>heliostat</keyword>
    <keyword>solar</keyword>
    <keyword>mirror</keyword>
    <application/>
  </script>

  <script ID="254" category="Isolated Command" name="HELIX01.inr" title="Use of the HELIX command">
    <description>
      Create an EDGE HELIX and make it into an
      EMITTING ENTITY and an EMITTING OBJECT.
    </description>
    <keyword>EDGE</keyword>
    <keyword>HELIX</keyword>
    <keyword>EMITTING ENTITY</keyword>
    <keyword>EMITTING OBJECT</keyword>
    <application/>
  </script>

  <script ID="255" category="Simple Problem" name="HEX_PYRAMID_ARRAY_CROSSED_ROOFS.inr" title="Hex pyramid array by bounded, crossed ROOFS">
    <description>
      An ARRAY of hexagonal pyramids is made using crossed
      ROOF surfaces. The three ROOFs are mutually bounded to form the pyramids.
      Please note the possibility for ray leakage (see Help, ROOF command)
      (approx 3% measured) when directing rays on axis with the pyramids.
      This should not be a concern when intersecting with randomized ray directions.
    </description>
    <keyword>Arrays</keyword>
    <keyword>ROOF</keyword>
    <keyword>ARRAY</keyword>
    <keyword>OBLIQUE</keyword>
    <keyword>RENDER</keyword>
    <keyword>LIGHTS</keyword>
    <keyword>pyramid</keyword>
    <keyword>hex</keyword>
    <application/>
  </script>

  <script ID="256" category="Simple Problem" name="Hex_Tube.inr" title="Hexagonal Tube with Surfaces">
    <description>
      A method to make a hexagonal tube
      using a $DO loop.  A simple formula is used to
      calculate the side dimensions so that bounding
      is unnecessary. A GROUP command may be used to
      apply further transformations from the origin.
    </description>
    <keyword>Geometry</keyword>
    <keyword>hex</keyword>
    <keyword>tube</keyword>
    <keyword>SURFACE</keyword>
    <keyword>$DO</keyword>
    <keyword>ROTATE</keyword>
    <keyword>REPEAT</keyword>
    <application/>
  </script>

  <script ID="257" category="Isolated Command" name="HISTORY_Flux_Per_Angle.inr" title="Graphing Flux per Angle of any Object">
    <description>
      An example showing how to use HISTORY PX
      to select out paths of rays hitting a surface for each
      degree over a specified angular range.  A $ITER loop
      is used to create the display file of flux per angle
      using PX commands.  A graph is easily plotted from the
      stored iter data. A parabola was examined here, but any
      surface could have been used.
    </description>
    <keyword>HISTORY PX</keyword>
    <keyword>$ITER</keyword>
    <keyword>SAVE</keyword>
    <keyword>Tracing</keyword>
    <application/>
  </script>

  <script ID="258" category="Simple Problem" name="History_Plot.inr" title="Plotting Ray Histories">
    <description>
      Using HISTORY PLOT to plot the reverse
      trajectory of a selected ray path.
      The SAVE command  must be invoked before the trace in order to have
      saved ray intersection data.
    </description>
    <keyword>Tracing</keyword>
    <keyword>HISTORY</keyword>
    <keyword>PLOT</keyword>
    <keyword>PATHS</keyword>
    <keyword>SAVE</keyword>
    <application/>
  </script>

  <script ID="259" category="Simple Problem" name="hoe1.inr" title="HOE Imported from Zemax">
    <description>
      An HOE (Holographic Optical Element) imported
      from Zemax. The holographic surface used for the diffractive
      element is made with a multiple USERFUNC surface which calls
      a holographic function.
    </description>
    <keyword>DOE</keyword>
    <keyword>grating</keyword>
    <keyword>hoe</keyword>
    <keyword>holographic</keyword>
    <keyword>optical</keyword>
    <keyword>$FCN</keyword>
    <keyword>USERFUNC</keyword>
    <application/>
  </script>

  <script ID="260" category="Simple Problem" name="hoe2.inr" title="HOE by Two Point Sources">
    <description>
      Define a function that is equal to the total
      optical path length along straight lines that connect the
      two points with a given point on the plane. The plane is
      assumed to be perpendicular to the z axis. A given point
      on the plane is given by the registers _1, _2, and _3
      (_3 is always zero). The xyz coordinates of the first point
      are _4, _5, and _6, and the coordinates of the second point
      are _7, _8, and _9. After the function is defined, the three
      components of the gradient for the function are defined
      (the z component of the gradient is zero).
    </description>
    <keyword>DOE</keyword>
    <keyword>Gratings</keyword>
    <keyword>hoe</keyword>
    <keyword>DIFFRACT</keyword>
    <keyword>Hologram</keyword>
    <keyword>USERFUNC</keyword>
    <keyword>MULTIPLE</keyword>
    <keyword>$FCN</keyword>
    <application/>
  </script>

  <script ID="261" category="Simple Problem" name="HORN_Array_01.inr" title="Array of HORNs Bounded by Planes">
    <description>An Array of HORN Surfaces bounded by two planes.</description>
    <keyword>Arrays</keyword>
    <keyword>HORN</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>ARRAY</keyword>
    <application/>
  </script>

  <script ID="262" category="Isolated Command" name="IES_Data.inr" title="Writing an IES file">
    <description>
      Creates a source and writes its properties to
      a standard IESNA photometric file (name.IES) of an angular
      distribution created by either a RADIANT command (A or C photometry
      where the polar axis becomes vertical) or a SPOTS DIR and ANGLES
      combination (B photometry). ASAP uses IES Standard LM-63-1995.
    </description>
    <keyword>IESFILE</keyword>
    <application/>
  </script>

  <script ID="263" category="Isolated Command" name="Immerse_Rays01.inr" title="Sources born in Different Media">
    <description>
      Starting a source in a media other than
      vacuum/air, using the IMMERSE command.
    </description>
    <keyword>IMMERSE</keyword>
    <keyword>Sources</keyword>
    <keyword>MEDIA</keyword>
    <application/>
  </script>

  <script ID="264" category="Isolated Command" name="Immerse_Rays02.inr" title="Complete Example using IMMERSE">
    <description>
      Using IMMERSE to start rays inside another
      medium other than vacuum/air. In this case, the rays
      must be born in plastic, since the source is inside the
      LED. Even though the interfaces are 100% transmissive,
      the rays must exit into AIR before they hit the LENS_A
      interface. Otherwise, wrong-side errors will stop the
      rays from going further.
    </description>
    <keyword>IMMERSE</keyword>
    <keyword>Sources</keyword>
    <keyword>led</keyword>
    <keyword>Geometry</keyword>
    <application/>
  </script>

  <script ID="265" category="Simple Problem" name="Integrating_Sphere01.inr" title="Importance Area Sampling">
    <description>
      A model of an integrating sphere
      to show multiple random scatter. LEVEL and HALT
      are adjusted to allow many generations of scatter
      for a more accurate power calculation.
    </description>
    <keyword>Scatter</keyword>
    <keyword>SCATTER</keyword>
    <keyword>RANDOM</keyword>
    <keyword>TOWARDS</keyword>
    <keyword>LEVEL</keyword>
    <keyword>HALT</keyword>
    <keyword>integrating</keyword>
    <keyword>sphere</keyword>
    <application/>
  </script>

  <script ID="266" category="Simple Problem" name="Integrating_Sphere02.inr" title="Integrating Sphere">
    <description>
      A more detailed integrating sphere using
      a Lambertian surface scattering TOWARDS an edge. The
      RANDOM modifier is needed on the SCATTER MODEL command
      to make sure a seed ray gets generated to make all rays
      scatter toward the importance edge. With a LEVEL high
      enough and sufficient number of starting rays, the correct
      flux should be calculated for the exit hole.
    </description>
    <keyword>Scatter</keyword>
    <keyword>SCATTER</keyword>
    <keyword>TOWARDS</keyword>
    <keyword>sphere</keyword>
    <keyword>integrating</keyword>
    <application/>
  </script>

  <script ID="267" category="Isolated Command" name="interface01.inr" title="Reflective Interface">
    <description>
      Various ways of defining
      reflective interfaces. The minus (-) sign
      prevents the transmitted ray from being
      traced.
    </description>
    <keyword>INTERFACE</keyword>
    <keyword>Interfaces</keyword>
    <application/>
  </script>

  <script ID="268" category="Isolated Command" name="interface02.inr" title="Refractive Interface">
    <description>
      Several ways of defining
      refractive interfaces. The PLUS (+) sign
      prevents reflected rays from being traced.
    </description>
    <keyword>INTERFACE</keyword>
    <keyword>Interfaces</keyword>
    <application/>
  </script>

  <script ID="269" category="Simple Problem" name="INTERFACE_REPEAT.inr" title="Redefining OBJECT Properties">
    <description>
      How to change the interface properties of
      the second object with a previously-defined object.
      In this case, the interface properties are changed
      to match the first object.
    </description>
    <keyword>Geometry</keyword>
    <keyword>OBJECT</keyword>
    <keyword>INTERFACE REPEAT</keyword>
    <keyword>PRINT OBJECTS</keyword>
    <application/>
  </script>

  <script ID="270" category="Simple Problem" name="interfering_plane_waves.inr" title="Interfering Plane Waves">
    <description>
      Two plane waves intersecting
      to show interfence. One is tipped relative
      the other.
    </description>
    <keyword>Wave</keyword>
    <keyword>interference</keyword>
    <keyword>SPREAD</keyword>
    <keyword>PARABASAL</keyword>
    <application/>
  </script>

  <script ID="271" category="Isolated Command" name="INVERT01.inr" title="Use of the INVERT command">
    <description>
      Create (2) identical edge points.
      Use ROTATE to see the effect.
      For second edge use INVERT before ROTATE.
      Note, there is no effect on the rotation of the edges,
      but the points are reordered as seen by PLOT EDGES
    </description>
    <keyword>INVERT</keyword>
    <keyword>EDGE</keyword>
    <keyword>POINTS</keyword>
    <application/>
  </script>

  <script ID="272" category="Simple Problem" name="irradiance_vs_wavelength.inr" title="Plotting Irradiance vs. Wavelength">
    <description>
      How to plot irradiance vs. wavelength
      for a polychromatic source.  Uses $ITER to run
      raytraces at wavelength intervals over a thermal
      spectrum, saving the irradiance results to the
      iter.dis display file.
    </description>
    <keyword>Analysis</keyword>
    <keyword>SPECTRUM</keyword>
    <keyword>THERMAL</keyword>
    <keyword>WAVELENGTH</keyword>
    <keyword>irradiance</keyword>
    <keyword>$ITER</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="273" category="Isolated Command" name="isometric.inr" title="ISOMETRIC Display Command">
    <description>
      Create a 3-Dimensional plot of
      a SPOTS POSITION distribution file. Performed
      after a DISPLAY command. Does not modify
      display data. A Gaussian apodized grid is
      plotted.
    </description>
    <keyword>ISOMETRIC</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>USERAPOD</keyword>
    <application/>
  </script>

  <script ID="274" category="Simple Problem" name="Iter_Find_Lens_RC.inr" title="Modifying Lens RC with $ITER">
    <description>
      The following uses the second form of $ITER to find
      the best Radius of Curvature of a lens to focus the rays at a
      specified target position. The lens is actually rebuilt with
      a new R of C value at each iteration (the object's associated
      LENS entity is redefined) and the XY deviations of the the rays
      at the target are tested for minimum. When a best minimum is
      found, the new R of C is printed along with the Centroid Z
      position, which should equal the Target Z position. It starts
      with a desired focus position of 60. This is where the target
      is placed. Change this number to view different results.
    </description>
    <keyword>Scripts</keyword>
    <keyword>$ITER</keyword>
    <keyword>LENSES</keyword>
    <keyword>minimum</keyword>
    <keyword>merit</keyword>
    <keyword>iterate</keyword>
    <keyword>redefining</keyword>
    <application/>
  </script>

  <script ID="275" category="Simple Problem" name="Iter_Focus_Find.inr" title="Finding Best Focus with $ITER">
    <description>
      This demonstrates the second form of $ITER by finding
      the best focus of a singlet lens. A trace is performed at each
      iteration and the target repositioned until a minimum ray deviation
      is found. The technique of redefining a Surface and Object is used.
      This new position is printed and compared with the ASAP command,
      FOCUS MOVE, which is actually the easier way to perform this
      function.  The Radius of Curvature for the lens may be changed to view
      a different set of results.
    </description>
    <keyword>Scripts</keyword>
    <keyword>$ITER</keyword>
    <keyword>LENSES</keyword>
    <keyword>minimum</keyword>
    <keyword>merit</keyword>
    <keyword>iterate</keyword>
    <keyword>FOCUS</keyword>
    <keyword>MOVE</keyword>
    <keyword>redefining</keyword>
    <application/>
  </script>

  <script ID="276" category="Simple Problem" name="ITER_GENERAL_First_Form.inr" title="Modifying a GENERAL Polynomial Surface with ALTER">
    <description>
      The following uses the first form of $ITER to plot changes
      to the Radius of Curvature of an optical surface made with GENERAL.
      The GENERAL polynomial is changed with ALTER at each iteration step.
    </description>
    <keyword>Geometry</keyword>
    <keyword>$ITER</keyword>
    <keyword>GENERAL</keyword>
    <keyword>iterate</keyword>
    <keyword>redefining</keyword>
    <keyword>ALTER</keyword>
    <application/>
  </script>

  <script ID="277" category="Simple Problem" name="Iter_Multiple_Var_Graphing01.inr" title="Plotting Multiple Iter Results in one Graph">
    <description>
      A way to run multiple iterations on several
      variables, storing the data in one display file so they can
      be graphed separately or as a series.
    </description>
    <keyword>Analysis</keyword>
    <keyword>$ITER</keyword>
    <keyword>plot</keyword>
    <keyword>GRAPH</keyword>
    <keyword>$SCR</keyword>
    <application/>
  </script>

  <script ID="278" category="Simple Problem" name="ITER_OPTICAL_First_Form.inr" title="Modifying OPTICAL RC with $ITER">
    <description>
      The following uses the first form of $ITER to graph the results
      of a range of Radius of Curvatures for an OPTICAL. The $ITER records the entire
      the entire range in ITER.DIS and leaves off where the minimum RofC was found.
      The OPTICAL is rebuilt with a new RofC at each iteration (the object's associated
      OPTICAL entity is redefined) and the XZ deviations of the the rays
      at the target are saved at each step. This is not as accurate as using
      the second form - see "ITER_OPTICAL_Second_Form.INR" where a more precise
      minimum may be found.  This first form will simply step through the range
      as given, leaving it in the best step where the minimum was found. It starts
      with a desired focus position of 15. This is where the target
      is placed. Change this number to view different results. The $ITER
      R of C range should be made to cover the new Target position.
      Another method for changing polynomial coefficients using ALTER
      in a $ITER, may be found in ITER_GENERAL_First_Form.inr
    </description>
    <keyword>Scripts</keyword>
    <keyword>$ITER</keyword>
    <keyword>OPTICAL</keyword>
    <keyword>minimum</keyword>
    <keyword>merit</keyword>
    <keyword>iterate</keyword>
    <keyword>redefining</keyword>
    <application/>
  </script>

  <script ID="279" category="Simple Problem" name="ITER_OPTICAL_Second_Form.inr" title="Modifying OPTICAL RC with $ITER">
    <description>
      The following uses the second form of $ITER to find
      the best Radius of Curvature of an OPTICAL surface to focus rays at a
      specified target position. The OPTICAL is actually rebuilt with
      a new R of C value at each iteration (the object's associated
      OPTICAL entity is redefined) and the XZ deviations of the the rays
      at the target are tested for minimum. When a best minimum is
      found, the new R of C is printed along with the Centroid Y
      position, which should equal the Target Y position. It starts
      with a desired focus position of 18. This is where the target
      is placed. Change this number to view different results. The $ITER
      R of C range should be made to cover the new Target position.
    </description>
    <keyword>Scripts</keyword>
    <keyword>$ITER</keyword>
    <keyword>LENSES</keyword>
    <keyword>minimum</keyword>
    <keyword>merit</keyword>
    <keyword>iterate</keyword>
    <keyword>redefining</keyword>
    <application/>
  </script>

  <script ID="280" category="Simple Problem" name="Iter_Over_Range.inr" title="Media Index based on Temperature &amp; Pressure">
    <description>
      The following uses the first form of $ITER to create
      a two-dimensional display file that relates temperature and pressure
      to reflectivity of a surface with a complicated index of refraction.
    </description>
    <keyword>Scripts</keyword>
    <keyword>$ITER</keyword>
    <keyword>iterate</keyword>
    <keyword>range</keyword>
    <keyword>index</keyword>
    <keyword>pressure</keyword>
    <keyword>temperature</keyword>
    <application/>
  </script>

  <script ID="281" category="Simple Problem" name="Iter_Root_Find01.inr" title="Finding Root of Equation with $ITER">
    <description>Uses root finding method of $ITER.</description>
    <keyword>Scripts</keyword>
    <keyword>$ITER</keyword>
    <keyword>root</keyword>
    <keyword>iterate</keyword>
    <keyword>$SCR</keyword>
    <application/>
  </script>

  <script ID="282" category="Simple Problem" name="Iter_Root_Find02.inr" title="Both Forms of $ITER">
    <description>
      The following is used to locate a coordinate position
      along an axis that corresponds to a particular flux value.
      The $ITER will look for a minimum "MERIT" value starting at some
      initial "YSEARCH" value (in this case 10).
    </description>
    <keyword>Scripts</keyword>
    <keyword>$ITER</keyword>
    <keyword>iterate</keyword>
    <keyword>merit</keyword>
    <keyword>$SCR</keyword>
    <keyword>WRITE</keyword>
    <keyword>macro</keyword>
    <application/>
  </script>

  <script ID="283" category="Isolated Command" name="ITER_Singlet01.inr" title="$ITER for bending, first form">
    <description>
      Optimize singlet bending with the first
      form of $ITER.  This is the simpler form of $ITER.  It
      only does a grid search to find the minimum value of the
      specified function within a user-specified range.
      The function minimized here is the RMS blur diameter as
      a function of bending.
      See also "ITER_SINGLET02.INR" for comparison with the
      second form of $ITER, and "OPTIMIZE_SINGLET.INR"
      for a comparison using MINIMIZE for conic sequences.
    </description>
    <keyword>$ITER</keyword>
    <keyword>iterate</keyword>
    <keyword>SINGLET</keyword>
    <keyword>bending</keyword>
    <keyword>$UNVAR</keyword>
    <application/>
  </script>

  <script ID="284" category="Isolated Command" name="ITER_Singlet02.INR" title="$ITER for bending, second form">
    <description>
      Optimize singlet bending with the second  form of $ITER.
      This form uses singular value
      decomposition (SVD) to seek the minimum of a function.
      The function minimized here is the RMS blur diameter, as
      reported by the FOCUS command, as a function of bending.
      See also "ITER_SINGLET01.INR" for comparison with $ITER
      as a grid search (form 1), and "OPTIMIZE_SINGLET.INR"  f
      or a comparison using MINIMIZE for conic sequences.
    </description>
    <keyword>$ITER</keyword>
    <keyword>iterate</keyword>
    <keyword>SINGLET</keyword>
    <keyword>bending</keyword>
    <application/>
  </script>

  <script ID="285" category="Simple Problem" name="Iter_TIR_Graph.inr" title="Graphing Reflected Flux Approaching TIR">
    <description>
      Uses first form of $ITER to graph
      a ray traced within glass at an angle range from  0 to 50°.
      The reflected flux is saved to the ITER
      display file and graphed at the end.
    </description>
    <keyword>Tracing</keyword>
    <keyword>$ITER</keyword>
    <keyword>tir</keyword>
    <keyword>IMMERSE</keyword>
    <application/>
  </script>

  <script ID="286" category="Isolated Command" name="lambertian01.inr" title="Lambertian Scatter Towards an Edge">
    <description>
      Demonstration of scatter towards an
      edge. An emitting grid is used to show Lambertian
      scatter through a lens toward a rectangular edge.
    </description>
    <keyword>LAMBERTIAN</keyword>
    <keyword>MODELS</keyword>
    <keyword>SCATTER</keyword>
    <keyword>TOWARDS</keyword>
    <application/>
  </script>

  <script ID="287" category="Simple Problem" name="Laser_Coupling.inr" title="Laser Coupling">
    <description>
      This file demonstrates the use of
      ASAP for calculating the coupling efficiency
      of a laser diode to a single-mode fiber. The
      beams must be decomposed in direction first
      to determine the total energy losses for the
      coupling efficiency calculation later.
    </description>
    <keyword>Wave</keyword>
    <keyword>laser</keyword>
    <keyword>coupling</keyword>
    <keyword>FIELD</keyword>
    <keyword>COUPLE</keyword>
    <keyword>DECOMPOSE</keyword>
    <application/>
  </script>

  <script ID="288" category="Simple Problem" name="Laser_Diode.inr" title="Diode Laser using DECOMPOSE DIRECTION">
    <description>
      A model for a diode laser where
      DECOMPOSE DIRECTION is needed for a single  narrow beam.
      A DECOMPOSE POSITION would not work for this case.
    </description>
    <keyword>Wave</keyword>
    <keyword>laser</keyword>
    <keyword>diode</keyword>
    <keyword>DECOMPOSE</keyword>
    <keyword>FIELD</keyword>
    <keyword>MODULUS</keyword>
    <application/>
  </script>

  <script ID="289" category="Simple Problem" name="LCD_Diffuser_Dots.inr" title="LCD Edge-lit Diffuser">
    <description>
      The following example is an LCD backlight diffuser
      panel using arrays of dots, having a white paint scattering property.
      The dots are just above the bottom surface inside the diffuser  panel.
      The majority of flux should be reflected or scattered out
      of the top of the panel.
      This is an early example to show how to use the ARRAY command to
      generate separate squares of dots.  Variable dot spacing may also be
      accomplished through the EXP option, as well as RANdom dot sizes.
      See Help for details.
      There may be a mathematical formula to create a large number
      of squares with varying dot size within a $DO loop if required.
      In this example, specific squares were generated with a fixed dot
      size.  The light source was put along the top edge of the panel and the
      window for analysis was looking straight down on top of the panel.
      This could be modified for any configuration.
    </description>
    <keyword>Geometry</keyword>
    <keyword>ARRAY</keyword>
    <keyword>diffuser</keyword>
    <keyword>lcd</keyword>
    <keyword>backlight</keyword>
    <keyword>dots</keyword>
    <keyword>bumps</keyword>
    <application/>
  </script>

  <script ID="290" category="Isolated Command" name="lenses01.inr" title="Multiple Lens Methods">
    <description>
      Three different ways to enter
      the same afocal telescope with an afocal
      magnification of 5 1/3.
    </description>
    <keyword>LENSES</keyword>
    <keyword>AFOCAL</keyword>
    <keyword>SINGLET</keyword>
    <keyword>SEQUENCE</keyword>
    <application/>
  </script>

  <script ID="291" category="Isolated Command" name="LENSES_PERFECT01.inr" title="PERFECT Lens with Image at Infinity">
    <description>
      A PERFECT lens with object at 0, and
      image at infinity. This maintains an infinite
      conjugate which is essential when using PERFECT.
      Coherent beams are used to show that the wavefront
      curvature is maintained, rather than if using IDEAL.
    </description>
    <keyword>PERFECT</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="292" category="Isolated Command" name="LENSES_PERFECT02.inr" title="PERFECT Lens with Object at Infinity">
    <description>
      A PERFECT lens with object at infinity.
      A PERFECT lens must have an infinite conjugate.
      This case demonstrates light focused from an infinite
      object.  When using coherent beams, better results are
      achieved with PERFECT than with IDEAL, since the
      spherical wavefront is maintained.
    </description>
    <keyword>PERFECT</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="293" category="Isolated Command" name="LENSES_PERFECT03.inr" title="PERFECT Lens with Bi-directional Light Path">
    <description>
      A PERFECT lens with a reflector
      at the focal plane. Shows the use of a bi-directional
      light path. A PERFECT lens must be used with infinite
      conjugates. Either the image is at infinity or
      the object is at infinity.  Here, both paths are
      demostrated by the use of a mirror at one focal
      distance away from the lens.
    </description>
    <keyword>PERFECT</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="294" category="Simple Problem" name="Lens_Afocal.inr" title="An Afocal Lens">
    <description>
      Making an afocal lens for use in
      7x35 binoculars. From the Lenses chapter.
    </description>
    <keyword>Lenses</keyword>
    <keyword>LENSES</keyword>
    <keyword>AFOCAL</keyword>
    <keyword>binoculars</keyword>
    <application/>
  </script>

  <script ID="295" category="Simple Problem" name="lens_array01.inr" title="A Discrete Lens Array">
    <description>
      A micro-lens array with discrete lens
      objects using nested macro/do loops. This is better
      performed with bounding and using the ARRAY command.
    </description>
    <keyword>Macros_user</keyword>
    <keyword>Arrays</keyword>
    <keyword>lenslet</keyword>
    <keyword>macro</keyword>
    <application/>
  </script>

  <script ID="296" category="Simple Problem" name="Lens_Aspheric01.inr" title="Aspheric Lens by Sag Coefficients">
    <description>
      An Aspheric lens from Melles-Griot created
      by USERSAG, with raytrace. This method may be used
      for lenses defined by sag coefficients rather than
      aspheric coefficients.
    </description>
    <keyword>Lenses</keyword>
    <keyword>aspheric</keyword>
    <keyword>USERSAG</keyword>
    <keyword>$FCN</keyword>
    <keyword>Melles-Griot</keyword>
    <keyword>sag</keyword>
    <application/>
  </script>

  <script ID="297" category="Simple Problem" name="Lens_Box.inr" title="Lens Box to View Radiant Source">
    <description>
      Lens box for viewing a Radiant
      Imaging source. Needs to be larger than
      the source dimensions. Included here for  convenience.
    </description>
    <keyword>Sources</keyword>
    <keyword>LENSES</keyword>
    <keyword>box</keyword>
    <keyword>Radiant</keyword>
    <application/>
  </script>

  <script ID="298" category="Simple Problem" name="Lens_DOME01.inr" title="Dome Lens">
    <description>
      How to model a DOME lens, showing
      raytrace and analysis.
    </description>
    <keyword>Lenses</keyword>
    <keyword>LENSES</keyword>
    <keyword>DOME</keyword>
    <application/>
  </script>

  <script ID="299" category="Simple Problem" name="Lens_Doublet.inr" title="A Doublet Lens">
    <description>
      How to make a doublet lens.
      From the Lenses chapter.
    </description>
    <keyword>Lenses</keyword>
    <keyword>DOUBLET</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="300" category="Simple Problem" name="Lens_Explode_Minus.inr" title="Cooke Triplet with SEQUENCE and EXPLODE-">
    <description>
      Making a 50 MM Cooke Triplet using the
      short form of the SEQUENCE command, combined with
      EXPLODE -. EXPLODE breaks up the sequence into separate
      surface objects.  From the Lenses chapter.
    </description>
    <keyword>Lenses</keyword>
    <keyword>LENSES</keyword>
    <keyword>SEQUENCE</keyword>
    <keyword>Cooke</keyword>
    <keyword>triplet</keyword>
    <keyword>EXPLODE</keyword>
    <application/>
  </script>

  <script ID="301" category="Simple Problem" name="Lens_Explode_Plus.inr" title="Cooke Triplet with SEQUENCE and EXPLODE+">
    <description>
      Making a 50 MM Cooke Triplet using the
      short form of the SEQUENCE command, combined with  EXPLODE +.
      EXPLODE breaks up the sequence into separate  surface objects.
      From the Lenses chapter.
    </description>
    <keyword>Lenses</keyword>
    <keyword>LENSES</keyword>
    <keyword>SEQUENCE</keyword>
    <keyword>Cooke</keyword>
    <keyword>triplet</keyword>
    <keyword>EXPLODE</keyword>
    <application/>
  </script>

  <script ID="302" category="Isolated Command" name="lens_ideal01.inr" title="Simple Ideal Lens">
    <description>
      Defines an ideal lens with
      a focal length of 5 and whose vertex is
      located at z = 4. The lens is 2 in diameter.
    </description>
    <keyword>IDEAL</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="303" category="Isolated Command" name="lens_ideal02.inr" title="Ideal Telescope Lens">
    <description>
      Defines an ideal afocal
      telescope whose first surface is located
      at y = -4. The diameters of the two
      elements are 1 and .6 and they are separated
      by 2. The afocal magnification of the system is 2.
    </description>
    <keyword>IDEAL</keyword>
    <keyword>LENSES</keyword>
    <keyword>telescope</keyword>
    <application/>
  </script>

  <script ID="304" category="Isolated Command" name="lens_ideal03.inr" title="Ideal Lens with Raytrace">
    <description>
      An ideal lens with a single
      ray traced through.
    </description>
    <keyword>IDEAL</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="305" category="Simple Problem" name="lens_ideal04.inr" title="Binoculars using Ideal Lenses">
    <description>Make a 7X35 binoculars using ideal lenses.</description>
    <keyword>Lenses</keyword>
    <keyword>LENSES</keyword>
    <keyword>IDEAL</keyword>
    <keyword>binoculars</keyword>
    <application/>
  </script>

  <script ID="306" category="Simple Problem" name="Lens_Image01.inr" title="Landscape Lens using IMAGE">
    <description>
      Using the IMAGE command to image rays
      through a lens and a pupil. It is used as a source
      modifier.
    </description>
    <keyword>Geometry</keyword>
    <keyword>IMAGE</keyword>
    <keyword>LENSES</keyword>
    <keyword>SINGLET</keyword>
    <keyword>pupil</keyword>
    <application/>
  </script>

  <script ID="307" category="Simple Problem" name="Lens_Image02.inr" title="A Lens Grid">
    <description>
      An efficient meridional raytrace through
      a finite conjugate system.  The stop of the lens is
      located close to the middle of the lens. From the
      Lenses chapter.
    </description>
    <keyword>Lenses</keyword>
    <keyword>grid</keyword>
    <keyword>LENSES</keyword>
    <keyword>SEQUENCE</keyword>
    <keyword>RADI</keyword>
    <keyword>IMAGE</keyword>
    <keyword>conjugate</keyword>
    <keyword>EXPLODE</keyword>
    <application/>
  </script>

  <script ID="308" category="Simple Problem" name="Lens_Image03.inr" title="IMAGE as a Lens &amp; Edge Modifier">
    <description>
      Using IMAGE as a LENS and an
      EDGE modifier.
    </description>
    <keyword>Geometry</keyword>
    <keyword>IMAGE</keyword>
    <keyword>LENSES</keyword>
    <keyword>EDGES</keyword>
    <application/>
  </script>

  <script ID="309" category="Simple Problem" name="Lens_Image04.inr" title="IMAGE Command used as Source modifier">
    <description>
      Uses IMAGE as a source modifier. The
      modified source, placed at the image position, is
      compared to the original in the final plot.
    </description>
    <keyword>Sources</keyword>
    <keyword>IMAGE</keyword>
    <keyword>LENSES</keyword>
    <keyword>EMITTING HELIX</keyword>
    <application/>
  </script>

  <script ID="310" category="Isolated Command" name="lens_interface.inr" title="Lens Interfaces">
    <description>
      A singlet lens and a prism
      lens made from different materials. See
      explanations below.
    </description>
    <keyword>LENSES</keyword>
    <keyword>interfaces</keyword>
    <keyword>properties</keyword>
    <application/>
  </script>

  <script ID="311" category="Isolated Command" name="lens_mangin01.inr" title="Mangin Mirror by Curvature">
    <description>
      A mangin mirror, using CV
      entries for curvature, with ray trace.
    </description>
    <keyword>MANGIN</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="312" category="Isolated Command" name="lens_mangin02.inr" title="Mangin Mirror by Focal Length">
    <description>
      A mangin mirror, using FL
      entries for focal length and bending,
      with ray trace.
    </description>
    <keyword>MANGIN</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="313" category="Isolated Command" name="lens_mangin03.inr" title="Mangin Mirror by Radii">
    <description>
      A mangin mirror, using
      RD entries for radii of curvature, with  ray trace.
    </description>
    <keyword>MANGIN</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="314" category="Isolated Command" name="lens_mangin04.inr" title="Mangin Mirror FL in Detail">
    <description>
      Defines a Mangin mirror whose
      first conicoid vertex is located at y=32.
      The central thickness is .75 and the aperture
      semi-diameter is 1.5. The focal length is 3
      and the bending parameter is -1, and so the
      first surface is flat. Medium 1 is bounded by
      the two conicoids.
    </description>
    <keyword>MANGIN</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="315" category="Isolated Command" name="lens_mangin05.inr" title="Mangin Mirror RD">
    <description>
      A Mangin mirror lens using RD
      with an absorptive interface.
    </description>
    <keyword>MANGIN</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="316" category="Isolated Command" name="lens_mangin06.inr" title="Mangin Mirror with Trace">
    <description>
      A MANGIN mirror lens with an
      emitting rectangle to show simple use and
      properties.
    </description>
    <keyword>MANGIN</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="317" category="Simple Problem" name="Lens_Mirror.inr" title="A Lens Mirror">
    <description>
      An example of the LENS MIRROR command.
      A simple parabolic concave mirror pointed towards -Z.
      Under the universal design law that light travels only
      from left to right, the focal length of a concave
      mirror is positive while the focal length of a convex
      mirror is negative. From the Lenses chapter.
    </description>
    <keyword>Lenses</keyword>
    <keyword>LENSES</keyword>
    <keyword>MIRROR</keyword>
    <keyword>parabolic</keyword>
    <application/>
  </script>

  <script ID="318" category="Isolated Command" name="lens_mirror01.inr" title="Parabolic Mirror Lens">
    <description>
      A simple parabolic mirror using
      the LENSES command.
    </description>
    <keyword>MIRROR</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="319" category="Isolated Command" name="lens_mirror02.inr" title="Parabolic Mirror with Hole">
    <description>
      Defines a parabolic mirror located at
      z=-15 with a semi-diameter of 5. The focal length
      of the mirror is 20. The central 25 percent of the
      mirror aperture is cut out.
    </description>
    <keyword>MIRROR</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="320" category="Isolated Command" name="lens_mirror03.inr" title="Cassegrain Telescope #2">
    <description>
      Simple Cassegrain telescope
      using the LENSES command to make the
      mirrors and detector.
    </description>
    <keyword>Geometry</keyword>
    <keyword>LENSES</keyword>
    <keyword>MIRROR</keyword>
    <keyword>Cassegrain</keyword>
    <keyword>telescope</keyword>
    <application/>
  </script>

  <script ID="321" category="Isolated Command" name="lens_penta01.inr" title="Penta-Prism Lens">
    <description>
      PENTA makes a 90° deviation
      penta-prism with 4 circular surfaces.
      PLOT FACETS are needed to see the surfaces.
    </description>
    <keyword>PENTA</keyword>
    <keyword>LENSES</keyword>
    <keyword>prism</keyword>
    <application/>
  </script>

  <script ID="322" category="Simple Problem" name="Lens_Penta_Prism.inr" title="Penta Prism Lens">
    <description>
      An example of a penta prism lens using
      the PENTA command modifier. From the Lenses chapter.
    </description>
    <keyword>Lenses</keyword>
    <keyword>LENSES</keyword>
    <keyword>PENTA</keyword>
    <keyword>prism</keyword>
    <application/>
  </script>

  <script ID="323" category="Simple Problem" name="Lens_Progressive_01.inr" title="Four Zone Progressive Optometric Lens">
    <description>
      A  four-zone  optometric lens made by exploded
      convex-plano or concave-plano singlets using the FL (Focal Length)
      option and bounding.
      Power of zones 1 - 4 add to Zone 0 power controlled by curvature and index.
      Connected points compose the zonal outlines.
      Cross-hatched profiles are overlain on faceting to show the points grid.
      This lens can be used with AHEM if lines are commented out as noted below.
    </description>
    <keyword>Lenses</keyword>
    <keyword>LENSES</keyword>
    <keyword>SINGLET</keyword>
    <keyword>EXPLODE</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>progressive</keyword>
    <keyword>optometric</keyword>
    <keyword>ophthalmic lens</keyword>
    <keyword>eye</keyword>
    <keyword>ahem</keyword>
    <application/>
  </script>

  <script ID="324" category="Isolated Command" name="lens_right01.inr" title="Right-Angle Prism Lens">
    <description>
      A right-angle prism made
      with LENSES command. The first conicoid is
      located at z = 0.  The prism has an aperture
      semi-diameter of .5 and is composed of medium 1.
      The prism is oriented so that a ray entering
      the prism along the z-axis leaves the prism
      propagating along the positive y-direction.
    </description>
    <keyword>RIGHT</keyword>
    <keyword>LENSES</keyword>
    <keyword>prism</keyword>
    <application/>
  </script>

  <script ID="325" category="Isolated Command" name="lens_sequence01.inr" title="Simple Lens Sequence">
    <description>
      Defines four spherical lenses
      whose vertices are located at (0,0,0),  (
      0,0,1.25), (0,0,1.75) and (0,0,3) and
      are aligned with the global z axis. All
      lenses are 3 in semi-diameter. The respective
      radii of curvature are 10, -10, 40 and -20.
      The first two conicoids and the last two
      conicoids bound medium 1; the second and
      third conicoids bound medium 2.
    </description>
    <keyword>SEQUENCE</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="326" category="Isolated Command" name="lens_sequence02.inr" title="Lens Sequence with Media">
    <description>
      A lens sequence using the
      media 'm' parameter.
    </description>
    <keyword>SEQUENCE</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="327" category="Isolated Command" name="lens_sequence03.inr" title="Lens Sequence Long Format">
    <description>
      The prescription of this lens
      is the same as in a Sequence Lens. Note
      the first line of numerical data is entered
      in the long format.
    </description>
    <keyword>SEQUENCE</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="328" category="Simple Problem" name="Lens_Sequence_Long.inr" title="Long Form of SEQUENCE">
    <description>
      A 50 MM Cooke triplet with a folding mirror
      that uses the long form of the SEQUENCE command.
      This command creates a sequence of conicoids. It can be used
      in its short or long form. The long form specifies the global
      coordinates and the normal vector of the vertex of each conicoid.
      In any case, the first conicoid of a SEQUENCE must be entered
      in the long format. From the Lenses chapter.
    </description>
    <keyword>Lenses</keyword>
    <keyword>LENSES</keyword>
    <keyword>SEQUENCE</keyword>
    <keyword>RADI</keyword>
    <keyword>Cooke</keyword>
    <keyword>triplet</keyword>
    <application/>
  </script>

  <script ID="329" category="Simple Problem" name="Lens_Sequence_Short01.inr" title="A Cooke Triplet using Short Form of SEQUENCE Command">
    <description>
      A 50 MM Cooke triplet using the long form
      of the SEQUENCE command. This command creates a sequence
      of conicoids. It can be used in its short or long form.
      The short form uses a more compact notation and assumes
      that all conicoids share a similar vertex normal vector.
      Distances between conicoids are used to relate each
      conicoid. However, the first conicoid of a SEQUENCE must
      be entered in the long format.
      This example is especially designed to please lens
      designers that are conditioned to recognize an input
      sequence that ends each line with a thickness input.
      From the Lenses chapter.
    </description>
    <keyword>Lenses</keyword>
    <keyword>LENSES</keyword>
    <keyword>SEQUENCE</keyword>
    <keyword>RADI</keyword>
    <keyword>Cooke</keyword>
    <keyword>triplet</keyword>
    <application/>
  </script>

  <script ID="330" category="Isolated Command" name="lens_singlet01.inr" title="Singlet Lens by Curvature">
    <description>
      A Singlet lens using the
      curvature 'CV' parameters c and c'.
    </description>
    <keyword>SINGLET</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="331" category="Isolated Command" name="lens_singlet02.inr" title="Singlet Lens by Focal Length">
    <description>
      A Singlet lens using the
      focal length 'FL' parameters f and b.
    </description>
    <keyword>SINGLET</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="332" category="Isolated Command" name="lens_singlet03.inr" title="Singlet Lens by RD">
    <description>
      A Singlet lens using radius
      of curvature 'RD' parameters r and r'.
      Defines a singlet whose front conicoid
      vertex is located at x = -4. The thickness
      is .75 and the aperture semi-diameter is 2.5.
      The power of the element is specified by the
      lens radii, which are 10 and -20 respectively.
      The lens is composed of medium 1.
    </description>
    <keyword>SINGLET</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="333" category="Simple Problem" name="Lens_Telescope_Chretien.inr" title="Ritchey-Chretien Cassegrain Telescope">
    <description>
      A telescope using two mirrors in a
      Ritchey-Chretien Cassegrain configuration. The TELESCOPE command
      is programmed to design telescopes that are always corrected
      for third order spherical aberration.
      The radii of curvature of the primary and secondary mirrors
      are respectively 400 and 140 mm. The primary mirror obscuration
      is created automatically. Aberration control is done via the
      addition of conics on the two mirrors that eliminates third
      order spherical aberration and coma. This results in a
      Ritchey-Chrétien telescope design that is limited by astigmatism.
      From the Lenses chapter.
    </description>
    <keyword>Lenses</keyword>
    <keyword>LENSES</keyword>
    <keyword>TELESCOPE</keyword>
    <keyword>Ritchey</keyword>
    <keyword>Chretien</keyword>
    <keyword>mirror</keyword>
    <application/>
  </script>

  <script ID="334" category="Simple Problem" name="Lens_Telescope_Maksutov.inr" title="Maksutov-Cassegrain Telescope">
    <description>
      A two mirror telescope design similar to
      a Maksutov-Cassegrain, using the LENS TELESCOPE command.
      The reference point of the system is the vertex of the
      primary mirror and it is oriented and located given the
      defined global coordinates axis and location.
      The second mirror of the Cassegrain configuration has a
      negative power and a positive magnification.
      This is an example of the design with two concentric
      mirrors with the stop. Such location of the mirrors
      eliminates third order coma, astigmatism and distortion
      without the addition of conics on the mirror. However,
      ASAP is programmed to always eliminate spherical aberration.
      That is why the two mirrors end up with conic constants
      that correct spherical aberration and coma.
      From the Lenses chapter.
    </description>
    <keyword>Lenses</keyword>
    <keyword>LENSES</keyword>
    <keyword>TELESCOPE</keyword>
    <keyword>Maksutov</keyword>
    <keyword>Cassegrain</keyword>
    <application/>
  </script>

  <script ID="335" category="Simple Problem" name="Lens_Telescope_Parabolic.inr" title="Parabolic Telescope">
    <description>
      A one mirror telescope using a simple
      parabolic mirror. The TELESCOPE command is programmed
      to design telescopes that are always corrected for
      third order spherical aberration. The one mirror
      telescope has a 40 mm radius of curvature (2xFL). The
      mirror conic constant is automatically set to -1 for
      a parabola that corrects spherical aberration.
      From the Lenses chapter.
    </description>
    <keyword>Lenses</keyword>
    <keyword>LENSES</keyword>
    <keyword>TELESCOPE</keyword>
    <keyword>parabolic</keyword>
    <keyword>mirror</keyword>
    <application/>
  </script>

  <script ID="336" category="Simple Problem" name="Lens_Telescope_Schmidt.inr" title="Schmidt Telescope with Corrector">
    <description>
      A one mirror telescope using a simple
      parabolic mirror. The TELESCOPE command is programmed
      to design telescopes that are always corrected for
      third order spherical aberration.
      The mirror has a 40 mm radius of curvature (2xFL). In
      this design, the mirror is concentric with the stop
      (the corrector plate). Such configuration eliminates third
      order coma, astigmatism and distortion introduced by the
      mirror. The asphericity of the corrector plate corrects
      spherical aberration and the mirror remains spherical with
      a zero conic constant.  From the Lenses chapter.
    </description>
    <keyword>Lenses</keyword>
    <keyword>LENSES</keyword>
    <keyword>TELESCOPE</keyword>
    <keyword>Schmidt</keyword>
    <keyword>mirror</keyword>
    <keyword>corrector</keyword>
    <application/>
  </script>

  <script ID="337" category="Simple Problem" name="Lens_Triplet_Composite.inr" title="Triplet Lens using REPEAT and COMPOSITE">
    <description>
      A lens triplet using the REPEAT and COMPOSITE commands.
      The COMPOSITE command combines several lens entities into a single
      lens entity. IDEAL lens entities are not allowed in a composite set.
      The REPEAT command repeats previously defined entity data that may
      subsequently be changed by linear transformations.
      From the Lenses chapter.
    </description>
    <keyword>Lenses</keyword>
    <keyword>LENSES</keyword>
    <keyword>SEQUENCE</keyword>
    <keyword>RADI</keyword>
    <keyword>REPEAT</keyword>
    <keyword>COMPOSITE</keyword>
    <keyword>triplet</keyword>
    <application/>
  </script>

  <script ID="338" category="Isolated Command" name="lens_wedge01.inr" title="Glass Wedge Lens">
    <description>
      A wedge of glass made
      with LENSES command.
    </description>
    <keyword>WEDGE</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="339" category="Isolated Command" name="library02.inr" title="Macro Input Records">
    <description>
      Shows the proper way to call
      macros with input records.
    </description>
    <keyword>LIBRARY</keyword>
    <keyword>macro</keyword>
    <application/>
  </script>

  <script ID="340" category="Isolated Command" name="limits01.inr" title="Object Bounding Box">
    <description>
      Defines an optical surface
      with a radius of curvature equal to -30  and a conic constant equal to -1. The
      object is bounded by a cylinder whose  semi-diameter is equal to 4 and whose
      z limits [in global coordinates] extend  from -1 to 1.
      The object has a hole with  a semi-diameter of .8 at its origin.
    </description>
    <keyword>LIMITS</keyword>
    <keyword>OBJECT</keyword>
    <application/>
  </script>

  <script ID="341" category="Isolated Command" name="line01.inr" title="A Line Edge">
    <description>A straight line edge.</description>
    <keyword>LINE</keyword>
    <keyword>EDGES</keyword>
    <application/>
  </script>

  <script ID="342" category="Simple Problem" name="Line_Source.inr" title="Grid Converging to a Line">
    <description>
      Demostrates the creation of a grid source which focuses
      to a line. The +\- x-coordinates are made large to force the ellipsoid
      focii to form a line.
    </description>
    <keyword>Sources</keyword>
    <keyword>SOURCE</keyword>
    <keyword>LINE</keyword>
    <keyword>REVERSE</keyword>
    <application/>
  </script>

  <script ID="343" category="Isolated Command" name="list01.inr" title="LIST Command Options">
    <description>Various options of the LIST command. See below for explanations.</description>
    <keyword>LIST</keyword>
    <keyword>Sources</keyword>
    <keyword>rays</keyword>
    <keyword>Tracing</keyword>
    <application/>
  </script>

  <script ID="344" category="Isolated Command" name="list02.inr" title="List Command Output">
    <description>
      Output examples of various LIST
      command options.
    </description>
    <keyword>LIST</keyword>
    <keyword>Tracing</keyword>
    <keyword>rays</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="345" category="Isolated Command" name="list03.inr" title="Output of LISTing Parabasals">
    <description>
      Using LIST for outputing
      parabasal ray data. Example shows PS, DS,
      P#, and D# options.
    </description>
    <keyword>LIST</keyword>
    <keyword>Wave</keyword>
    <keyword>rays</keyword>
    <keyword>Tracing</keyword>
    <application/>
  </script>

  <script ID="346" category="Isolated Command" name="list_ellipse.inr" title="LIST ELLIPSE Output">
    <description>
      The LIST ELLIPSE command output
      for "POLARIZ X 0 1" on a grid of rays in the
      Z direction.
    </description>
    <keyword>LIST ELLIPSE</keyword>
    <keyword>Polarization</keyword>
    <application/>
  </script>

  <script ID="347" category="Isolated Command" name="LIST_INTEGER.inr" title="LIST INTEGER output">
    <description>
      Demonstration of LIST INTEGER.
      Some simple geometry is created, a trace is performed
      and the result of the command LIST INTEGER is shown.
    </description>
    <keyword>LIST INTEGER</keyword>
    <keyword>GRID</keyword>
    <keyword>Tracing</keyword>
    <application/>
  </script>

  <script ID="348" category="Isolated Command" name="LIST_RAYS.inr" title="LIST RAYS output">
    <description>
      Demonstration of LIST RAYS.
      Some simple geometry is created, a trace is performed
      and the result of the command LIST RAYS is shown.
    </description>
    <keyword>LIST RAYS</keyword>
    <keyword>GRID</keyword>
    <keyword>Tracing</keyword>
    <application/>
  </script>

  <script ID="349" category="Simple Problem" name="Literal_Passing01.inr" title="Passing Literals to a Macro">
    <description>
      The do's and don't's of passing numerical values
      as a literal to a macro,
    </description>
    <keyword>Scripts</keyword>
    <keyword>literal</keyword>
    <keyword>macro</keyword>
    <keyword>string</keyword>
    <keyword>register</keyword>
    <keyword>expression</keyword>
    <application/>
  </script>

  <script ID="350" category="Simple Problem" name="Literal_Passing02.inr" title="Passing Variables to Plot Titles">
    <description>
      Passing variables to plot titles using the LIT
      operator and a macro.
    </description>
    <keyword>Scripts</keyword>
    <keyword>literal</keyword>
    <keyword>string</keyword>
    <keyword>variable</keyword>
    <keyword>macro</keyword>
    <keyword>plot</keyword>
    <keyword>title</keyword>
    <application/>
  </script>

  <script ID="351" category="Isolated Command" name="lsqfit01.inr" title="Least Squares Fit Control">
    <description>
      Using LSQFIT to modify the singular value
      decomposition method used by the REVOLUTION command's
      least squares fitting algorythm.  Note the use of $FCN to create
      the data for REVOLUTION.  If the fits are not
      good then consider breaking the OBJECT into
      many piecewise OBJECTS for fits over smaller
      divisions.
    </description>
    <keyword>LSQFIT</keyword>
    <keyword>REVOLUTION</keyword>
    <keyword>$DO</keyword>
    <keyword>$FCN</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="352" category="Isolated Command" name="lsqfit02.inr" title="LSQFIT Output">
    <description>Example output from LSQFIT command.</description>
    <keyword>LSQFIT</keyword>
    <application/>
  </script>

  <script ID="353" category="Simple Problem" name="Lyot_Filter01.inr" title="Illustration of a three-stage Lyot filter">
    <description>
      This model uses three cascaded stages that are first,
      second, and fourth order, respectively. Each stage consists of a
      polarizer/analyzer and a crystal waveplate that modulates the
      throughput of the stage (as a function of wavelength, angle, ...).
      Each waveplate is rotated about the device axis 45 degrees
      relative to the X polarizer/analyzers so it may act on the
      two polarization components and rotate the resultant polarization.
      This results in modulation of throughput at the following analyzer.
      A diverging point grid source with X nominal polarization
      illuminates the filter. All polarizers are X-aligned. The
      throughput is checked using field energy integral at the detector.
      The position of all geometry elements is set by variables to
      make it simple to keep these (typically) thin elements from
      colliding. The element size and the detector size is scaled to be
      sure to capture the entire beam.
      This model uses quartz refractive index data at 400, 458, 590,
      and 694 nm from J.V.Atansoff and P.J.Hart, Phys. Rev. Vol.59,
      pp 85-96 1941, and A.W.Lawson, Phys. Rev. Vol 59, pp.838-839, 1941
      Wavelengths from 351 to 980 nm are included, so a reference
      wavelength should be set within this range to avoid extrapolation.
    </description>
    <keyword>Polarization</keyword>
    <keyword>Lyot</keyword>
    <keyword>POLARIZ</keyword>
    <keyword>POLAR</keyword>
    <keyword>IDEAL</keyword>
    <keyword>filter</keyword>
    <keyword>waveplate</keyword>
    <keyword>quartz</keyword>
    <keyword>crystal</keyword>
    <application/>
  </script>

  <script ID="354" category="Simple Problem" name="Mach-Zehnder_Interferometer_01.inr" title="Mach-Zehnder Interferometer">
    <description>
      Mach-Zehnder interferometer with circular fringes
      resulting from point-source illumination with a
      dense-medium slab to change the optical path length
      in one arm. Derived from Michelson_Interferometer.inr example.
    </description>
    <keyword>Wave</keyword>
    <keyword>interference</keyword>
    <keyword>Mach-Zehnder</keyword>
    <keyword>interferometer</keyword>
    <keyword>SPREAD</keyword>
    <keyword>splitter</keyword>
    <application/>
  </script>

  <script ID="355" category="Isolated Command" name="macro_$args01.inr" title="Macro Argument Passing">
    <description>
      Two examples of using $ARGS
      with a user-defined macro.
    </description>
    <keyword>$ARGS</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <application/>
  </script>

  <script ID="356" category="Isolated Command" name="macro_$args02.inr" title="$ARGS to Call Dialog Box">
    <description>
      Using $ARGS to create a dialog box
      for passing arguments to a macro.
    </description>
    <keyword>$ARGS</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <application/>
  </script>

  <script ID="357" category="Simple Problem" name="Macro_$ARGS03.inr" title="The USER Option">
    <description>
      The USER option tells ASAP what to
      do with unspecified arguments in the "calling"
      line to the macro. It allows arguments to be left
      off that are not specifically prompted for in the  macro.
      Normally, if arguments are left off, ASAP
      will prompt the user, even if there are no prompts  supplied by the macro. This allows for easier  batch mode operation. Note that for all macros,  the #n's are simple text substitutions done before
      any parsing occurs on the macro lines themselves.
      Any arguments that are left off are substituted
      with blanks.
    </description>
    <keyword>Macros_pre</keyword>
    <keyword>$ARGS</keyword>
    <keyword>macro</keyword>
    <keyword>USER</keyword>
    <application/>
  </script>

  <script ID="358" category="Isolated Command" name="Macro_$ASK01.inr" title="$ASK Predefined Macro">
    <description>Demonstrates the use of $ASK.</description>
    <keyword>$ASK</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>prompt</keyword>
    <keyword>ask</keyword>
    <keyword>VUFACETS</keyword>
    <application/>
  </script>

  <script ID="359" category="Isolated Command" name="macro_$ask02.inr" title="$ASK Pausing and Prompting">
    <description>
      Demonstrates the use of $ASK for
      pausing a script and prompting for input. Also shows
      A $DO loop containing a $IF...THEN structure using
      $NEXT to jump to top of loop and $LEAVE to prematurely
      exit loop.
    </description>
    <keyword>$ASK</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>$BEEP</keyword>
    <keyword>$IF</keyword>
    <keyword>$DO</keyword>
    <keyword>$LEAVE</keyword>
    <keyword>$NEXT</keyword>
    <application/>
  </script>

  <script ID="360" category="Isolated Command" name="macro_$datim01.inr" title="Turn off Plotting Date and Time">
    <description>
      How to turn off Date and Time
      stamps from showing up in plots. This may be
      desired when wanting to copy plots for
      publication purposes. A handy command to
      store into a User-defined button.
    </description>
    <keyword>$DATIM</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>plot</keyword>
    <application/>
  </script>

  <script ID="361" category="Isolated Command" name="macro_$dbg01.inr" title="Output of $DBG Macro">
    <description>
      Example output of $DBG showing how
      ASAP parser reads an input line. Used for debugging
      purposes. In the second part, since the command is
      on the same line, it does not get sent to the kernal.
    </description>
    <keyword>$DBG</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <application/>
  </script>

  <script ID="362" category="Isolated Command" name="Macro_$DO01.inr" title="$DO Predefined Macro">
    <description>Simple $DO loop to create 3 planes.</description>
    <keyword>$DO</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>loop</keyword>
    <application/>
  </script>

  <script ID="363" category="Simple Problem" name="Macro_$DO02.inr" title="Arrays with $DO &amp; Macros">
    <description>
      Making an array by calling a macro
      containing a $DO loop from another $DO loop.
      In this case, the other $DO loop is in a
      second macro which calls a third macro to
      create the geometry. See explanations in the
      body below.
    </description>
    <keyword>Macros_user</keyword>
    <keyword>$DO</keyword>
    <keyword>macro</keyword>
    <keyword>Arrays</keyword>
    <keyword>lenslet</keyword>
    <application/>
  </script>

  <script ID="364" category="Isolated Command" name="macro_$edit01.inr" title="Example Output of $EDIT">
    <description>
      Example output of $EDIT showing the
      default response when no options are given.
      Otherwise, the filename, macro or string may be
      specified on the command line.
    </description>
    <keyword>$EDIT</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <application/>
  </script>

  <script ID="365" category="Isolated Command" name="macro_$err01.inr" title="Branching on Input Error">
    <description>
      Example of $ERR usage. Error flag
      is set with $ERR command. At any time after
      this command is issued, ASAP will branch down
      to the bottom label if it encounters an input
      error and will resume executing with the RAYS 0
      command.
    </description>
    <keyword>$ERR</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <application/>
  </script>

  <script ID="366" category="Isolated Command" name="Macro_$EVAL01.inr" title="Graphing a Function with $EVAL">
    <description>
      Evaluating a simple sine-wave function
      in X using $EVAL. Uses the first form, where a range
      and steps are given for the variable. Produces the
      display file eval.dis which can be graphed.
    </description>
    <keyword>$EVAL</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>$FCN</keyword>
    <application/>
  </script>

  <script ID="367" category="Isolated Command" name="Macro_$FCN01.inr" title="$FCN Predefined Macro">
    <description>
      Simple use of $FCN. A hyperbolic sine
      function is defined and named SINH which accepts a
      single parameter using the underscore character (_).
    </description>
    <keyword>$FCN</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>function</keyword>
    <application/>
  </script>

  <script ID="368" category="Isolated Command" name="Macro_$GO01.inr" title="$GO Predefined Macro">
    <description>
      Skipping a portion of code using
      the $GO pre-defined macro. The label used here may
      be lower or upper case.  Lower case was chosen to
      allow easy commenting out of $GO line, without
      having to find the closing label (lower case ignored
      otherwise).
    </description>
    <keyword>$GO</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>goto</keyword>
    <keyword>skip</keyword>
    <application/>
  </script>

  <script ID="369" category="Isolated Command" name="macro_$go02.inr" title="Jump and Skip with $GO">
    <description>
      Using $GO to skip records or
      jump to other locations in the program.
      Several examples are shown below. Note
      that the jump-to label must begin in
      the first column.
    </description>
    <keyword>$GO</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>$IO</keyword>
    <application/>
  </script>

  <script ID="370" category="Isolated Command" name="Macro_$GRAB01.inr" title="$GRAB Predefined Macro">
    <description>
      Demonstrates the use of $GRAB.
      Uses $GRAB to assign variables to numbers
      that are printed to the command console.
    </description>
    <keyword>$GRAB</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>macro</keyword>
    <application/>
  </script>

  <script ID="371" category="Isolated Command" name="Macro_$GRAB02.inr" title="Grabbing Console Output">
    <description>
      Using $GRAB to grab console output
      data and assign to variables, for saving, printing
      or using in calculations. The example below grabs
      data from a STATS POS output (looks for the 1st
      three numbers after the string "Centroid") to set
      up a WINDOW command.
    </description>
    <keyword>$GRAB</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <application/>
  </script>

  <script ID="372" category="Isolated Command" name="Macro_$HELP01.inr" title="Using $HELP">
    <description>
      Several examples of using $HELP.
      Note when "&amp;" is used instead of "$" it only shows the
      command format without text description.
    </description>
    <keyword>$HELP</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <application/>
  </script>

  <script ID="373" category="Isolated Command" name="Macro_$IF01.inr" title="$IF Predefined Macro #1">
    <description>Demonstrates the use of $IF.</description>
    <keyword>$IF</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>$ENDIF</keyword>
    <application/>
  </script>

  <script ID="374" category="Isolated Command" name="Macro_$IF02.inr" title="$IF Predefined Macro #2">
    <description>
      Using $IF to provide typical decision
      branching found in most programming environments.  $IF's may be nested.
    </description>
    <keyword>$IF</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>$ELSEIF</keyword>
    <keyword>$ELSE</keyword>
    <keyword>EQ</keyword>
    <application/>
  </script>

  <script ID="375" category="Isolated Command" name="Macro_$IF03.inr" title="Examples with $IF THEN">
    <description>Several examples of using $IF.</description>
    <keyword>$IF THEN</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>$IF</keyword>
    <keyword>EQ</keyword>
    <keyword>$GO</keyword>
    <application/>
  </script>

  <script ID="376" category="Isolated Command" name="Macro_$IO01.inr" title="$IO Predefined Macro #1">
    <description>
      Simple use of $IO to output data to a file.
      FILE(10) tells ASAP to use a file unit number of 10 or
      higher.
    </description>
    <keyword>$IO</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>io</keyword>
    <keyword>output</keyword>
    <keyword>file</keyword>
    <keyword>redirect</keyword>
    <application/>
  </script>

  <script ID="377" category="Isolated Command" name="Macro_$IO02.inr" title="$IO for Redirection">
    <description>
      Using $IO to output selected data to a file.
      Shows hot to turn off console output while writing to file.
      Also shows how to append data to the current file.
      FILE(10) tells ASAP to use a file unit number of 10 or
      higher.
    </description>
    <keyword>$IO</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>io</keyword>
    <keyword>$ECHO</keyword>
    <keyword>redirect</keyword>
    <keyword>file</keyword>
    <application/>
  </script>

  <script ID="378" category="Isolated Command" name="Macro_$IO03.inr" title="$IO for Program Breaks">
    <description>
      Using $IO to provide a break or pause
      in a script file. Here, after geometry is created,
      a $IO pauses execution. another $IO typed from the
      command console allows the program to continue  from that point.
      If not, you must hit the END button  to start again.
    </description>
    <keyword>$IO</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>break</keyword>
    <keyword>pause</keyword>
    <keyword>PATHS</keyword>
    <application/>
  </script>

  <script ID="379" category="Isolated Command" name="Macro_$IO04.inr" title="File Input and IO Control">
    <description>Several examples of using $IO.</description>
    <keyword>$IO</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>file</keyword>
    <keyword>redirect</keyword>
    <keyword>output</keyword>
    <application/>
  </script>

  <script ID="380" category="Isolated Command" name="Macro_$ITER01.inr" title="$ITER Predefined Macro">
    <description>
      Using $ITER to plot a function over
      a specified range (including end points).  The result
      for Y is found over 40 points taken in the X range of
    </description>
    <keyword>$ITER</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>loop</keyword>
    <keyword>iterate</keyword>
    <application/>
  </script>

  <script ID="381" category="Isolated Command" name="macro_$iter02.inr" title="Iterating Records">
    <description>
      Plotting transverse ray abberations
      using $ITER. The $ITER below looks for a ray with
      minimum Y value over a range of rows that were
      printed to the output console.
    </description>
    <keyword>$ITER</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>loop</keyword>
    <keyword>iterate</keyword>
    <application/>
  </script>

  <script ID="382" category="Isolated Command" name="Macro_$ITER03.inr" title="$ITER Root Find Output">
    <description>
      Output produced from $ITER root finding
      example. This is not a runable inr file.
    </description>
    <keyword>$ITER</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>output</keyword>
    <keyword>iterate</keyword>
    <keyword>root</keyword>
    <application/>
  </script>

  <script ID="383" category="Isolated Command" name="macro_$leave01.inr" title="Example of $LEAVE">
    <description>
      Example of where to use $LEAVE.
      In this case, if $IF is true, it will leave
      the $DO loop.
    </description>
    <keyword>$LEAVE</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>$DO</keyword>
    <application/>
  </script>

  <script ID="384" category="Isolated Command" name="Macro_$REG01.inr" title="Example of $REG">
    <description>
      Various ways of using $REG to
      print out variable or register values. Note
      that "&amp;" in place of "$" makes for a cleaner
      output.
    </description>
    <keyword>$REG</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>output</keyword>
    <application/>
  </script>

  <script ID="385" category="Isolated Command" name="Macro_$SCR01.inr" title="$SCR and Cancel">
    <description>
      A few examples of using $SCR to
      print out a dialog box of information and
      how to test for and use the Cancel button.
    </description>
    <keyword>$SCR</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>output</keyword>
    <keyword>$GO</keyword>
    <application/>
  </script>

  <script ID="386" category="Isolated Command" name="Macro_$SCR02.inr" title="Screen Entry with $SCR">
    <description>
      Using $SCR to generate an input screen
      for the user. Suppose you wanted to setup a screen
      entry for a mirror. One possibility involving two macros
      is shown below. The second macro MAKEOBJ was necessary
      in order to get the name of the OBJECT contained in the
      N" variable into the comment string. If you had written
      OBJECT 'N"' instead, the parser would have put the
      character string N" into the comment rather than the
      contents of N".
    </description>
    <keyword>$SCR</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>input</keyword>
    <keyword>string</keyword>
    <application/>
  </script>

  <script ID="387" category="Isolated Command" name="Macro_$SCR03.inr" title="Output Formatting with $SCR">
    <description>
      Using $SCR to generate output of text
      and values in a desired format. While the $REG command
      is useful for printing out variable information, it is
      crude because it doesn't allow formatting. The $SCR
      command is a convenient way to output data in a more
      aesthetic manner. Consider the following simplistic
      comparison of printing the contents of two variables.
    </description>
    <keyword>$SCR</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>output</keyword>
    <keyword>formatting</keyword>
    <application/>
  </script>

  <script ID="388" category="Isolated Command" name="Macro_$STO_RCL01.inr" title="Saving and Retrieving Stored Variables">
    <description>
      How to save and retrieve variables from
      saved register files. See below for examples. This
      is not a runable inr file.
    </description>
    <keyword>$STO</keyword>
    <keyword>$RCL</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>register</keyword>
    <keyword>variable</keyword>
    <application/>
  </script>

  <script ID="389" category="Isolated Command" name="Macro_$SYS01.inr" title="$SYS to Run External Commands">
    <description>
      Shows how $SYS may be used to perform
      an external process. In this case, temp files are
      created by the PICTURE command and may be left behind.
      $SYS is used to delete the unwanted files when done.
      The screen will go black while executing the command
      prompt function.
    </description>
    <keyword>$SYS</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>PICTURE</keyword>
    <application/>
  </script>

  <script ID="390" category="Isolated Command" name="Macro_$SYS02.inr" title="Passing Literals to $SYS Macro">
    <description>
      Shows how a $SYS may be performed via macro to enable
      passing to it a concatenated string that controls an external process.
      The result of this $SYS is simply to delete the unwanted files
      when the script ends.
    </description>
    <keyword>$SYS</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>literal</keyword>
    <keyword>string</keyword>
    <keyword>concatenation</keyword>
    <application/>
  </script>

  <script ID="391" category="Isolated Command" name="Macro_$TIC01.inr" title="Time Interval Check using $TIC">
    <description>
      Using $TIC to measure elapsed time. An
      interval of CPU time is tracked from one TIC
      to the next. The &amp;TIC is used to reset the timer with
      no elapsed time output generated. Optional fixed time
      units may be specified (MICroseconds, MILiseconds, SEConds,
      MINutes, HOUrs, YEArs, or OFF for floating units).
    </description>
    <keyword>$TIC</keyword>
    <keyword>time</keyword>
    <application/>
  </script>

  <script ID="392" category="Isolated Command" name="macro_$view01.inr" title="3D View of Geometry">
    <description>Displaying a 3D view of geometry  in the 3D viewer.  A model of a Petzval lens.</description>
    <keyword>$VIEW</keyword>
    <keyword>LENSES</keyword>
    <keyword>SEQUENCE</keyword>
    <keyword>macro</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>3d</keyword>
    <application/>
  </script>

  <script ID="393" category="Simple Problem" name="Macro_Fresnel_Lens.inr" title="Fresnel Lens Macro">
    <description>
      A macro that makes an aspheric Fresnel lens. It
      uses parameters based on Edmund Scientic Fresnel lens. Another
      smaller macro is used for creating a test source.
    </description>
    <keyword>Macros_user</keyword>
    <keyword>Fresnel</keyword>
    <keyword>lens</keyword>
    <keyword>macro</keyword>
    <keyword>$FCN</keyword>
    <keyword>SWEEP</keyword>
    <keyword>AXIS</keyword>
    <application/>
  </script>

  <script ID="394" category="Simple Problem" name="macro_library.inr" title="Example Library of Macros">
    <description>
      This is an example set of macros
      to be saved as a library file with the .LIB
      extension.
    </description>
    <keyword>Scripts</keyword>
    <keyword>library</keyword>
    <keyword>macro</keyword>
    <application/>
  </script>

  <script ID="395" category="Simple Problem" name="Macro_User01.inr" title="A Simple Macro">
    <description>
      The basic user-defined macro. Makes a
      spherical mirror.
    </description>
    <keyword>Macros_user</keyword>
    <keyword>macro</keyword>
    <application/>
  </script>

  <script ID="396" category="Simple Problem" name="map_slopes.inr" title="Accessing Multivalued Display Files">
    <description>
      Using DISPLAY options of 1ST,
      2ND, and so forth, to access additional matrix
      values. Some display commands will produce these
      additional matrices.  For this example, MAP SLOPES
      is used. It creates two additional matrices of slope
      values for each window dimension. These are accessed
      through the 2ND and 3RD option as shown below.
    </description>
    <keyword>Analysis</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>MAP</keyword>
    <keyword>SLOPES</keyword>
    <application/>
  </script>

  <script ID="397" category="Isolated Command" name="matrix01.inr" title="MATRIX Rotation">
    <description>
      Example of a MATRIX command
      equivalent to a ROTATE.
    </description>
    <keyword>MATRIX</keyword>
    <keyword>Manipulating</keyword>
    <application/>
  </script>

  <script ID="398" category="Isolated Command" name="matrix02.inr" title="MATRIX PREVIOUS Option">
    <description>Example of a MATRIX command</description>
    <keyword>MATRIX</keyword>
    <keyword>PREVIOUS</keyword>
    <keyword>Manipulating</keyword>
    <application/>
  </script>

  <script ID="399" category="Isolated Command" name="matrix03.inr" title="Compare MATRIX and ROTATE">
    <description>
      Compare the MATRIX command to the
      ROTATE command. Create 1 Plane surface. Then
      create 2 identical surfaces at the same place.
      ROTATE 1 of the surfaces. Use the MATRIX command
      to rotate the other surface. Inspect with 3D-Viewer.
    </description>
    <keyword>MATRIX</keyword>
    <keyword>Manipulating</keyword>
    <keyword>ROTATE</keyword>
    <application/>
  </script>

  <script ID="400" category="Isolated Command" name="MATRIX04.inr" title="Converting MATRIX to Discrete Translations">
    <description>Convert a direct MATRIX command input to a  discrete sequence of ROTATEs and SHIFTs using the LIST option.  Create 1 Plane surface with MATRIX. Apply the LIST option at  the end of the last line. This gives the rotational angle info  to use with ROTATE in the Ouput Console.  Can use either X-Y-Z  or Z-Y-X data to reconstruct the translation matrix (not both)  using discrete ROTATE commands. Note that Z-Y-X is in that  order even though it falls under the columns in the order of  X-Y-Z. ROTATE commands must be referenced to Global Origin, and  therefore any additional SHIFTs must follow at the end.  SHIFTs  are determined by the number in the first column (displacement  vector).  In this example, only a Z shift is given.   A second surface is created with the discrete commands and  is compared to the other, showing they overlap exactly.  A LIST is also done after the last translation command, in  this case SHIFT, to show the computed MATRIX is the same as  the previous MATRIX entered. The first line in the Matrix output  can be ignored.  Initially, for this example, simple integer  numbers were used with ROTATE and SHIFT and the LIST output was  copied and used for the direct MATRIX input on the first surface.  This shows the LIST output may be used either way for conversion.</description>
    <keyword>MATRIX</keyword>
    <keyword>Manipulating</keyword>
    <keyword>LIST</keyword>
    <keyword>ROTATE</keyword>
    <application/>
  </script>

  <script ID="401" category="Isolated Command" name="MATRIX05.inr" title="MATRIX For Source Coordinate System Conversion">
    <description>
      Example of using the MATRIX command to change from
      left handed to right handed coordinate system. This can be useful
      for converting Radiant Imaging ray files to the ASAP right-handed
      system.
    </description>
    <keyword>MATRIX</keyword>
    <keyword>Sources</keyword>
    <keyword>Manipulating</keyword>
    <keyword>handedness</keyword>
    <keyword>coordinate system</keyword>
    <application/>
  </script>

  <script ID="402" category="Isolated Command" name="MATRIX06.inr" title="MATRIX 'k' Option">
    <description>
      Example of using the MATRIX k option to specify
      a previous entities' matrix.
    </description>
    <keyword>MATRIX</keyword>
    <keyword>Manipulating</keyword>
    <application/>
  </script>

  <script ID="403" category="Isolated Command" name="media01.inr" title="Defining Non-dispersive Media">
    <description>
      Defining non-dispersive media.
      Three examples of using the MEDIA command
      are given.
    </description>
    <keyword>MEDIA</keyword>
    <keyword>ABSORB</keyword>
    <application/>
  </script>

  <script ID="404" category="Isolated Command" name="media02.inr" title="Defining Dispersive Media">
    <description>
      Defining wavelengths and their
      associated dispersive media.
    </description>
    <keyword>MEDIA</keyword>
    <keyword>WAVELENGTHS</keyword>
    <application/>
  </script>

  <script ID="405" category="Simple Problem" name="Media_Absorb.inr" title="Making Absorbing Media">
    <description>
      How to make an absorbing media letting ASAP
      calculate the absorption, using MEDIA ABSORB command.
    </description>
    <keyword>Interfaces</keyword>
    <keyword>MEDIA</keyword>
    <keyword>ABSORB</keyword>
    <keyword>beer's law</keyword>
    <application/>
  </script>

  <script ID="406" category="Simple Problem" name="MEDIA_ABSORB02.inr" title="Making Absorbing Media #2">
    <description>
      Using the absorption coefficient on the
      MEDIA command line.  Origin is at Vertex 1. Propagation
      direction is +Z.  Units are in MM.
    </description>
    <keyword>Interfaces</keyword>
    <keyword>MEDIA</keyword>
    <keyword>ABSORB</keyword>
    <keyword>$FCN</keyword>
    <keyword>$EVAL</keyword>
    <keyword>absorption</keyword>
    <keyword>beer's law</keyword>
    <application/>
  </script>

  <script ID="407" category="Isolated Command" name="MESH_COLOR01.inr" title="MESH Plot Using COLOR Option">
    <description>
      How to do a mesh plot of multiple sources
      in different colors. Two sources are created to emit in
      opposite directions. A radiant distribution of each source
      is averaged around the X-Y plane.  A MESH plot with
      assigned color is sent to the vector file which can be
      displayed in the 3-D viewer. The default for MESH is B&amp;W.
    </description>
    <keyword>MESH</keyword>
    <keyword>COLORS</keyword>
    <keyword>plot</keyword>
    <application/>
  </script>

  <script ID="408" category="Simple Problem" name="mesh_object.inr" title="Mesh Object from Edges">
    <description>A mesh object formed from edges.</description>
    <keyword>Edges</keyword>
    <keyword>MESH</keyword>
    <keyword>REPEAT</keyword>
    <keyword>PLOT</keyword>
    <application/>
  </script>

  <script ID="409" category="Simple Problem" name="michelson_interferometer.inr" title="Michelson Interferometer">
    <description>
      Interferometer using two mirrors
      and a beam splitter.  A plane wave splits in two,
      hits two mirrors at equal distance and are sent
      back through the splitter to end up at the same
      location on the detector. One mirror is tilted
      slightly to show the interference effects between
      the two beams.
    </description>
    <keyword>Wave</keyword>
    <keyword>interference</keyword>
    <keyword>Michelson</keyword>
    <keyword>interferometer</keyword>
    <keyword>SPREAD</keyword>
    <keyword>splitter</keyword>
    <application/>
  </script>

  <script ID="410" category="Simple Problem" name="mie_scatter_mil1246c.inr" title="MIL-STD 1246C Particle Scatter">
    <description>
      Mie scatter calculation for bsdf
      of a surface with MIL-STD 1246C contamination
      distribution. Change wavelength and index of
      refraction for the particles matching your system.
      Also must set the coverage fraction and
      cleanliness level.  They are not independent.
      If you know your cleanliness level, then the
      coverage fraction has a corresponding value.
      Particle model works well with large wavelengths
      or where particle size is small compared to
      wavelength. If particles get large compared to
      wavelength, then BSDF may not be correct for
      angles less than 2 or 3 degrees.
    </description>
    <keyword>Scatter</keyword>
    <keyword>PARTICLES</keyword>
    <keyword>MIE</keyword>
    <keyword>1246C</keyword>
    <keyword>$FCN</keyword>
    <application/>
  </script>

  <script ID="411" category="Isolated Command" name="missed01.inr" title="Rays Missing Absorbing Surface">
    <description>
      Shows ho to display missed rays in
      the 3D viewer. Note that 2D plots show missed rays
      out to edge of plot as a convenience, but will not
      normally show up in 3D viewer. Uses an emitting
      spheroid reflected off an extruded edge toward
      an absorbing plane.
    </description>
    <keyword>MISSED</keyword>
    <keyword>rays</keyword>
    <keyword>Analysis</keyword>
    <application/>
  </script>

  <script ID="412" category="Isolated Command" name="modify.inr" title="MODIFY Display Command">
    <description>
      Modifies the distribution.
      Performed after a DISPLAY command.
    </description>
    <keyword>MODIFY</keyword>
    <keyword>DISPLAY</keyword>
    <application/>
  </script>

  <script ID="413" category="Isolated Command" name="move01.inr" title="Moving Rays along Trajectory">
    <description>
      Model of a landscape lens to
      demonstrate MOVE command. Entrance pupil
      is located 5.639 inches from 1st surface.
      Entrance pupil is 1 inch in diameter
      and 10 degrees off-axis. Before and after
      SPOTS are shown.
    </description>
    <keyword>MOVE</keyword>
    <keyword>rays</keyword>
    <application/>
  </script>

  <script ID="414" category="Isolated Command" name="MOVE_TO_PLANE.inr" title="Moving a Source to a Plane">
    <description>
      Demonstration of MOVE TO PLANE.
      Some simple geometry is created and the source is
      moved to a different location (plane).
    </description>
    <keyword>MOVE TO PLANE</keyword>
    <keyword>GRID</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="415" category="Isolated Command" name="MOVE_TO_POINT.INR" title="Moving a Source to a Point">
    <description>
      Demonstration of MOVE TO POINT.
      Some simple geometry is created and the source is
      moved to a different location (point).
    </description>
    <keyword>MOVE TO POINT</keyword>
    <keyword>Sources</keyword>
    <keyword>GRID</keyword>
    <keyword>Tracing</keyword>
    <application/>
  </script>

  <script ID="416" category="Isolated Command" name="MOVE_TO_SPHERE.inr" title="Moving a source to a reference sphere">
    <description>
      Demonstration of MOVE TO SPHERE.
      Some simple geometry is created and a source is
      moved to a different location along a reference sphere.
    </description>
    <keyword>MOVE TO SPHERE</keyword>
    <keyword>Sources</keyword>
    <keyword>GRID</keyword>
    <keyword>Tracing</keyword>
    <application/>
  </script>

  <script ID="417" category="Simple Problem" name="Msquared.inr" title="Creating and characterizing an M-squared gaussian beam in ASAP">
    <description>
      Demonstrates technique for creating an M-squared
      laser beam in ASAP. Requires making a wavelength adjustment to
      compensate for the increased divergence of a non-ideal gaussian.
    </description>
    <keyword>Wave</keyword>
    <keyword>M-squared</keyword>
    <keyword>GAUSSIAN</keyword>
    <keyword>FIELD</keyword>
    <keyword>ENERGY</keyword>
    <keyword>$ITER</keyword>
    <application/>
  </script>

  <script ID="418" category="Simple Problem" name="mtf_ideal_lens.inr" title="MTF from an Ideal Lens">
    <description>
      MTF produced by an ideal lens using FFT.
      First the PSF is plotted at one wavelength. Then the
      spatial frequency spectrum is calculated with FFT  and plotted.
    </description>
    <keyword>Wave</keyword>
    <keyword>FIELD</keyword>
    <keyword>mtf</keyword>
    <keyword>IDEAL</keyword>
    <keyword>FFT</keyword>
    <keyword>LENSES</keyword>
    <keyword>ENERGY</keyword>
    <keyword>psf</keyword>
    <application/>
  </script>

  <script ID="419" category="Simple Problem" name="mtf_obscured.inr" title="Monochromatic Diffraction MTF">
    <description>Monochromatic diffraction MTF of an obscured aperture F/2 system.</description>
    <keyword>Wave</keyword>
    <keyword>mtf</keyword>
    <keyword>FFT</keyword>
    <keyword>diffraction</keyword>
    <keyword>macro</keyword>
    <keyword>APPEND</keyword>
    <application/>
  </script>

  <script ID="420" category="Simple Problem" name="Multiple_Display_Graph_01.inr" title="Multiple 1D Display Files in One 2D Graph">
    <description>
      Demonstrates the combining 1-dimensional graphs into a single
      2-dimensional distribution so the graphs are easily ploted together.
      A Gaussian superposition of beams is illustrated as an example.
    </description>
    <keyword>Analysis</keyword>
    <keyword>GRAPH</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>RANGE</keyword>
    <keyword>MODIFY</keyword>
    <keyword>HEADER</keyword>
    <keyword>REPLICATE</keyword>
    <keyword>REDUCE</keyword>
    <keyword>COMBINE</keyword>
    <keyword>superposition</keyword>
    <keyword>Gaussian</keyword>
    <keyword>multiple</keyword>
    <application/>
  </script>

  <script ID="421" category="Simple Problem" name="multiple_iter_graph.inr" title="Graphing Multiple ITER Results">
    <description>
      Graphing several iter display files on
      one plot.  A $ITER which performs wavelength vs. irradiance
      over a thermal spectrum is put inside a macro.  This way
      the iter may be called from a $DO loop, passing it a
      parameter which changes the absorption of the material.
      On each loop a $ITER display file is produced and plotted
      on the same graph. Probably an unnecessarily complicated
      way to show how to graph several display files in the same
      plot after having fixed the range.
    </description>
    <keyword>Analysis</keyword>
    <keyword>$ITER</keyword>
    <keyword>GRAPH</keyword>
    <keyword>$DO</keyword>
    <keyword>APPEND</keyword>
    <keyword>RANGE</keyword>
    <keyword>macro</keyword>
    <application/>
  </script>

  <script ID="422" category="Simple Problem" name="multi_color_source01.inr" title="Multi-color Source">
    <description>
      Using an emitting object at multiple
      specified by SPECTRUM VISIBLE.
    </description>
    <keyword>Sources</keyword>
    <keyword>SPECTRUM</keyword>
    <keyword>VISIBLE</keyword>
    <keyword>WAVELENGTH</keyword>
    <keyword>EMITTING</keyword>
    <keyword>OBJECT</keyword>
    <application/>
  </script>

  <script ID="423" category="Isolated Command" name="numbers_names.inr" title="NUMBERS NAMES Output">
    <description>
      Output from the NUMBERS NAMES
      command.
    </description>
    <keyword>NUMBERS</keyword>
    <keyword>NAMES</keyword>
    <keyword>CONSIDER</keyword>
    <application/>
  </script>

  <script ID="424" category="Isolated Command" name="object01.inr" title="A Single Edge Object">
    <description>
      An example of a single EDGE
      object.
    </description>
    <keyword>OBJECT</keyword>
    <keyword>Edges</keyword>
    <application/>
  </script>

  <script ID="425" category="Isolated Command" name="object02.inr" title="Slicing Irradiance with SPREAD">
    <description>
      Solid object formed from a collection  of surfaces. This uses the second form of the
      OBJECT command.
    </description>
    <keyword>OBJECT</keyword>
    <keyword>Geometry</keyword>
    <keyword>RENDER</keyword>
    <application/>
  </script>

  <script ID="426" category="Simple Problem" name="OBJECT_Redefine01.inr" title="Redefining OBJECT Properties">
    <description>
      How to change the properties of
      a previously-defined object. In this case,
      the interface properties are changed.
    </description>
    <keyword>Geometry</keyword>
    <keyword>OBJECT</keyword>
    <keyword>INTERFACE</keyword>
    <keyword>redefining</keyword>
    <application/>
  </script>

  <script ID="427" category="Simple Problem" name="OBJECT_Redefine02.inr" title="Redefining Objects: A Practical Application">
    <description>
      An application for modifying
      SURFACE and OBJECT database settings, including
      BOUNDS. This example shows a TUBE filled part
      way with water that rises a certain amount through
      each pass of the loop. INTERFACE COATING
      assignments are properly maintained for all objects
      by updating on each pass. Source creation, ray
      tracing, and analysis would normally be included
      withing the loop, as well. A RAYS 0 should be
      performed at the top of the loop to clear previously
      traced rays. All other objects, including detector
      can be made before the loop, similar to the
      TUBE_OUTER seen here.
    </description>
    <keyword>Geometry</keyword>
    <keyword>OBJECT</keyword>
    <keyword>INTERFACE</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>redefining</keyword>
    <keyword>water</keyword>
    <keyword>$DO</keyword>
    <application/>
  </script>

  <script ID="428" category="Simple Problem" name="Object_Tree_Branching.inr" title="Making an Object Tree">
    <description>
      The following demonstrates the use of the
      BRANCH command to assign common names to a group of
      objects that have a common theme. The individual objects
      of the branch are sequentially numbered using a $DO loop.
      The branch name is given just before each common group
      of objects is created. New branch names may be tacked on
      to the last one by using a period (.) before the name.
      New branch names could also be attached to previous levels
      by using the caret (^) symbol before the name. This
      moves the assignment up one level (for each caret).
    </description>
    <keyword>Scripts</keyword>
    <keyword>BRANCH</keyword>
    <keyword>TREE</keyword>
    <keyword>OBJECT</keyword>
    <keyword>$DO</keyword>
    <keyword>NUMBERS</keyword>
    <application/>
  </script>

  <script ID="429" category="Simple Problem" name="OCTAGONAL_PYRAMID_ARRAY_CROSSED_ROOFS.inr" title="Octagonal pyramid array by bounded, crossed ROOFS">
    <description>
      An ARRAY of hexagonal pyramids is made using crossed
      ROOF surfaces. The three ROOFs are mutually bounded to form the pyramids.
      Please note the possibility for ray leakage (see Help, ROOF command)
      (approx 3% measured) when directing rays on axis with the pyramids.
      This should not be a concern when intersecting with randomized ray directions.
    </description>
    <keyword>Arrays</keyword>
    <keyword>ROOF</keyword>
    <keyword>ARRAY</keyword>
    <keyword>OBLIQUE</keyword>
    <keyword>RENDER</keyword>
    <keyword>LIGHTS</keyword>
    <keyword>pyramid</keyword>
    <keyword>octagonal</keyword>
    <application/>
  </script>

  <script ID="430" category="Isolated Command" name="OFFSET01.inr" title="Use of the OFFSET command">
    <description>
      Create a BRO009.DAT file
      with first element of Cooke Triplet and GRID source.
      OFFSET simply moves the distribution file
      to the new location without altering the shape.
    </description>
    <keyword>OFFSET</keyword>
    <keyword>DISPLAY</keyword>
    <application/>
  </script>

  <script ID="431" category="Isolated Command" name="opdmap01.inr" title="Wavefront Map of Singlet">
    <description>
      Making an on-axis and off-axis
      wavefront map of a singlet lens using OPDMAP.
    </description>
    <keyword>OPDMAP</keyword>
    <keyword>wavefront</keyword>
    <application/>
  </script>

  <script ID="432" category="Simple Problem" name="optical04.inr" title="Cassegrain Telescope #1">
    <description>
      Simple Cassegrain telescope
      using the OPTICAL command to make the  mirrors.
    </description>
    <keyword>Geometry</keyword>
    <keyword>OPTICAL</keyword>
    <keyword>Cassegrain</keyword>
    <keyword>telescope</keyword>
    <application/>
  </script>

  <script ID="433" category="Simple Problem" name="Optical_Activity.inr" title="Analyzing Optically Active Media">
    <description>
      Using PLOT POLAR and LIST ELLIPSE to
      analyze a crystal-type polarizer coupled to an optically active element.
      The CRYSTAL media generates two rays, ordinary and extraordinary. The
      ordinary ray is then sent through the active medium where its
      polarization state rotates as it propagates. The polarization
      is plotted as it is traced in steps, in a timed loop, to allow the
      polarization vector direction to be watched as it evolves.
    </description>
    <keyword>Polarization</keyword>
    <keyword>PLOT</keyword>
    <keyword>ACTIVITY</keyword>
    <keyword>CRYSTAL</keyword>
    <keyword>LIST ELLIPSE</keyword>
    <keyword>POLARIZ</keyword>
    <keyword>TRACE STEP</keyword>
    <keyword>$WAIT</keyword>
    <application/>
  </script>

  <script ID="434" category="Isolated Command" name="OPTICAL_Dual.inr" title="Dual OPTICAL Surface">
    <description>
      Two examples of making two-sided
      singlet lenses as one object. The second line
      provides the optional second surface parameters.
      The first argument given is the relative distance
      (t) from the first surface.
      The first example shows an aspheric optical
      surface whose vertex is located at y = 0
      with a radius of curvature of -30 and a
      conic constant of -1. The 4th, 6th, 8th and
      10th order deformation coefficients are 1E-3,
    </description>
    <keyword>OPTICAL</keyword>
    <keyword>SURFACE</keyword>
    <keyword>aspheric</keyword>
    <keyword>singlet</keyword>
    <application/>
  </script>

  <script ID="435" category="Simple Problem" name="Optimize01.inr" title="Optimizing a Cassegrain Telescope">
    <description>
      Optimization of a telescope mirror system.
      Within the specified constraints, finds the minimum
      rms spot size on axis.  The results are stored and the
      optimized system is traced.
    </description>
    <keyword>Lenses</keyword>
    <keyword>Optimization</keyword>
    <keyword>ABERRATIONS</keyword>
    <keyword>VARIABLES</keyword>
    <keyword>MINIMIZE</keyword>
    <keyword>STORE</keyword>
    <application/>
  </script>

  <script ID="436" category="Simple Problem" name="Optimize01_temp.inr" title="Optimizing a Cassegrain Telescope">
    <description>
      Optimization of a telescope mirror system.
      Within the specified constraints, finds the minimum
      rms spot size on axis.  The results are stored and the
      optimized system is traced.
    </description>
    <keyword>Lenses</keyword>
    <keyword>Optimization</keyword>
    <keyword>ABERRATIONS</keyword>
    <keyword>VARIABLES</keyword>
    <keyword>MINIMIZE</keyword>
    <keyword>STORE</keyword>
    <application/>
  </script>

  <script ID="437" category="Simple Problem" name="Optimize02.inr" title="Optimizing a Maksutov Telescope">
    <description>
      Optimization of a telescope mirror system,
      within specified constraints.  Uses a fast algorithm
      that finds the minimum rms spot size at a single on-axis
      field.
    </description>
    <keyword>Lenses</keyword>
    <keyword>Optimization</keyword>
    <keyword>ABERRATIONS</keyword>
    <keyword>VARIABLES</keyword>
    <keyword>MINIMIZE</keyword>
    <application/>
  </script>

  <script ID="438" category="Simple Problem" name="Optimize03.inr" title="Optimizing a Fourier Transform Lens">
    <description>
      Optimization of a multi-element telecentric
      lens system.  Default is 10 elements. Several field
      locations are used. The final result is saved as a macro
      and run.
    </description>
    <keyword>Lenses</keyword>
    <keyword>Optimization</keyword>
    <keyword>ABERRATIONS</keyword>
    <keyword>VARIABLES</keyword>
    <keyword>MINIMIZE</keyword>
    <keyword>STORE</keyword>
    <application/>
  </script>

  <script ID="439" category="Simple Problem" name="Optimize04.inr" title="Optimizing a three-lens imaging system">
    <description>
      An attempt at optimizing a three-lens system.
      The result can be compared to the "Cooke Triplet" design
      included in William Smith's book, "Modern Lens Design".
    </description>
    <keyword>Lenses</keyword>
    <keyword>Optimization</keyword>
    <keyword>ABERRATIONS</keyword>
    <keyword>VARIABLES</keyword>
    <keyword>MINIMIZE</keyword>
    <keyword>STORE</keyword>
    <application/>
  </script>

  <script ID="440" category="Simple Problem" name="Optimize_Singlet.inr" title="Optimizing a singlet lens">
    <description>
      Optimization of singlet lens bending factor.
      Finds the minimum rms spot size on axis.  The results are
      stored and the optimized system is traced.  The resulting
      bending factor and curvatures are printed at the end.
      See also "ITER_SINGLET01.INR" and "ITER_SINGLET02.INR"
      for a comparison using $ITER (both forms).
    </description>
    <keyword>Lenses</keyword>
    <keyword>Optimization</keyword>
    <keyword>ABERRATIONS</keyword>
    <keyword>VARIABLES</keyword>
    <keyword>MINIMIZE</keyword>
    <keyword>STORE</keyword>
    <application/>
  </script>

  <script ID="441" category="Simple Problem" name="Optimize_Singlet_temp.inr" title="Optimizing a singlet lens">
    <description>
      Optimization of singlet lens bending factor.
      Finds the minimum rms spot size on axis.  The results are
      stored and the optimized system is traced.  The resulting
      bending factor and curvatures are printed at the end.
      See also "ITER_SINGLET01.INR" and "ITER_SINGLET02.INR"
      for a comparison using $ITER (both forms).
    </description>
    <keyword>Lenses</keyword>
    <keyword>Optimization</keyword>
    <keyword>ABERRATIONS</keyword>
    <keyword>VARIABLES</keyword>
    <keyword>MINIMIZE</keyword>
    <keyword>STORE</keyword>
    <application/>
  </script>

  <script ID="442" category="Simple Problem" name="Output_ANGLES.inr" title="Using VALUES to Output Exact Angle Data">
    <description>
      Shows how to output an exact angular range of -90 to 90
      to a text file.  The idea is to get a slice along the X and Y with
      increments every 2 degrees. Normally, a distribution file has a
      range of -89.x to 89.x, where x is determined by the number of
      PIXELS. The outermost pixels can't go beyond the window edge.  Using
      VALUES, actual data coordinates are given which extracts an interpolated
      value from the distribution.  This allows one to produce a file that
      begins exactly at the ends of the window, such as -90 to 90 (or -1 to 1
      in dir-cosine space).  The end values would be extrapolated from the
      closest nearby pixel.  Accuracy should improve with more rays and higher  PIXELS.
    </description>
    <keyword>Radiometry</keyword>
    <keyword>VALUES</keyword>
    <keyword>$SCR</keyword>
    <keyword>ANGLES</keyword>
    <keyword>$IO</keyword>
    <application/>
  </script>

  <script ID="443" category="Simple Problem" name="Output_Formatted01.inr" title="Writing Formatted Output #1">
    <description>
      Demonstrates the use of $IO to redirect data,
      and $SCR to write out lines of formatted output.  In
      this example the data are written to RAYDATA.TXT.
      Four values are written by $SCR each time through the loop.
      The "1" after $SCR tells ASAP to expect one line of
      formatting information after the commmand (120 chars max).
      The width of each field is indicated by the distance between
      the / / delimiters.  The .9 tells ASAP to write a floating-
      point number with nine places after the decimal point.
      FILE(10) tells ASAP to use a file unit number of 10 or  higher.
    </description>
    <keyword>Macros_pre</keyword>
    <keyword>output</keyword>
    <keyword>formatting</keyword>
    <keyword>$SCR</keyword>
    <keyword>$IO</keyword>
    <keyword>GET</keyword>
    <application/>
  </script>

  <script ID="444" category="Simple Problem" name="Output_Formatted02.inr" title="Writing Formatted Output #2">
    <description>
      Demonstrates the use of $IO to redirect data,
      and $SCR to write out lines of formatted output.  In
      this example the data are written to a file named TEST.
      Three values are written each time $SCR is encountered.
      The "1" after $SCR tells ASAP to expect one line of
      formatting information after the commmand.  The width
      of each field is indicated by the distance between the  / / delimiters.
      The .9 tells ASAP to write a floating-
      point number with nine places after the decimal point.
      To append more data to the file TEST (in a DO loop, for
      example), use +FILE(21) on subsequent output
      redirection, as shown at the bottom.
    </description>
    <keyword>Macros_pre</keyword>
    <keyword>output</keyword>
    <keyword>formatting</keyword>
    <keyword>$SCR</keyword>
    <keyword>$IO</keyword>
    <keyword>$GRAB</keyword>
    <application/>
  </script>

  <script ID="445" category="Simple Problem" name="Output_Formatted03.inr" title="Writing Formatted Output #3">
    <description>
      This file shows how to grab console output
      and write the data to a file with formatting using $SCR.
    </description>
    <keyword>Macros_pre</keyword>
    <keyword>output</keyword>
    <keyword>formatting</keyword>
    <keyword>$SCR</keyword>
    <keyword>$IO</keyword>
    <keyword>$GRAB</keyword>
    <keyword>redirect</keyword>
    <keyword>append</keyword>
    <application/>
  </script>

  <script ID="446" category="Simple Problem" name="Output_Formatted04.inr" title="Writing EXTREMES POSITION Data to File">
    <description>
      Demonstration of grabbing console output of
      EXTREMES POSITION, slightly reformatting the data format,
    </description>
    <keyword>Macros_pre</keyword>
    <keyword>$SCR</keyword>
    <keyword>EXTREMES</keyword>
    <keyword>$GRAB</keyword>
    <keyword>$IO</keyword>
    <keyword>output</keyword>
    <keyword>formatting</keyword>
    <application/>
  </script>

  <script ID="447" category="Simple Problem" name="Output_Formatted05.inr" title="Writing Variable Filename with Date stamp">
    <description>
      This file shows how to enter an arbitrary filename to be
      used as an output file and put the current date in the title. It continues
      to append output data to a file with formatting using $SCR.
    </description>
    <keyword>Macros_pre</keyword>
    <keyword>output</keyword>
    <keyword>formatting</keyword>
    <keyword>$SCR</keyword>
    <keyword>$IO</keyword>
    <keyword>$GRAB</keyword>
    <keyword>literal</keyword>
    <keyword>append</keyword>
    <keyword>$FF</keyword>
    <application/>
  </script>

  <script ID="448" category="Simple Problem" name="Output_Log_File.inr" title="Writing Out Data to Log File">
    <description>
      A very convenient macro for writing a log file.
      It allows writing output in one command line.
    </description>
    <keyword>Macros_user</keyword>
    <keyword>output</keyword>
    <keyword>data</keyword>
    <keyword>file</keyword>
    <keyword>log</keyword>
    <application/>
  </script>

  <script ID="449" category="Simple Problem" name="Output_Plot_Data.inr" title="Writing Plot Data to a File">
    <description>
      Shows how to output data to a text file that would
      normally be plotted.
    </description>
    <keyword>Scripts</keyword>
    <keyword>$IO</keyword>
    <keyword>$PLOT</keyword>
    <keyword>RADIAL</keyword>
    <keyword>text</keyword>
    <keyword>output</keyword>
    <keyword>file</keyword>
    <keyword>data</keyword>
    <application/>
  </script>

  <script ID="450" category="Simple Problem" name="Output_Sci_Not.inr" title="Writing Data to File in Scientific Notation">
    <description>
      This example shows how to output numbers in scientific
      notation to a formatted data file using DISPLAY and TEXTFILE.
      A FIELD file created with variables in any format can be outputted
      in the same format using TEXTFILE.  A $GRAB could have been used
      to assign these variables.
    </description>
    <keyword>Analysis</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>output</keyword>
    <keyword>TEXTFILE</keyword>
    <keyword>scientific</keyword>
    <keyword>formatting</keyword>
    <keyword>file</keyword>
    <keyword>data</keyword>
    <application/>
  </script>

  <script ID="451" category="Isolated Command" name="oval01.inr" title="An Oval Edge">
    <description>
      A partial oval edge made
      with OVAL and displayed with PLOT EDGES.
    </description>
    <keyword>OVAL</keyword>
    <keyword>EDGES</keyword>
    <application/>
  </script>

  <script ID="452" category="Isolated Command" name="overlay01.inr" title="OVERLAY to Combine Plots">
    <description>
      Examples of using OVERLAY
      to combine plots into a single plot.
    </description>
    <keyword>OVERLAY</keyword>
    <keyword>plot</keyword>
    <application/>
  </script>

  <script ID="453" category="Isolated Command" name="overlay02.inr" title="OVERLAY for Quadrant Views">
    <description>Using OVERLAY for Quadrant views.</description>
    <keyword>OVERLAY</keyword>
    <keyword>plot</keyword>
    <application/>
  </script>

  <script ID="454" category="Simple Problem" name="Overlay03.inr" title="Overlaying DIRECTIONAL UNWRAP Plots">
    <description>
      How to overlay DIRECTIONAL UNWRAP plots using
      original display viewer.
    </description>
    <keyword>Analysis</keyword>
    <keyword>DIRECTIONAL</keyword>
    <keyword>$GUI</keyword>
    <keyword>OVERLAY</keyword>
    <keyword>plot</keyword>
    <keyword>PLOT</keyword>
    <application/>
  </script>

  <script ID="455" category="Simple Problem" name="Overlay04.inr" title="Quadrant Plot of Two Spatial Filters">
    <description>
      Multiple overlays performed to show two
      spatial filters in one plot. Taken from Aperture_Sampling02.inr.
    </description>
    <keyword>Analysis</keyword>
    <keyword>PLOT</keyword>
    <keyword>OVERLAY</keyword>
    <keyword>plot</keyword>
    <application/>
  </script>

  <script ID="456" category="Simple Problem" name="Parabolic_Strip.inr" title="Parabolic Strip by Swept Edge">
    <description>
      This shows how to make a parabolic surface section
      using POINTS with the 2 option to specify a parabolic curve with
      control point. SWEEP DIRECTION makes the strip surface.
    </description>
    <keyword>Geometry</keyword>
    <keyword>parabolic</keyword>
    <keyword>strip</keyword>
    <keyword>SWEEP</keyword>
    <keyword>EDGES</keyword>
    <keyword>POINTS</keyword>
    <keyword>ribbon</keyword>
    <application/>
  </script>

  <script ID="457" category="Isolated Command" name="paths01.inr" title="Stray Light Analysis with PATHS">
    <description>
      A simple example to show a typical use
      of the PATHS command for ghost image analysis.
      Several surfaces are set up to create multiple
      trace paths through splitting and scattering.
      Paths are listed after the trace using the PATHS
      command.
    </description>
    <keyword>PATHS</keyword>
    <keyword>Tracing</keyword>
    <keyword>ghost</keyword>
    <keyword>stray</keyword>
    <application/>
  </script>

  <script ID="458" category="Isolated Command" name="paths02.inr" title="Typical PATHS Output">
    <description>
      Typical output from the PATHS
      command for all currently defined rays. This
      output shows the default LONG form and listing
      according to total flux.
    </description>
    <keyword>PATHS</keyword>
    <keyword>Tracing</keyword>
    <keyword>stray</keyword>
    <keyword>ghost</keyword>
    <application/>
  </script>

  <script ID="459" category="Isolated Command" name="penta01.inr" title="Penta Prism Lens">
    <description>
      Defines a penta-angle prism
      whose first conicoid is located at z=0.
      The prism has an aperture semi-diameter of
      .5 and is composed of medium 1.  The prism
      is oriented so that a ray entering the prism
      along the z-axis leaves the prism propagating
      along the positive y-direction.
    </description>
    <keyword>PENTA</keyword>
    <keyword>LENSES</keyword>
    <application/>
  </script>

  <script ID="460" category="Simple Problem" name="Phase_Conjugate_01.inr" title="Creating a Phase Conjugate or Mask">
    <description>
      Make a source of specified Hermite-Gaussian wavefront.
      Capture the complex field of the wavefront.
      Extract the real and imaginary parts of the field.
      Composite these together into a file that can be read in to create
      a mask that represents the complex-conjugate condition.
      Create a new unit reference field.
      Impose the conjugate mask on the unit field to obtain the
      conjugate field.    THIS SCRIPT WAS CREATED IN RESPONSE TO SEVERAL ISSUES.
      It illustrates that we can create a complex field file from its
      real and imaginary parts individually, which facilitates common
      operations such as conjugation, phase mask construction, etc.
      Other uses are left as an exercise for the reader.
    </description>
    <keyword>Wave</keyword>
    <keyword>Gaussian</keyword>
    <keyword>phase</keyword>
    <keyword>complex</keyword>
    <keyword>conjugate</keyword>
    <keyword>mask</keyword>
    <application/>
  </script>

  <script ID="461" category="Simple Problem" name="Photometry.inr" title="'Radiometric Analysis' Appendix File">
    <description>
      This file is from the appendix of the
      Radiometric Analysis (BRO0909.pdf) Tech Guide.  It has
      not been altered from its original form, and may be used
    </description>
    <keyword>Radiometry</keyword>
    <keyword>cie</keyword>
    <keyword>blackbody</keyword>
    <keyword>THERMAL</keyword>
    <keyword>spectral</keyword>
    <keyword>photopic</keyword>
    <keyword>scotopic</keyword>
    <keyword>eye</keyword>
    <keyword>color</keyword>
    <application/>
  </script>

  <script ID="462" category="Simple Problem" name="Pinhole_Array.inr" title="Array of Pinholes">
    <description>
      This shows how to create a pinhole array in a panel
      by bounding a plane to an array of tubes.
    </description>
    <keyword>Arrays</keyword>
    <keyword>Bounds</keyword>
    <keyword>pinhole</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>ARRAY</keyword>
    <application/>
  </script>

  <script ID="463" category="Isolated Command" name="plane01.inr" title="Rectangular PLANE Surface">
    <description>
      Defines a plane normal to
      the z axis at z = 5. Requires the key word
      SURFACE precede the command.  Note also
      that this PLANE is not yet an OBJECT, i.e.,
      something that may be ray traced.
    </description>
    <keyword>PLANE</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="464" category="Isolated Command" name="plane02.inr" title="Elliptical PLANE Surface">
    <description>
      A plane surface using the
      ELLIPSE modifier to describe its boundary.
    </description>
    <keyword>PLANE</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="465" category="Isolated Command" name="plane03.inr" title="PLANE NORMAL Surface">
    <description>
      A plane surface using the
      NORMAL option. This example shows a plane
      that contains the point 0,0,0 and whose
      Normal vector is 0,1,1.  The LOCAL modifier
      is needed to define the boundaries of the
      surface. Note that ASAP will calculate the
      vector 0,1,1 as 45° from Z or Y.
    </description>
    <keyword>PLANE</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="466" category="Isolated Command" name="plane04.inr" title="PLANE POINTS Surface">
    <description>
      A plane surface described by
      three points on the surface. The Normal is
      determined by the right-hand rule.
    </description>
    <keyword>PLANE</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="467" category="Simple Problem" name="plane_wave.inr" title="Simple Truncated Plane Wave">
    <description>
      A simple truncated plane wave
      made with GRID.
    </description>
    <keyword>Wave</keyword>
    <keyword>beams</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="468" category="Isolated Command" name="plot01.inr" title="Plotting Beams">
    <description>
      Plotting Gaussian beams with
      an overlayed spot diagram.
    </description>
    <keyword>PLOT</keyword>
    <keyword>Wave</keyword>
    <application/>
  </script>

  <script ID="469" category="Isolated Command" name="plot02.inr" title="Plotting Edges and Facets">
    <description>Plotting Edges and Facets.</description>
    <keyword>PLOT</keyword>
    <keyword>Geometry</keyword>
    <application/>
  </script>

  <script ID="470" category="Isolated Command" name="plot03.inr" title="Plotting Lenses">
    <description>
      ASAP model of Petzval lens
      to demonstrate plotting.
    </description>
    <keyword>PLOT</keyword>
    <keyword>Lenses</keyword>
    <application/>
  </script>

  <script ID="471" category="Isolated Command" name="plot04.inr" title="Graphical Analysis of Polarization">
    <description>
      Plotting polarization using PLOT POLAR
      and PLOT RAYS.
    </description>
    <keyword>PLOT</keyword>
    <keyword>Polarization</keyword>
    <application/>
  </script>

  <script ID="472" category="Isolated Command" name="plot3d.inr" title="PLOT3D Display Command">
    <description>
      Create a 3-Dimensional plot of
      a SPOTS POSITION distribution file. Performed
      after a DISPLAY command. Does not modify
      display data. A Gaussian apodized grid is  plotted.
    </description>
    <keyword>PLOT3D</keyword>
    <keyword>DISPLAY</keyword>
    <application/>
  </script>

  <script ID="473" category="Simple Problem" name="Plotting_Mesh.inr" title="Mesh Plot Display of a Source">
    <description>
      This shows how to do a mesh plot of a source
      or set of rays. Two sources are created to emit in
      opposite directions. A radiant distribution is made which
      is averaged around the X-Y plane.  The mesh plot sends data
      to the vector file which can be displayed in the 3-D viewer
      or by using the DRAWING command.
    </description>
    <keyword>Radiometry</keyword>
    <keyword>MESH</keyword>
    <keyword>DIMENSIONS</keyword>
    <keyword>plot</keyword>
    <keyword>DRAWING</keyword>
    <application/>
  </script>

  <script ID="474" category="Simple Problem" name="PLOT_Saving1.inr" title="Saving MODEL...PLOT Data to File">
    <description>
      Demonstrates writing BSDF PLOT data to a file using $IO OUTPUT.
      Uses a VOLUME Media as an example. Writes plot data from display
      "slices" of a 3D display file containing the default incident angles.
    </description>
    <keyword>Scripts</keyword>
    <keyword>Scatter</keyword>
    <keyword>MODELS</keyword>
    <keyword>$IO</keyword>
    <keyword>VOLUME</keyword>
    <keyword>PLOT</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>text</keyword>
    <keyword>output</keyword>
    <keyword>file</keyword>
    <keyword>data</keyword>
    <application/>
  </script>

  <script ID="475" category="Simple Problem" name="PLOT_Saving2.inr" title="Saving MODEL...PLOT Data to File #2">
    <description>
      Demonstrates writing BSDF PLOT data to a file using $IO OUTPUT.
      Uses a VOLUME Media as an example. Writes plot data from separate
      display files at specific incident angles.
    </description>
    <keyword>Scripts</keyword>
    <keyword>Scatter</keyword>
    <keyword>MODELS</keyword>
    <keyword>$IO</keyword>
    <keyword>VOLUME</keyword>
    <keyword>PLOT</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>text</keyword>
    <keyword>output</keyword>
    <keyword>file</keyword>
    <keyword>data</keyword>
    <application/>
  </script>

  <script ID="476" category="Simple Problem" name="PLOT_Saving3.inr" title="Saving MODEL...PLOT Data to File #3">
    <description>
      Demonstrates writing BSDF PLOT data to a file.
      Uses a VOLUME Media as an example. Writes plot data from separate
      display files at specific incident angles.
    </description>
    <keyword>Scripts</keyword>
    <keyword>Scatter</keyword>
    <keyword>MODELS</keyword>
    <keyword>WRITE</keyword>
    <keyword>VOLUME</keyword>
    <keyword>PLOT</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>text</keyword>
    <keyword>output</keyword>
    <keyword>file</keyword>
    <keyword>data</keyword>
    <application/>
  </script>

  <script ID="477" category="Simple Problem" name="PLOT_Saving4.inr" title="Saving MODEL...PLOT Data to File #4 - with Loop">
    <description>
      Demonstrates writing BSDF PLOT data to a file.
      Uses a VOLUME Media as an example. Writes plot data from display
      "slices" of a 3D display file containing the default incident angles.
      Uses $DO loop to save all files.
    </description>
    <keyword>Scripts</keyword>
    <keyword>Scatter</keyword>
    <keyword>MODELS</keyword>
    <keyword>WRITE</keyword>
    <keyword>$DO</keyword>
    <keyword>VOLUME</keyword>
    <keyword>PLOT</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>text</keyword>
    <keyword>output</keyword>
    <keyword>file</keyword>
    <keyword>data</keyword>
    <keyword>LIT</keyword>
    <application/>
  </script>

  <script ID="478" category="Simple Problem" name="plot_text01.inr" title="Annotating Plots with Text">
    <description>
      How to add labels to a plot using
      the TEXT option of the PLOT command.
    </description>
    <keyword>Analysis</keyword>
    <keyword>PLOT</keyword>
    <keyword>TEXT</keyword>
    <keyword>annotation</keyword>
    <keyword>label</keyword>
    <application/>
  </script>

  <script ID="479" category="Simple Problem" name="plot_text02.inr" title="Color Chart with Labels">
    <description>
      ASAP color chart with labeling
      using the TEXT option on the PLOT command.
      ASAP assigns the colors automatically in this  sequence.
      Handy reference for seeing printed
      color results.
    </description>
    <keyword>Analysis</keyword>
    <keyword>PLOT</keyword>
    <keyword>TEXT</keyword>
    <keyword>color chart</keyword>
    <application/>
  </script>

  <script ID="480" category="Simple Problem" name="Plot_Text03.inr" title="Passing Variables to Plot Labels">
    <description>
      Labeling a plot using numbers or strings
      contained in variables. The PLOT command is contained
      within a macro to allow passing of variables into plot
      labels using the TEXT option. Numeric data is passed using
      the LIT operator and strings are passed by using one double
      quote on the right side.  Be sure to set the coordinate
      position (spacing) of labels to allow for length of variables.
    </description>
    <keyword>Scripts</keyword>
    <keyword>plot</keyword>
    <keyword>TEXT</keyword>
    <keyword>variables</keyword>
    <keyword>literal</keyword>
    <keyword>macro</keyword>
    <keyword>string</keyword>
    <application/>
  </script>

  <script ID="481" category="Isolated Command" name="points01.inr" title="POINTS and Weighting">
    <description>
      Shows the effect of varying
      weighting factors and control vertices.
    </description>
    <keyword>POINTS</keyword>
    <keyword>EDGES</keyword>
    <application/>
  </script>

  <script ID="482" category="Isolated Command" name="POINTS_Arc.inr" title="POINTS Curve using Arc Parameter">
    <description>This creates a simple curve using the  "-2" connection parameter. The Radius and Angle may  be changed to see how the "parent ellipse" point with  angular subtense works.</description>
    <keyword>Edges</keyword>
    <keyword>EDGES</keyword>
    <keyword>POINTS</keyword>
    <application/>
  </script>

  <script ID="483" category="Simple Problem" name="Point_Source_Towards_Aperture_01.inr" title="Simple Problem">
    <description>Example of a point source entering an aperture.</description>
    <keyword>Sources</keyword>
    <keyword>Point Source</keyword>
    <keyword>aperture</keyword>
    <keyword>TOWARDS</keyword>
    <keyword>Scatter</keyword>
    <application/>
  </script>

  <script ID="484" category="Isolated Command" name="polariz01.inr" title="Linear Vertical Polarization">
    <description>
      Setting up the POLARIZ command
      for a linear, vertically polarized source.
    </description>
    <keyword>POLARIZ</keyword>
    <keyword>Polarization</keyword>
    <application/>
  </script>

  <script ID="485" category="Simple Problem" name="polarized_field.inr" title="Irradiance of Polarized Field">
    <description>
      Irradiance of a polarized field.
      Demonstrates that orthogonally polarized fields
      sum in quadrature.
    </description>
    <keyword>Wave</keyword>
    <keyword>POLARIZ</keyword>
    <keyword>FIELD ENERGY</keyword>
    <keyword>FIELD</keyword>
    <keyword>irradiance</keyword>
    <application/>
  </script>

  <script ID="486" category="Simple Problem" name="polariz_crystal.inr" title="Analyzing Crystal Polarizers">
    <description>
      Using PLOT POLAR and LIST ELLIPSE to
      analyze a crystal-type polarizer. A CRYSTAL media
      generates two rays, ordinary and extraordinary.
    </description>
    <keyword>Polarization</keyword>
    <keyword>PLOT</keyword>
    <keyword>CRYSTAL</keyword>
    <keyword>LIST ELLIPSE</keyword>
    <keyword>POLARIZ</keyword>
    <application/>
  </script>

  <script ID="487" category="Simple Problem" name="polariz_list.inr" title="Numerical Analysis of Polarization">
    <description>
      Using LIST ELLIPSE for numerical
      analysis of polarization.
    </description>
    <keyword>Polarization</keyword>
    <keyword>PLOT</keyword>
    <keyword>POLARIZ</keyword>
    <keyword>POLAR</keyword>
    <keyword>LIST ELLIPSE</keyword>
    <application/>
  </script>

  <script ID="488" category="Isolated Command" name="POLARIZ_RANDOM_EMITTING_02.inr" title="Randomizing Polarization of Various Emitters">
    <description>
      A set of all 14 EMITTING sources are created and displayed
      after setting a random polarization using the UNIFORM option.
      The user can choose which source to show the ray directions and
      polarization ellipses in the 3D viewer.
    </description>
    <keyword>POLARIZ RANDOM</keyword>
    <keyword>EMITTING</keyword>
    <keyword>Polarization</keyword>
    <keyword>SELECT</keyword>
    <application/>
  </script>

  <script ID="489" category="Simple Problem" name="polar_lin_circular.inr" title="Linear to Circular Polarization">
    <description>
      Linear polarized rays converted to circular
      polarization by an ideal lens. A grid of rays, initially
      linear polarized at 45° are passed through an ideal lens
      set up to be a quarter wave plate (using Jones Matrix -
      fast axis vertical). The result is right-circular
      polarization.
    </description>
    <keyword>Polarization</keyword>
    <keyword>LENSES</keyword>
    <keyword>IDEAL</keyword>
    <keyword>POLARIZ</keyword>
    <keyword>POLAR</keyword>
    <keyword>FIELD</keyword>
    <keyword>REAL</keyword>
    <keyword>quarter</keyword>
    <application/>
  </script>

  <script ID="490" category="Simple Problem" name="polar_qtr_wave.inr" title="Quarter Wave Plate using CRYSTAL">
    <description>
      An example of birefringence through a crystal
      media. Shows how polarized light changes after propagating
      through a quarter wave plate made of Crystal media.
      PLOT POLARIZATION plots the two orthogonal linear polarization
      components. The FIELD commands allows study of the combined
      effects of the two rays.
    </description>
    <keyword>Polarization</keyword>
    <keyword>CRYSTAL</keyword>
    <keyword>quarter</keyword>
    <keyword>waveplate</keyword>
    <keyword>POLARIZ</keyword>
    <keyword>FIELD</keyword>
    <keyword>REAL</keyword>
    <keyword>DELTA</keyword>
    <application/>
  </script>

  <script ID="491" category="Simple Problem" name="Polar_Random_Emitter01.inr" title="Controlling Polarization of Emitters">
    <description>
      Control polarization of emitters using
      POLARIZ RANDOM, and show the polarization in the 3D Viewer.
    </description>
    <keyword>Polarization</keyword>
    <keyword>POLARIZ RANDOM</keyword>
    <keyword>POLARIZ K</keyword>
    <keyword>POLARIZ TREF</keyword>
    <application/>
  </script>

  <script ID="492" category="Simple Problem" name="polar_rhomb.inr" title="Fresnel Rhomb Converter">
    <description>
      The Fresnel rhomb is a simple optical
      device for converting linearly polarized light to
      circularly polarized light by way of total internal
    </description>
    <keyword>Polarization</keyword>
    <keyword>Fresnel</keyword>
    <keyword>rhomb</keyword>
    <keyword>POLARIZ</keyword>
    <keyword>POLAR</keyword>
    <keyword>ARROWS</keyword>
    <keyword>SEGMENTS</keyword>
    <application/>
  </script>

  <script ID="493" category="Simple Problem" name="polar_sapphire_dome.inr" title="Polarization of a Saphire Dome">
    <description>
      An example of birefringence.  How polarized light
      changes after propagating through a saphire dome.  By specifying
      a CRYSTAL media with SPLIT set to 1, two independent rays are
      created from one input ray - the ordinary and extraordinary rays.
      PLOT POLARIZATION plots the two orthogonal linear polarization
      components.  The FIELD commands allows study of the combined
      effects of the two rays.
    </description>
    <keyword>Polarization</keyword>
    <keyword>CRYSTAL</keyword>
    <keyword>saphire</keyword>
    <keyword>birefringence</keyword>
    <keyword>POLARIZ</keyword>
    <keyword>FIELD</keyword>
    <keyword>REAL</keyword>
    <keyword>DELTA</keyword>
    <application/>
  </script>

  <script ID="494" category="Isolated Command" name="polynomial_fit.inr" title="Polynomial Fit Model">
    <description>
      Polynomial fit model of Chemglaze
      306 data.
    </description>
    <keyword>POLYNOMIAL</keyword>
    <keyword>FIT</keyword>
    <keyword>MODELS</keyword>
    <application/>
  </script>

  <script ID="495" category="Isolated Command" name="polynomial_fit02.inr" title="Polynomial Model Using Coefficients">
    <description>
      Polynomial model of Chemglaze
      306M.  The coefficients used are a direct copy
      from a PRINT MODELS done on the POLYNOMIAL_FIT.INR.
      Note - commas must be added to continue lines.
    </description>
    <keyword>POLYNOMIAL</keyword>
    <keyword>FIT</keyword>
    <keyword>MODELS</keyword>
    <application/>
  </script>

  <script ID="496" category="Isolated Command" name="print01.inr" title="Printing System Media">
    <description>
      Example output of PRINT MEDIA
      for birefringent materials.
    </description>
    <keyword>PRINT</keyword>
    <keyword>MEDIA</keyword>
    <application/>
  </script>

  <script ID="497" category="Simple Problem" name="PRISM_ARRAY_BOUNDED_ROOFS.INR" title="Slanted Prism Array by Mutually Bounding TUBEs">
    <description>
      An ARRAY of prisms created by using ROOF
      to form the main prism face, mutually bounded with a
      TUBE to form the sides and prism "heel".
      It traceS like a real surface, and a few periods are
      traced to show it works.
    </description>
    <keyword>Arrays</keyword>
    <keyword>ROOF</keyword>
    <keyword>ARRAY</keyword>
    <keyword>prism</keyword>
    <keyword>BOUNDS</keyword>
    <application/>
  </script>

  <script ID="498" category="Isolated Command" name="profiles01.inr" title="Plotting Profiles">
    <description>
      Several examples of plotting
      with PROFILES is shown. PROFILES is dependent
      on previous WINDOW and PIXELS settings. The last
      example uses OBLIQUE setting.
    </description>
    <keyword>PROFILES</keyword>
    <keyword>WINDOW</keyword>
    <keyword>OBLIQUE</keyword>
    <application/>
  </script>

  <script ID="499" category="Simple Problem" name="PSF_Poly_Doublet01.inr" title="Polychromatic PSF of Discrete Lens">
    <description>
      The following produces a Point Spread Function of
      an achromatic doublet made with discrete optical surfaces.
      Three wavelengths are summed incoherently at the target and
      plotted.
    </description>
    <keyword>Wave</keyword>
    <keyword>SPREAD</keyword>
    <keyword>psf</keyword>
    <keyword>OPTICAL</keyword>
    <keyword>doublet</keyword>
    <keyword>lens</keyword>
    <application/>
  </script>

  <script ID="500" category="Simple Problem" name="PSF_Poly_Doublet02.inr" title="Polychromatic PSF of Lens Sequence">
    <description>
      The following produces a Point Spread Function of
      an achromatic doublet made with LENSES SEQUENCE command.
      Energy contributions from three wavelengths are incoherently
      summed at the target and plotted.
    </description>
    <keyword>Wave</keyword>
    <keyword>SPREAD</keyword>
    <keyword>psf</keyword>
    <keyword>SEQUENCE</keyword>
    <keyword>doublet</keyword>
    <keyword>Lenses</keyword>
    <application/>
  </script>

  <script ID="501" category="Isolated Command" name="psf_poly_doublet03.inr" title="PSF and MTF of Doublet">
    <description>
      Polychromatic PSF and MTF of a
      doublet lens.
    </description>
    <keyword>Wave</keyword>
    <keyword>SPREAD</keyword>
    <keyword>psf</keyword>
    <keyword>mtf</keyword>
    <keyword>SEQUENCE</keyword>
    <keyword>doublet</keyword>
    <keyword>lens</keyword>
    <keyword>FFT</keyword>
    <keyword>NORMALIZE</keyword>
    <application/>
  </script>

  <script ID="502" category="Isolated Command" name="ptf_poly_doublet.inr" title="Polychromatic PTF of Doublet">
    <description>Polychromatic PTF of a doublet lens.</description>
    <keyword>Wave</keyword>
    <keyword>SPREAD</keyword>
    <keyword>ptf</keyword>
    <keyword>mtf</keyword>
    <keyword>SEQUENCE</keyword>
    <keyword>doublet</keyword>
    <keyword>lens</keyword>
    <application/>
  </script>

  <script ID="503" category="Isolated Command" name="put01.inr" title="PUTing Ray Data">
    <description>
      Transfers the current variable
      data to ray number 15 in the ray table.
      In this case ray 15 will be turned off
      because its FLUX will be set to zero.
    </description>
    <keyword>PUT</keyword>
    <keyword>rays</keyword>
    <application/>
  </script>

  <script ID="504" category="Isolated Command" name="racetrack01.inr" title="A Racetrack Edge">
    <description>
      A full racetrack edge shown
      with PLOT EDGES.
    </description>
    <keyword>RACETRACK</keyword>
    <keyword>EDGES</keyword>
    <application/>
  </script>

  <script ID="505" category="Simple Problem" name="Radial_Angles_Enclosed01.inr" title="Enclosed Energy vs. Angle #1">
    <description>
      This shows a simple example of how to graph enclosed
      energy vs. angle out to 90 degrees using the $ITER command.
      It does not have the problem of spilling over 90 degrees when
      radially averaging over a rectangular map of angles - as when
      performing a RADIAL BOTH after converting dir-cosine data to
      angles.
    </description>
    <keyword>Radiometry</keyword>
    <keyword>enclosed</keyword>
    <keyword>energy</keyword>
    <keyword>$ITER</keyword>
    <keyword>ANGLES</keyword>
    <keyword>radial</keyword>
    <application/>
  </script>

  <script ID="506" category="Simple Problem" name="Radial_Angles_Enclosed02.inr" title="Enclosed Energy vs. Angle #2">
    <description>
      This is a more advanced example of how to graph
      enclosed energy vs. angle out to 90 degrees using the $ITER
      command. It does not have the problem of spilling over 90
      degrees when radially averaging over a rectangular map of angles,
      as when performing a RADIAL BOTH after converting dir-cosine
      data to angles. This file compares both methods.
    </description>
    <keyword>Radiometry</keyword>
    <keyword>enclosed</keyword>
    <keyword>energy</keyword>
    <keyword>$ITER</keyword>
    <keyword>ANGLES</keyword>
    <keyword>radial</keyword>
    <keyword>$DO</keyword>
    <application/>
  </script>

  <script ID="507" category="Isolated Command" name="radiant01.inr" title="Radiance of Emitting Spheroid">
    <description>
      Simple use of the RADIANT
      command. MESH allows viewing results
      in 3-D viewer.
    </description>
    <keyword>RADIANT</keyword>
    <keyword>Radiometry</keyword>
    <keyword>radiance</keyword>
    <application/>
  </script>

  <script ID="508" category="Isolated Command" name="radiant_area01.inr" title="Radiance of Multiple Emitting Spheroids">
    <description>
      Plotting RADIANT AREA on multiple emitting
      spheroids of varying sizes. This is radiance per unit
      area in the plane of the selected window.
    </description>
    <keyword>RADIANT</keyword>
    <keyword>AREA</keyword>
    <keyword>Radiometry</keyword>
    <keyword>SPHEROID</keyword>
    <keyword>radiance</keyword>
    <application/>
  </script>

  <script ID="509" category="Simple Problem" name="Radiant_Area_Anal.inr" title="Using SELECT ONLY to simulate RADIANT AREA">
    <description>
      Performs a similar function to a Radiant
      Area, using SELECT ONLY to look at directional info over a
      specified area of a detector surface. Similar results could
      obtained using the WINDOW command rather than SELECT ONLY.
    </description>
    <keyword>Radiometry</keyword>
    <keyword>RADIANT</keyword>
    <keyword>AREA</keyword>
    <keyword>SELECT</keyword>
    <keyword>TRANSPOSE</keyword>
    <application/>
  </script>

  <script ID="510" category="Isolated Command" name="radiant_map01.inr" title="Radiance Map">
    <description>
      An example of a radiance map using an
      emitting surface.
    </description>
    <keyword>RADIANT</keyword>
    <keyword>Radiometry</keyword>
    <keyword>radiance</keyword>
    <keyword>EMITTING</keyword>
    <application/>
  </script>

  <script ID="511" category="Isolated Command" name="radiant_map02.inr" title="Radiance Calculation">
    <description>
      Radiance calculation using the
      RADIANT command.
    </description>
    <keyword>RADIANT</keyword>
    <keyword>Radiometry</keyword>
    <keyword>radiance</keyword>
    <application/>
  </script>

  <script ID="512" category="Isolated Command" name="randomizer01.inr" title="Random Number Generator">
    <description>
      Creates a set of variables with random
      numbers assigned. Note that INT is used when generating
      a random number with the tilde operator, since it is
      normally floating-point.
    </description>
    <keyword>Macros_user</keyword>
    <keyword>macro</keyword>
    <keyword>random</keyword>
    <application/>
  </script>

  <script ID="513" category="Simple Problem" name="Random_Number01.inr" title="Random Number Generator">
    <description>
      The following generates a random
      number sequence from 1 through 100. Output is
      a random floating point number.
    </description>
    <keyword>Scripts</keyword>
    <keyword>math</keyword>
    <keyword>random</keyword>
    <application/>
  </script>

  <script ID="514" category="Simple Problem" name="Random_Number02.inr" title="Random Emitting Disks">
    <description>
      The following generates a random set
      of emitting disks using the the random number generator
      within the SHIFT command. This is the tilde (~)
      operator. The X position is random between -1 and 1.
    </description>
    <keyword>Scripts</keyword>
    <keyword>math</keyword>
    <keyword>random</keyword>
    <keyword>$DO</keyword>
    <keyword>EMITTING</keyword>
    <application/>
  </script>

  <script ID="515" category="Simple Problem" name="Random_Number03.inr" title="Random Number and Seed Generator">
    <description>
      Example of various probability distributions
      using a random seed sequence. The RAN operator generates a
      new random number within a distribution determined by the
      value in TYPE, below. The $RAN function generates a new
      random seed sequence for each run. Use the HISTOGRAM plot
      to observe changes with different values. The actual probability
      distribution output is a random floating point number.
    </description>
    <keyword>Scripts</keyword>
    <keyword>math</keyword>
    <keyword>random</keyword>
    <keyword>RAN</keyword>
    <keyword>$RAN</keyword>
    <keyword>HISTOGRAM</keyword>
    <application/>
  </script>

  <script ID="516" category="Simple Problem" name="Random_Number04.inr" title="Automated Random Number Distributions">
    <description>
      Probability distributions automated over the full range
      of types, using a random seed sequence. The RAN operator generates a
      new random number within a distribution determined by the
      value for the distribution "type." The $RAN function generates a new
      random seed sequence for each run. The HISTOGRAM plots show the
      changes using the different values. The actual probability
      distribution output is in random floating point numbers.
    </description>
    <keyword>Scripts</keyword>
    <keyword>math</keyword>
    <keyword>random</keyword>
    <keyword>RAN</keyword>
    <keyword>$RAN</keyword>
    <keyword>HISTOGRAM</keyword>
    <keyword>$ITER</keyword>
    <keyword>$DO</keyword>
    <application/>
  </script>

  <script ID="517" category="Simple Problem" name="Random_Number05.inr" title="Random Number after Kernel Restart">
    <description>
      The following shows how to get a different
      sequence (or starting seed) for random number generation
      after each Kernel restart (or program start).
    </description>
    <keyword>Scripts</keyword>
    <keyword>random</keyword>
    <keyword>RAN</keyword>
    <keyword>$RAN</keyword>
    <keyword>$TIC</keyword>
    <keyword>math</keyword>
    <application/>
  </script>

  <script ID="518" category="Isolated Command" name="ray01.inr" title="RAY Command Text Options">
    <description>
      Two variations of RAY command
      output.
    </description>
    <keyword>RAY</keyword>
    <keyword>Tracing</keyword>
    <application/>
  </script>

  <script ID="519" category="Isolated Command" name="rayset01.inr" title="RAYSET Command">
    <description>
      RAYSET command example.
      Note that this command only defines
      the spatial properties of the rayset
      and not the angular properties, i.e.,
      propagation direction.
    </description>
    <keyword>RAYSET</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="520" category="Isolated Command" name="rayset02.inr" title="Letter 'R' With RAYSET">
    <description>
      Generating a rayset by position
      in the shape of the letter 'R'.
    </description>
    <keyword>RAYSET</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="521" category="Isolated Command" name="RAYSET_NOSPLIT.inr" title="A RAYSET Source with Splitting Control">
    <description>
      How to make a simple source with a few
      listed rays and control the splitting.
      Must use  NOSPLIT on any rays not intended to split.
      A SPLIT 0  will have no affect on RAYSET.  Also, NOSPLIT can only
      be entered after the appropriate number of parameters
      for each ray, even if they are only default.
    </description>
    <keyword>RAYSET</keyword>
    <keyword>Sources</keyword>
    <keyword>Tracing</keyword>
    <keyword>RAYSET</keyword>
    <keyword>NOSPLIT</keyword>
    <keyword>splitting</keyword>
    <application/>
  </script>

  <script ID="522" category="Simple Problem" name="RAYS_SYSTEM_RECOVER.inr" title="Rotating Ray Data">
    <description>
      This demonstration creates a simple geometry and rayset,
      traces rays, deletes the geometry and rays, then reloads
      the geometry and rays. The appropriate associations
      between objects and rays are restored by this process.
    </description>
    <keyword>Tracing</keyword>
    <keyword>rays</keyword>
    <keyword>RAYS</keyword>
    <keyword>SYSTEM</keyword>
    <keyword>XMEMORY</keyword>
    <application/>
  </script>

  <script ID="523" category="Simple Problem" name="Raytrace_Interactive.inr" title="Projection Lens using Bounding Surfaces">
    <description>
      The lens design imported using ZEMAX (a trademark
      of Focus Software) is now supplemented with outer edges
      and annular front or rear surfaces to illustrate use
      of the BOUNDS command. The object names have also
      been changed at this time to better reflect their
      function in the system. This will be useful later
      when various reports name the surfaces involved in
      stray-light analysis.
      The projector lens is very nearly telecentric to minimize
      vignetting when projecting the image from the LCD. The
      chief ray is approximately 3° from the normal at the edge
      of the LCD. Distortion is below 1.6%. The probable use
      for a lens like this is for a fixed focus rear projection
      LCD system with multiple fold mirrors. All spherical glass
      elements are used in this prototype system. Production
      systems might use aspheres and some plastic elements. A
      Zoom system would be desirable for front projection.
      A profile of the lenses will be plotted and then single
      ray tracing will be enabled via the mouse. First mark the
      start of the ray with the left mouse button. Mark the end
      point to indicate direction and initiate trace. The right  mouse button ends the session.
    </description>
    <keyword>Tracing</keyword>
    <keyword>Geometry</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>RAY</keyword>
    <keyword>interactive</keyword>
    <keyword>projector</keyword>
    <keyword>lens</keyword>
    <keyword>raytrace</keyword>
    <application/>
  </script>

  <script ID="524" category="Simple Problem" name="ray_fan.inr" title="Making a Ray Fan">
    <description>
      Plotting rays from the source position
      point. Useful to create a ray fan for display
      purposes. A grid is created using SOURCE POSITION
      to specify the ray directions (using a virtual
      origin). Normally, tracing will occur starting
      from the grid. In order to actually trace the
      rays from the "virtual origin" and see them in a
      PLOT, the MOVE command must be used.
    </description>
    <keyword>Manipulating</keyword>
    <keyword>rays</keyword>
    <keyword>MOVE</keyword>
    <keyword>fan</keyword>
    <application/>
  </script>

  <script ID="525" category="Simple Problem" name="ray_splitting01.inr" title="Tracing with SPLIT 1">
    <description>
      Ray trace plot showing effects of
      SPLIT set to 1. Only first generation child rays
      are allowed and only the parent can split. The most
      energetic child ray continues but cannot split.
    </description>
    <keyword>Tracing</keyword>
    <keyword>SPLIT</keyword>
    <keyword>child</keyword>
    <keyword>parent</keyword>
    <keyword>rays</keyword>
    <keyword>splitting</keyword>
    <keyword>EMITTING</keyword>
    <application/>
  </script>

  <script ID="526" category="Simple Problem" name="ray_splitting02.inr" title="Tracing with SPLIT 3">
    <description>
      Ray trace plot showing effects of
      SPLIT set to 3. First and second generation child rays
      are allowed to split but third generation cannot split.
      Only the most energetic great-grand-child ray continues.
    </description>
    <keyword>Tracing</keyword>
    <keyword>SPLIT</keyword>
    <keyword>child</keyword>
    <keyword>parent</keyword>
    <keyword>rays</keyword>
    <keyword>splitting</keyword>
    <keyword>EMITTING</keyword>
    <application/>
  </script>

  <script ID="527" category="Simple Problem" name="ray_splitting03.inr" title="Cube Beamsplitter">
    <description>
      ASAP model of beamsplitter
      to demo ray splitting.
    </description>
    <keyword>Tracing</keyword>
    <keyword>rays</keyword>
    <keyword>splitting</keyword>
    <application/>
  </script>

  <script ID="528" category="Isolated Command" name="rectangle01.inr" title="A Rectangle Edge">
    <description>
      A simple rectangle edge
      shown with PLOT EDGES.
    </description>
    <keyword>RECTANGLE</keyword>
    <keyword>EDGES</keyword>
    <application/>
  </script>

  <script ID="529" category="Isolated Command" name="redefine01.inr" title="Output From REDEFINE SURFACE">
    <description>
      Output from REDEFINE SURFACE
      command. A hexagonal edge was redefined to an
      alternate optical surface to make a hexagonal
      mirror. This is not a runable script file.
    </description>
    <keyword>REDEFINE</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="530" category="Isolated Command" name="REDUCE01.inr" title="REDUCE Command">
    <description>
      Using REDUCE to modify a
      display file.
    </description>
    <keyword>REDUCE</keyword>
    <keyword>DISPLAY</keyword>
    <application/>
  </script>

  <script ID="531" category="Isolated Command" name="REDUCE02.inr" title="REDUCE Display Command #2">
    <description>
      Using REDUCE to modify a
      display file.
    </description>
    <keyword>REDUCE</keyword>
    <keyword>DISPLAY</keyword>
    <application/>
  </script>

  <script ID="532" category="Simple Problem" name="ReflectanceCard01.inr" title="Measuring Kodak(tm) Reflectance Cards">
    <description>
      Measuring an 18% or 90% Kodak reflectance card.
      A light source is aimed at the Lambertian reflector card.
      Reflected scattered rays are collected by an outer hemisphere.
      Total flux on the hemisphere is equal to the reflectance card setting.
    </description>
    <keyword>Analysis</keyword>
    <keyword>reflectance</keyword>
    <keyword>card</keyword>
    <keyword>Kodak</keyword>
    <keyword>Lambertian</keyword>
    <keyword>Scatter</keyword>
    <keyword>MODELS</keyword>
    <application/>
  </script>

  <script ID="533" category="Simple Problem" name="Remote_BMP_Through_Cooke_Triplet.inr" title="Using Remote for a Three Color Trace">
    <description>
      This INR file takes a bmp file as an input to an
      optical system, splits the different colored components into
      their own channels, images each channel through a cooke triplet
      onto the detector plane, recombines all the channels, and makes
      a bmp of the output image.
      It is written such that each color channel is traced on a remote
      computer. The file is based on the BMPSourceTrace Project inr.
      For best results, 5 to 10 million rays should be traced.
    </description>
    <keyword>Tracing</keyword>
    <keyword>Remote</keyword>
    <keyword>$GUI</keyword>
    <keyword>$SCR</keyword>
    <keyword>BMP2DIS</keyword>
    <keyword>color</keyword>
    <keyword>Cooke</keyword>
    <keyword>triplet</keyword>
    <application/>
  </script>

  <script ID="534" category="Simple Problem" name="Remote_Distributed_Trace.inr" title="Using Remote to Trace Across 3 Computers">
    <description>
      This INR file shows how to set up a trace
      across three Remote machines using a different starting
      SEED value.  This produces three random traces of the same
      optical system occuring at the same time and thereby
      reducing the total raytrace time by one third. The sources
      for each are set to 1/3 of the combined total.
      The SPOTS results are transfered back to the local machine
      where they are COMBINEd into one display file for analysis.
      In this case, an Integrating Sphere model was chosen
      since this generally requires many rays to trace properly.
      Be sure to follow all DCOM and firewall procedures for each
      computer as outlined in the "Configuration of Windows XP
      with SP2 for ASAP Remote" found at our Knowledge base.
      A dialog will ask for various parameters including the names
      of three computers, number of rays and total flux desired.
    </description>
    <keyword>Tracing</keyword>
    <keyword>Remote</keyword>
    <keyword>$GUI</keyword>
    <keyword>$SCR</keyword>
    <keyword>Tracing</keyword>
    <keyword>SEED</keyword>
    <application/>
  </script>

  <script ID="535" category="Simple Problem" name="Remote_Distributed_Trace_Dual_Core.inr" title="Using Remote to Split a Trace Across 2 Cores">
    <description>
      This INR file shows how to set up a trace
      across two Remote cores on same machine using a different starting
      SEED value for each.  This produces two random traces of the same
      optical system occuring at the same time and thereby
      reducing the total raytrace time by one half. The rays
      for each are set to 1/2 of the combined total given at the start.
      The SPOTS results may either be transfered back to the local machine
      automatically and COMBINEd into one display file for analysis,
      or you can choose to do this manually using the remote toolbar buttons.
      For this test case, an Integrating Sphere model was chosen
      since this generally requires many rays to trace properly.
      Be sure to follow all DCOM and firewall procedures for each
      computer as outlined in the "Configuration of Windows XP
      with SP2 for ASAP Remote" found at our Knowledge base.
      A dialog will ask for various parameters including the name
      of the computer (can be your own machine if desired),
      total number of rays and total flux.
    </description>
    <keyword>Tracing</keyword>
    <keyword>Remote</keyword>
    <keyword>$GUI</keyword>
    <keyword>$SCR</keyword>
    <keyword>Tracing</keyword>
    <keyword>SEED</keyword>
    <application/>
  </script>

  <script ID="536" category="Simple Problem" name="Remote_Distributed_Trace_Plus_Local.inr" title="Using Remote to Trace on 4 Computers">
    <description>
      This example is based on the Remote_Distributed_Trace.inr
      which runs a trace on 3 remote machines, but adds a fourth run  on the local machine.
      It shows how to set up a trace  across all four machines using a different starting
      SEED value.  This produces four random traces of the same  optical system occuring at
      the same time and thereby  reducing the total raytrace time by one fourth. The sources
      for each are set to 1/4 of the combined total because they will  be summed up at the end.
      The SPOTS results from the 3 Remotes  are transfered back to the local machine where they are COMBINEd
      and finally added to the local trace results.
      An Integrating Sphere model was chosen since this generally
      requires many rays to trace properly.  Be sure to follow all
      DCOM and firewall procedures for each computer as outlined in the
      "Configuration of Windows XP with SP2 for ASAP Remote"  found at our Knowledge base.
      A dialog will ask for the names of the 3 Remote computers,
      number of rays and total flux desired.
    </description>
    <keyword>Tracing</keyword>
    <keyword>Remote</keyword>
    <keyword>$GUI</keyword>
    <keyword>$SCR</keyword>
    <keyword>Tracing</keyword>
    <keyword>SEED</keyword>
    <application/>
  </script>

  <script ID="537" category="Isolated Command" name="REMOVE.inr" title="REMOVE Command">
    <description>
      A short example of how the REMOVE command subtracts
      out a 1D polynomial of order k from the data in a display file.
      It could also be used in the other dimension after a TRANSPOSE
      but will not honor any cross terms, i.e., surface function terms
      involving products of x &amp; y. This command does not apply to tilt
      or focus.
    </description>
    <keyword>REMOVE</keyword>
    <keyword>SURFACE</keyword>
    <keyword>OPTICAL</keyword>
    <keyword>polynomial</keyword>
    <application/>
  </script>

  <script ID="538" category="Isolated Command" name="render01.inr" title="Rendering Objects">
    <description>
      Example of rendering a group
      of lenses. The resolution of RENDER is
      determined by the PIXELS command.
    </description>
    <keyword>RENDER</keyword>
    <keyword>Lenses</keyword>
    <application/>
  </script>

  <script ID="539" category="Isolated Command" name="repeat01.inr" title="REPEAT for Entities">
    <description>
      Using REPEAT to duplicate
      previously defined entities. Note that any
      transformations made to those entities
      will also be included.
    </description>
    <keyword>REPEAT</keyword>
    <keyword>Geometry</keyword>
    <application/>
  </script>

  <script ID="540" category="Isolated Command" name="REPEAT02.inr" title="REPEAT for Surfaces">
    <description>
      REPEAT the first element of Cooke Triplet,
      shifted by 30 in the Z-direction.
    </description>
    <keyword>REPEAT</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="541" category="Isolated Command" name="REPLICATE01.inr" title="Use of the REPLICATE command">
    <description>REPLICATE command with first element of Cooke Triplet.</description>
    <keyword>REPLICATE</keyword>
    <keyword>DISPLAY</keyword>
    <application/>
  </script>

  <script ID="542" category="Isolated Command" name="replot01.inr" title="REPLOT of MESH">
    <description>
      Using REPLOT to display MESH
      of a radiance distribution.
    </description>
    <keyword>REPLOT</keyword>
    <keyword>MESH</keyword>
    <application/>
  </script>

  <script ID="543" category="Isolated Command" name="replot02.inr" title="REPLOT of a GRIN trace">
    <description>
      Using the REPLOT command on
      a trace of a 2 period pitch GRIN rod.
    </description>
    <keyword>REPLOT</keyword>
    <keyword>MESH</keyword>
    <application/>
  </script>

  <script ID="544" category="Isolated Command" name="revolution02.inr" title="REVOLUTION with DECENTER">
    <description>Defines an OBJECT whose radial</description>
    <keyword>REVOLUTION</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="545" category="Simple Problem" name="Rhomboid.inr" title="Rhomboid Made with Edges">
    <description>
      Making a rhomboid with EDGE
      rectangles and the second  form of the OBJECT command.
      The exit face and the entrance face are
      extruded to make the outer wall or tube portion of the rhomboid.
    </description>
    <keyword>Geometry</keyword>
    <keyword>extrude</keyword>
    <keyword>OBJECT</keyword>
    <keyword>EDGES</keyword>
    <keyword>REPEAT</keyword>
    <keyword>rhombus</keyword>
    <keyword>rhomboid</keyword>
    <application/>
  </script>

  <script ID="546" category="Simple Problem" name="rotate_rays01.inr" title="Rotating Rays to Window Plane">
    <description>
      This file shows effects of rayset rotation
      depending on considered objects.
      Useful to demonstrate how to view rays looking normal
      to a surface that has been rotated so that it is not
      parallel to the window plane.
    </description>
    <keyword>Manipulating</keyword>
    <keyword>rays</keyword>
    <keyword>ROTATE</keyword>
    <keyword>SHIFT</keyword>
    <keyword>RAYS</keyword>
    <application/>
  </script>

  <script ID="547" category="Simple Problem" name="rotate_rays02.inr" title="Rotating Ray Data">
    <description>
      Rotating ray data with ROTATE.
      Two variations are shown.  In one case, rotation
      is done immediately after source creation. In the
      other, the rayset is referenced at a later time for
      rotation using the RAYS command. The latter method
      is useful after using SELECT or CONSIDER commands
      to isolate a particular set of rays.
    </description>
    <keyword>Manipulating</keyword>
    <keyword>rays</keyword>
    <keyword>RAYS</keyword>
    <keyword>ROTATE</keyword>
    <application/>
  </script>

  <script ID="548" category="Simple Problem" name="rotate_rays03.inr" title="Rotated Ray STATS Output">
    <description>STATS output of rotated rays.</description>
    <keyword>Manipulating</keyword>
    <keyword>rays</keyword>
    <keyword>RAYS</keyword>
    <keyword>ROTATE</keyword>
    <keyword>STATS</keyword>
    <application/>
  </script>

  <script ID="549" category="Isolated Command" name="roughness_model01.inr" title="Gaussian Roughness">
    <description>
      A ROUGHNESS model with a USERBSDF Gaussian
      function for roughness.
    </description>
    <keyword>ROUGHNESS</keyword>
    <keyword>Scatter</keyword>
    <keyword>USERBSDF</keyword>
    <keyword>MODELS</keyword>
    <keyword>$FCN</keyword>
    <keyword>Gaussian</keyword>
    <application/>
  </script>

  <script ID="550" category="Isolated Command" name="roughness_model02.inr" title="Roughness using Phong Model">
    <description>
      A roughness model using a Phong-like
      function for a USERBSDF.
    </description>
    <keyword>ROUGHNESS</keyword>
    <keyword>Scatter</keyword>
    <keyword>$FCN</keyword>
    <keyword>MODELS</keyword>
    <keyword>USERBSDF</keyword>
    <keyword>Phong</keyword>
    <application/>
  </script>

  <script ID="551" category="Simple Problem" name="roughness_model03.inr" title="Ground Glass Scatter">
    <description>
      This shows how to simulate ground glass scatter
      using ROUGHNESS with a Lambertian model. It demonstrates
      2-way scatter through bare Fresnel interfaces.
    </description>
    <keyword>Scatter</keyword>
    <keyword>ground</keyword>
    <keyword>glass</keyword>
    <keyword>ROUGHNESS</keyword>
    <keyword>MODELS</keyword>
    <keyword>title</keyword>
    <application/>
  </script>

  <script ID="552" category="Simple Problem" name="ROUGHNESS_MODEL_04.inr" title="Modeling White Etched Plastic">
    <description>
      White partially transmissive etched plastic cube
      with light incident at an angle.
    </description>
    <keyword>Scatter</keyword>
    <keyword>ROUGHNESS</keyword>
    <keyword>HARVEY</keyword>
    <keyword>plastic</keyword>
    <keyword>etched</keyword>
    <application/>
  </script>

  <script ID="553" category="Isolated Command" name="roughness_random01.inr" title="Applying Random Surface Roughness">
    <description>
      A random roughness is applied to
      a surface and hit with a random emitting source
      where all rays are parallel to Z axis. The
      reflected intensity distribution is analyzed
      for each of the RANDOM probability distributions
      (m) allowed - Two Deltas, Lambertian, Ramp, Uniform,
      Triangular, Gaussian-like, Cosine, Near-Gaussian, Gaussian.
    </description>
    <keyword>ROUGHNESS</keyword>
    <keyword>Scatter</keyword>
    <keyword>random</keyword>
    <keyword>$DO</keyword>
    <keyword>XMEMORY MIN</keyword>
    <keyword>ACCURACY</keyword>
    <application/>
  </script>

  <script ID="554" category="Isolated Command" name="rounded01.inr" title="A Rounded Edge">
    <description>
      A ROUNDED edge shown
      with PLOT EDGES.
    </description>
    <keyword>ROUNDED</keyword>
    <keyword>EDGES</keyword>
    <application/>
  </script>

  <script ID="555" category="Isolated Command" name="RRM_Crossed_O-type_polarizer_01.inr" title="Crossed O-Type Polarizer with Thick C-Plate">
    <description>
      Demonstration of using RRM to create a Realistic
      Retarder Model.  A crossed O-type polarizer with thick C-plate.
      A C-plate has the extraordinary axis aligned with the optical axis
      so there is no retardance on axis, and increasing retardance with
      angle of incidence. It works as a negative birefringence phase
      compensator having isotropic refractive indices in the x-y plane.
      This compensates for the positive birefringence in the Liquid Crystal
      and thereby improves off-axis performance. Since this C-plate is "thick"
      it exhibits multiple waves of retardance at high angles of incidence.
      Initial polarization state of rays is random - default Gaussian
      distribution. No pre-polarizers are used.
    </description>
    <keyword>RRM</keyword>
    <keyword>POLARIZ</keyword>
    <keyword>RPM</keyword>
    <keyword>crossed</keyword>
    <keyword>polarizer</keyword>
    <keyword>Polarization</keyword>
    <keyword>retarder</keyword>
    <keyword>waveplate</keyword>
    <keyword>XMEMORY NORM</keyword>
    <keyword>Liquid Crystal</keyword>
    <application/>
  </script>

  <script ID="556" category="Isolated Command" name="RRM_Crossed_O-type_polarizer_02.inr" title="Crossed O-Type Polarizer with Thicker C-Plate">
    <description>
      Demonstration of using RRM to create a Realistic
      Retarder Model.  A crossed O-type polarizer with a thicker C-plate
      (than the RRM_CROSSED_O-TYPE_POLARIZER_01.INR). A C-plate has the
      extraordinary axis aligned with the optical axis so there is no
      retardance on axis, and increasing retardance with angle of incidence.
      Since this one is "thick" it exhibits multiple waves of retardance at
      high angles of incidence. Initial polarization state of rays is random -
      default Gaussian distribution. No pre-polarizers are used.
    </description>
    <keyword>RRM</keyword>
    <keyword>POLARIZ</keyword>
    <keyword>RPM</keyword>
    <keyword>crossed</keyword>
    <keyword>polarizer</keyword>
    <keyword>Polarization</keyword>
    <keyword>retarder</keyword>
    <keyword>waveplate</keyword>
    <keyword>Liquid Crystal</keyword>
    <keyword>Maltese Cross</keyword>
    <application/>
  </script>

  <script ID="557" category="Isolated Command" name="sawtooth01.inr" title="A Sawtooth Edge">
    <description>
      A sawtooth edge
      displayed with PLOT EDGES.
    </description>
    <keyword>SAWTOOTH</keyword>
    <keyword>EDGES</keyword>
    <application/>
  </script>

  <script ID="558" category="Simple Problem" name="Sawtooth_Circle.inr" title="Grooved Tube made by Functions">
    <description>
      This makes a sawtooth circle using several
      function commands, which is then extruded into a tube.
      The end result is a linearly grooved tube. Tube radius,
      teeth height, and number are adjustable.
    </description>
    <keyword>Edges</keyword>
    <keyword>sawtooth</keyword>
    <keyword>EDGES</keyword>
    <keyword>function</keyword>
    <keyword>POINTS</keyword>
    <keyword>circle</keyword>
    <keyword>SWEEP</keyword>
    <keyword>$FCN</keyword>
    <keyword>groove</keyword>
    <keyword>tube</keyword>
    <application/>
  </script>

  <script ID="559" category="Simple Problem" name="Sawtooth_Slab_01.inr" title="Sawtooth Slab using EDGES">
    <description>
      Creates a slab with top corrugated as sawtooth
      using EDGES.
    </description>
    <keyword>Edges</keyword>
    <keyword>sawtooth</keyword>
    <keyword>EDGES</keyword>
    <keyword>corrugated</keyword>
    <application/>
  </script>

  <script ID="560" category="Simple Problem" name="Sawtooth_Slab_02.inr" title="Sawtooth Slab using Bounded Surfaces">
    <description>
      Creates a slab with top corrugated using SAWTOOTH
      and LINE EDGES COMPOSITEd for the sides.
    </description>
    <keyword>Bounds</keyword>
    <keyword>sawtooth</keyword>
    <keyword>EDGES</keyword>
    <keyword>corrugated</keyword>
    <keyword>LINE</keyword>
    <keyword>SWEEP</keyword>
    <keyword>COMPOSITE</keyword>
    <keyword>BOUNDS</keyword>
    <application/>
  </script>

  <script ID="561" category="Isolated Command" name="SCALE_01.inr" title="Using SCALE to Mirror a Rayset">
    <description>
      A simple example to show mirroring of
      a rayset using SCALE.  Source and scaled rays were
      shifted to confirm operation in 3D viewer.
    </description>
    <keyword>SCALE</keyword>
    <keyword>RAYSET</keyword>
    <keyword>rays</keyword>
    <keyword>mirroring</keyword>
    <application/>
  </script>

  <script ID="562" category="Simple Problem" name="Scatter_Anisotropic.inr" title="Anisotropic Scatter on Optical Surface">
    <description>
      Shows anisotropic Harvey scatter on an optical
      surface representing the hubcap of a car wheel with a turned
      surface of concentric grooves. The hubcap could be made more
      realistic by bounding it with edges or tubes. The RENDER MODELS
      command allows viewing all 3 scatter models used. The final
      view point is dependent on the geometry orientation, VIEW angle,
      and LIGHT source position.
    </description>
    <keyword>Scatter</keyword>
    <keyword>anisotropic</keyword>
    <keyword>HARVEY</keyword>
    <keyword>RENDER</keyword>
    <keyword>MODELS</keyword>
    <keyword>hubcap</keyword>
    <keyword>$PLOT</keyword>
    <keyword>$IO</keyword>
    <keyword>VIEW</keyword>
    <keyword>LIGHTS</keyword>
    <keyword>ACCURACY</keyword>
    <application/>
  </script>

  <script ID="563" category="Simple Problem" name="Scatter_Anisotropic02.inr" title="Scatter into Specular Plane Only">
    <description>
      Shows a way to get Harvey scatter into a single plane
      made with the specular and surface Normal.  Rays will be generated
      the full hemisphere (as seen with a TRACE PLOT), but most of the enrgy
      will be along a single plane, as described by the two shoulder points.
    </description>
    <keyword>Scatter</keyword>
    <keyword>anisotropic</keyword>
    <keyword>HARVEY</keyword>
    <keyword>MODELS</keyword>
    <application/>
  </script>

  <script ID="564" category="Simple Problem" name="Scatter_Bsdf.inr" title="Using Scatter Models">
    <description>
      For testing various scatter models using different
      incident angles, number of scatter rays, and direction. Note that
      BSDFDATA ANGLES normally takes thousands of data points for ASAP to
      do any reasonable attempt at interpolation over an entire hemisphere.
      The following is only a crude example to show how the data is set up.
    </description>
    <keyword>Scatter</keyword>
    <keyword>SCATTER</keyword>
    <keyword>BSDFDATA</keyword>
    <keyword>ANGLES</keyword>
    <keyword>MODELS</keyword>
    <keyword>TOWARDS</keyword>
    <keyword>SPEC</keyword>
    <keyword>Lambertian</keyword>
    <keyword>$FCN</keyword>
    <keyword>USERBSDF</keyword>
    <application/>
  </script>

  <script ID="565" category="Simple Problem" name="Scatter_HARVEY.inr" title="Harvey Scatter Model">
    <description>
      Shows Harvey model in graphical picture.
      Allows user to vary harvey parameters and see the effect.
    </description>
    <keyword>Scatter</keyword>
    <keyword>HARVEY</keyword>
    <keyword>bsdf</keyword>
    <keyword>MODELS</keyword>
    <application/>
  </script>

  <script ID="566" category="Simple Problem" name="scatter_infield.inr" title="In Field Scatter">
    <description>
      In-field scatter calculations on
      a mirror surface. A PSF is performed on the signal
      as well as the incoherent scatter rays.
    </description>
    <keyword>Scatter</keyword>
    <keyword>psf</keyword>
    <keyword>SPREAD</keyword>
    <keyword>SELECT</keyword>
    <keyword>bsdf</keyword>
    <application/>
  </script>

  <script ID="567" category="Simple Problem" name="Scatter_MIE.inr" title="MIE Scattering">
    <description>Scattering using the PARTICLES MIE model.</description>
    <keyword>Scatter</keyword>
    <keyword>MIE</keyword>
    <keyword>particles</keyword>
    <keyword>MODELS</keyword>
    <application/>
  </script>

  <script ID="568" category="Simple Problem" name="SCATTER_MODELS01.inr" title="Bi-directional Scatter">
    <description>
      Two way scatter using the MODELS
      modifier on the SCATTER command. Allows separate
      scatter models for both R and T. Forces scattering
      on both sides of interface without need for LEVEL ALL
      command or low energy cutoffs at the interface. A
      simple absorbing interface will work to allow scattering
      on both sides.   IMPORTANT! - Must have the "S" on MODELS for the
      two-directional model assignment to work.
    </description>
    <keyword>Scatter</keyword>
    <keyword>SCATTER</keyword>
    <keyword>MODELS</keyword>
    <application/>
  </script>

  <script ID="569" category="Simple Problem" name="SCATTER_MODELS02.inr" title="Bi-directional Scatter with COATING MODELS and SPLIT MONTECARLO">
    <description>
      Two way scatter using the MODELS
      modifier on the SCATTER command. Allows separate
      scatter models for both R and T. Forces scattering
      on both sides of interface without need for LEVEL ALL
      command or low energy cutoffs at the interface. The
      scattering interface allows for both reflection and
      transmission of the parent rays.
      Run with SPLIT MONTECARLO or SPLIT 1 (default)
      IMPORTANT! - Must have the "S" on MODELS for the
      two-directional model assignment to work.
    </description>
    <keyword>Scatter</keyword>
    <keyword>SCATTER</keyword>
    <keyword>MODELS</keyword>
    <keyword>SPLIT</keyword>
    <keyword>MONTECARLO</keyword>
    <application/>
  </script>

  <script ID="570" category="Simple Problem" name="Scatter_Volume_MIE.inr" title="Volume Scattering">
    <description>
      Shows possible use for modeling volume scatter
      using multiple surfaces (to represent the volume) with MIE
      model applied. It is necessary to conserve flux by tracking
      parent ray transmission through the volume.
    </description>
    <keyword>Scatter</keyword>
    <keyword>MIE</keyword>
    <keyword>particles</keyword>
    <keyword>MODELS</keyword>
    <keyword>volume</keyword>
    <keyword>$GO</keyword>
    <application/>
  </script>

  <script ID="571" category="Simple Problem" name="Script_Lens_Anal.inr" title="A Typical Script">
    <description>
      A typical script showing geometry, source
      and analysis. A lens is built with surface entities and
      then analyzed.
    </description>
    <keyword>Scripts</keyword>
    <keyword>lens</keyword>
    <keyword>Geometry</keyword>
    <keyword>Analysis</keyword>
    <application/>
  </script>

  <script ID="572" category="Simple Problem" name="script_setup.inr" title="Setting up a Script File">
    <description>
      The following shows example system and
      data-base settings for a script that will perform
      a light pipe analysis. Explanations of various
    </description>
    <keyword>Scripts</keyword>
    <keyword>MEDIA</keyword>
    <keyword>FRESNEL</keyword>
    <keyword>SPLIT</keyword>
    <keyword>RETURN</keyword>
    <keyword>SYSTEM</keyword>
    <keyword>RESET</keyword>
    <keyword>pipe</keyword>
    <application/>
  </script>

  <script ID="573" category="Isolated Command" name="search01.inr" title="SEARCH Command Options">
    <description>
      Various options for using the
      SEARCH command.
    </description>
    <keyword>SEARCH</keyword>
    <keyword>Tracing</keyword>
    <keyword>sequential</keyword>
    <application/>
  </script>

  <script ID="574" category="Isolated Command" name="search02.inr" title="SEARCH Command Output">
    <description>
      SEARCH command output for a specific
      sequential raytrace of a Triplet lens.
    </description>
    <keyword>SEARCH</keyword>
    <keyword>Tracing</keyword>
    <keyword>sequential</keyword>
    <application/>
  </script>

  <script ID="575" category="Simple Problem" name="SEARCH_XCube.inr" title="Skipping Objects with SEARCH">
    <description>
      A hypothetrical beam combiner (X-cube) showing
      how to bypass objects with SEARCH. The SEARCH criteria on
      the input sides of a cube are set to direct rays to the
      correct reflective diagonal surface so that they will
      only exit out the one side. Three one-dimensional GRID
      sources are set up with varying sizes to more clearly
      show the ray paths in the 3D viewer. The Green input side
      is set up to see only the output side and skip both
      diagonals. The Blue and Red input sides can only see
      the diagonal that allows the rays to reflect out the
      output side.   This is a simplified example. SEARCH criteria may be
      modified for BARE interfaces or splitting, as required.
    </description>
    <keyword>Interfaces</keyword>
    <keyword>SEARCH</keyword>
    <keyword>cube</keyword>
    <keyword>combiner</keyword>
    <application/>
  </script>

  <script ID="576" category="Simple Problem" name="seed_quasi.inr" title="Quasi-Random Emitters">
    <description>
      Shows how to generate a quasi-random
      set of rays on emitting sources.  This enables a
      smoother distribution of rays avoiding statistical
      clumping that can occur when using the default random
      ray generation. A before and after case is demonstrated.
      Simply changing the seed number will only start the rays
      at a different point in the sequence and still clump,
      but in different areas. The QUASI option is needed
      for a quasi-random sequence. Only one of 50 sequences are
      available for emitters (n=1 to 50).
    </description>
    <keyword>Sources</keyword>
    <keyword>SEED</keyword>
    <keyword>QUASI</keyword>
    <keyword>random</keyword>
    <keyword>rays</keyword>
    <keyword>EMITTING</keyword>
    <application/>
  </script>

  <script ID="577" category="Isolated Command" name="select01.inr" title="Isolating Ray Data">
    <description>
      Isolating ray data using the SELECT
      command. Three cases are shown.
    </description>
    <keyword>SELECT</keyword>
    <keyword>rays</keyword>
    <application/>
  </script>

  <script ID="578" category="Isolated Command" name="SELECT02.inr" title="Selecting Radial or Rectangular Regions">
    <description>
      Show selection of "round" and "rectangular" regions
      in direction cosine space using SELECT with one
      direction-cosine criterion or two, respectively.
    </description>
    <keyword>SELECT</keyword>
    <keyword>Radiometry</keyword>
    <application/>
  </script>

  <script ID="579" category="Simple Problem" name="SELECT_NA.inr" title="Demonstrate Selection by Numerical Aperture">
    <description>
      Selecting rays within a central core of
      the measured NA. Shows how to keep only rays in the
      inner half (in angle) of the beam NA, or the
      complementary set.
    </description>
    <keyword>Radiometry</keyword>
    <keyword>SELECT</keyword>
    <keyword>na</keyword>
    <keyword>$GRAB</keyword>
    <application/>
  </script>

  <script ID="580" category="Isolated Command" name="shift01.inr" title="Shifting Objects or Entities">
    <description>
      SHIFT command is used in same
      way for an Object or an Entity.
    </description>
    <keyword>SHIFT</keyword>
    <application/>
  </script>

  <script ID="581" category="Isolated Command" name="show01.inr" title="SHOW Command Output">
    <description>
      Typical output from the SHOW vs.
      the SHOW ALL commands. Prints out the status
      of some or ALL of the system settings' commands.
    </description>
    <keyword>SHOW</keyword>
    <application/>
  </script>

  <script ID="582" category="Simple Problem" name="Singlet_Coherent.inr" title="Fast Singlet Coherent Analysis">
    <description>
      Gaussian beam propagation through a fast singlet
      lens, with coherent field analysis.
    </description>
    <keyword>Wave</keyword>
    <keyword>Analysis</keyword>
    <keyword>singlet</keyword>
    <keyword>Lenses</keyword>
    <keyword>COHERENT</keyword>
    <keyword>FIELD</keyword>
    <application/>
  </script>

  <script ID="583" category="Simple Problem" name="SINGLET_Ghost_Anal.INR" title="Ghost Analysis on a Singlet Lens">
    <description>
      This file explodes a singlet and creates an edge around
      the front and back surfaces, yielding three objects.
      A grid of rays is launched 10mm in front of the lens. FRESNEL and
      SPLIT provide for ghost imaging. Split levels are set for the ghost order.
      The first 4 plots show the ghost images consecutively layered.
      The last four plots show each ghost order separately using the
      Path eXplorer, PX. Finally, Z axis positions of the ghosts are computed.
    </description>
    <keyword>Analysis</keyword>
    <keyword>ghost</keyword>
    <keyword>LENSES</keyword>
    <keyword>SINGLET</keyword>
    <keyword>SAVE</keyword>
    <keyword>PATHS</keyword>
    <keyword>HISTORY PX</keyword>
    <keyword>EXPLODE</keyword>
    <keyword>SELECT</keyword>
    <application/>
  </script>

  <script ID="584" category="Simple Problem" name="singlet_lens.inr" title="Building a Singlet Lens">
    <description>
      A Singlet lens created with
      PLANE, OPTICAL, and TUBE commands.
    </description>
    <keyword>Geometry</keyword>
    <keyword>singlet</keyword>
    <keyword>lens</keyword>
    <application/>
  </script>

  <script ID="585" category="Simple Problem" name="singlet_script.inr" title="Finding Best Focus of a Lens">
    <description>
      A complete sample script creating a
      plano-convex lens, tracing a few rays and finding
      best focus. Shows the four-step process - Build system;
      Create source; Trace rays; Perform analysis.
    </description>
    <keyword>Scripts</keyword>
    <keyword>singlet</keyword>
    <keyword>lens</keyword>
    <keyword>Analysis</keyword>
    <keyword>Geometry</keyword>
    <keyword>FOCUS</keyword>
    <keyword>PICTURE</keyword>
    <application/>
  </script>

  <script ID="586" category="Isolated Command" name="SKEW_RAYS.inr" title="Using SKEW on Rays">
    <description>
      Create 2 GRIDs passing through the first element of Cooke Triplet.
      SKEW second GRID by 20 degrees from Y to X.
    </description>
    <keyword>SKEW</keyword>
    <keyword>GRID</keyword>
    <keyword>rays</keyword>
    <application/>
  </script>

  <script ID="587" category="Isolated Command" name="SKEW_SURFACE.inr" title="Modifying an Object with SKEW">
    <description>
      SKEW the back side of the first element of Cooke Triplet,
      by 60 degrees from Y to Z.
    </description>
    <keyword>SKEW</keyword>
    <application/>
  </script>

  <script ID="588" category="Simple Problem" name="SolidWall_Hex_Shape.inr" title="Thick-Walled Hex Tube using EDGES and OBJECT">
    <description>
      Making a hex-shaped tube using EDGES and the second
      syntax of the OBJECT command.  The walls of the tube are made to
      have thickness.
    </description>
    <keyword>Geometry</keyword>
    <keyword>extrude</keyword>
    <keyword>OBJECT</keyword>
    <keyword>EDGES</keyword>
    <keyword>POINTS</keyword>
    <keyword>hex</keyword>
    <keyword>tube</keyword>
    <application/>
  </script>

  <script ID="589" category="Simple Problem" name="Source_Bulb_Fluor_Str.inr" title="Straight Fluorescent Tube">
    <description>
      This example shows a simple straight fluorescent tube
      using a volume emitting source at center which is the  length of the tube.
      An inner tube surrounds this  emitter whose surface properties are set up so that
      only the scattered rays get through and no specular rays.
      This simulates a plasma. Two macros are used, one
      calling another, to create the ends of the tube.
    </description>
    <keyword>Sources</keyword>
    <keyword>Fluorescent</keyword>
    <keyword>bulb</keyword>
    <keyword>EMITTING CONE</keyword>
    <keyword>RACETRACK</keyword>
    <keyword>SCATTER</keyword>
    <keyword>random</keyword>
    <keyword>SUBSET</keyword>
    <application/>
  </script>

  <script ID="590" category="Isolated Command" name="source_dir01.inr" title="SOURCE DIRECTION command">
    <description>Example of creating two grid sources.</description>
    <keyword>SOURCE</keyword>
    <keyword>Sources</keyword>
    <keyword>direction</keyword>
    <application/>
  </script>

  <script ID="591" category="Isolated Command" name="source_dir02.inr" title="SOURCE DIRECTION GRID command">
    <description>
      Example of creating a SOURCE
      DIRECTION GRID. The first grid defines the size
      and the number of grids.  In this case 4x4 grid
      in a square xy plane of -1.5 to 1.5. Since it is
      elliptical, we end up with only 12 grids total.
      The second grid defines the direction and spread
    </description>
    <keyword>SOURCE</keyword>
    <keyword>Sources</keyword>
    <keyword>direction</keyword>
    <keyword>grid</keyword>
    <application/>
  </script>

  <script ID="592" category="Isolated Command" name="source_focus01.inr" title="SOURCE FOCUS Command">
    <description>
      Example of creating three sources
      whose direction is given by focal coordinates.
    </description>
    <keyword>SOURCE</keyword>
    <keyword>Sources</keyword>
    <keyword>FOCUS</keyword>
    <keyword>MISSED</keyword>
    <application/>
  </script>

  <script ID="593" category="Simple Problem" name="Source_Multiple.inr" title="Three-Color Ray Trace">
    <description>
      The following example shows how to trace three
      sources at three different wavelengths and apply colors to
      them for visual representation.  Here, a typical source with
      red, green and blue components is traced through a singlet
      lens.  Note that with recent versions of ASAP, the COLORS
      keyword may not be necessary, as ASAP will color individual
      sources according to wavelength as best possible.
    </description>
    <keyword>Tracing</keyword>
    <keyword>COLORS</keyword>
    <keyword>WAVELENGTHS</keyword>
    <keyword>rays</keyword>
    <keyword>TRACE</keyword>
    <keyword>SELECT</keyword>
    <application/>
  </script>

  <script ID="594" category="Isolated Command" name="source_pos01.inr" title="SOURCE POSITION Example">
    <description>
      Two sources are created with ray
      directions determined by their virtual origins.
      The rays will start tracing from the GRID
      position, but appear to come from the point
      given by the SOURCE POS coordinates. This is
      useful for plotting a fan of rays at a
      particular angle starting just before an optic
      though their origin may be far away.
    </description>
    <keyword>SOURCE</keyword>
    <keyword>POS</keyword>
    <application/>
  </script>

  <script ID="595" category="Isolated Command" name="source_pos02.inr" title="SOURCE POSITION GRID Example">
    <description>
      A grid of sources are created from
      the information provided by two GRID commands.
      In this example, the first GRID tells ASAP how
      many rays are in each grid in XY.  Since this is
      an elliptical grid, the total is 12. It also determines
      the size of the grid (-4@1) at the starting position (Z=0).
      The second GRID gives the extent of the apparent origins
      of the entire array of grids in XY at their starting position.
      This would be -4@0.5 at Z=-3. The MOVE command moves the rays
      of all grids along their trajectories to this point, so that
      the raytrace will start from there.
      The plot shows how the rays from each grid cross each other
      at the grid starting point of Z=0 so that there are 9 rays
      eminating from the location defined by the first GRID command.
      Each ray contributed by one of the 9 grids.
    </description>
    <keyword>SOURCE</keyword>
    <keyword>POS</keyword>
    <keyword>grid</keyword>
    <application/>
  </script>

  <script ID="596" category="Isolated Command" name="source_wave01.inr" title="SOURCE WAVEFUNC Example">
    <description>
      Allows defining the source
      point of rays in a grid to start from a
      wavefront surface defined by a surface function.
      In this example, the rays in the grid are moved
      along Z to the nearest point on the wavefront
      surface made with the OPTICAL command.
    </description>
    <keyword>SOURCE</keyword>
    <keyword>WAVEFUNC</keyword>
    <application/>
  </script>

  <script ID="597" category="Simple Problem" name="spatial_filter.inr" title="Spatial Filter Model">
    <description>
      This lens system models spatial filtering
      in the Fourier transform plane. The POINTS model of
      the letter "F" is projected through a spatial filter
      which truncates some of the spatial frequencies. It is
      then analyzed at the image plane. This is a somewhat
      sophisticated script dealing with decomposing beams
      in position and direction and should be used in caution
      by those already familiar with these techniques.
    </description>
    <keyword>Wave</keyword>
    <keyword>SPREAD</keyword>
    <keyword>DECOMPOSE</keyword>
    <keyword>FIELD</keyword>
    <keyword>CLIP</keyword>
    <keyword>filter</keyword>
    <keyword>diffraction</keyword>
    <keyword>Fourier</keyword>
    <application/>
  </script>

  <script ID="598" category="Simple Problem" name="SPECTRUM_Weighting.inr" title="Weighting Flux to Wavelength using SPECTRUM">
    <description>
      Making a polychromatic source with weighting applied
      to each wavelength.  The total flux assigned to all sources will be
      distributed according to the weights.
    </description>
    <keyword>Sources</keyword>
    <keyword>SPECTRUM</keyword>
    <keyword>FLUX</keyword>
    <keyword>$DO</keyword>
    <keyword>STATS SOURCES</keyword>
    <application/>
  </script>

  <script ID="599" category="Simple Problem" name="Spherical_Irradiance.inr" title="Irradiance on a Spherical Detector">
    <description>
      This expects a source located somewhere inside a
      'sphere,' of which a section of it is the detector surface.
      First, set up a sphere to match the detector surface and apply
      transmissive scattering so that only child rays get
      through, leaving Normal to the surface. The PROFILE
      command shows clearly how this works using the following
      code.  The result is that the original directional
      information is lost and your left with essentially the
      positions along the spherical surface with directions
      relative to the sphere center. RADIANT then creates a
      distribution file which gives the far-field flux per
      spherical angles relative to the center of the sphere.
      By dividing this by the sphere radius squared, the
      steradian factor is removed, and your left with flux per
      surface area or Irradiance.  Key elements are highlighted.
    </description>
    <keyword>Analysis</keyword>
    <keyword>spherical</keyword>
    <keyword>RADIANT</keyword>
    <keyword>NORMALIZE</keyword>
    <keyword>irradiance</keyword>
    <application/>
  </script>

  <script ID="600" category="Simple Problem" name="Spherical_Surface_W_Hole.inr" title="Spherical Mirror by Swept Edge">
    <description>
      A simple way to create a spherical surface
      with a central hole.  A spherical edge is made
      from the outer edge of the central hole to the
      edge of the surface. A SWEEP AXIS of 360° around
      the optical axis makes the surface.
    </description>
    <keyword>Edges</keyword>
    <keyword>POINTS</keyword>
    <keyword>spherical</keyword>
    <keyword>SWEEP</keyword>
    <keyword>AXIS</keyword>
    <application/>
  </script>

  <script ID="601" category="Simple Problem" name="spline2d.inr" title="Explicit 2D Spline Curve">
    <description>
      Simple example of a 2D SPLINE.
      This is just a parabola. This example is
    </description>
    <keyword>Edges</keyword>
    <keyword>SPLINE</keyword>
    <keyword>2d</keyword>
    <keyword>parabola</keyword>
    <keyword>SEGMENTS</keyword>
    <application/>
  </script>

  <script ID="602" category="Simple Problem" name="spline3d.inr" title="General 3D Spline Curve">
    <description>
      Simple example of a general 3D SPLINE.
      This is Just a parabola.  This example is created
    </description>
    <keyword>Edges</keyword>
    <keyword>SPLINE</keyword>
    <keyword>3d</keyword>
    <keyword>parabola</keyword>
    <keyword>SEGMENTS</keyword>
    <application/>
  </script>

  <script ID="603" category="Isolated Command" name="SPLIT01.inr" title="SPLIT 3 using Fractional Energy Cutoff">
    <description>
      Ray trace plot showing effects of
      SPLIT set to 3. First and second generation child rays
      are allowed to split but third generation cannot split.
      Only the most energetic great-grand-child ray continues.
      Cutoff option controls how much energy a split ray needs
      to continue.
    </description>
    <keyword>SPLIT</keyword>
    <keyword>Tracing</keyword>
    <keyword>child</keyword>
    <keyword>parent</keyword>
    <keyword>rays</keyword>
    <keyword>splitting</keyword>
    <keyword>EMITTING</keyword>
    <application/>
  </script>

  <script ID="604" category="Isolated Command" name="spots_dir01.inr" title="A Directional Spots Diagram">
    <description>
      Creating a spots diagram in
      direction cosine space. Note that in all
      cases here, a display file is not created.
      Typically, one would create a display file
      and not want to plot the spots (ATTRIBUTE 0).
      In this example, two methods for plotting the
      spots are shown. One plots all 3 sources at
      once using plus signs. The other selects a
      different symbol for each and includes text
      in the plot. The spots are actual ray direction
      cosine coordinates on the unit sphere.
    </description>
    <keyword>SPOTS</keyword>
    <keyword>DIRECTION</keyword>
    <keyword>Analysis</keyword>
    <keyword>TEXT</keyword>
    <application/>
  </script>

  <script ID="605" category="Isolated Command" name="spots_pos01.inr" title="Spots Diagram in Position">
    <description>
      Creating a positional spots
      diagram. Note that in all cases here, the
      attribute modifier does not allow a display
      file to be created. When a display file is
      needed, the ATTRIBUTE modifier is left off
      or ATTRIBUTE 0 is used to suppress the spots.
      In this case, two methods for plotting the
      spots are shown. One plots all 3 sources at
      once using plus signs. The other selects a
      different symbol for each and includes text
      in the plot. The spots shown are actual ray
      positions on the source.
    </description>
    <keyword>SPOTS</keyword>
    <keyword>POSITION</keyword>
    <keyword>Analysis</keyword>
    <keyword>TEXT</keyword>
    <application/>
  </script>

  <script ID="606" category="Isolated Command" name="spots_pos02.inr" title="SPOTS POSITION Distribution">
    <description>
      Creating a positional spots
      diagram of multiple emitting spheroids
      with display file.
    </description>
    <keyword>SPOTS</keyword>
    <keyword>POS</keyword>
    <keyword>Analysis</keyword>
    <keyword>NORMALIZE</keyword>
    <application/>
  </script>

  <script ID="607" category="Isolated Command" name="SPOTS_XY.inr" title="Using the XY[Z] option">
    <description>
      Demonstrates use of the XY[Z] option on SPOTS POSITION
      for calculating spot diagram on arbitrarily oriented plane.
    </description>
    <keyword>AXIS</keyword>
    <keyword>LOCAL</keyword>
    <keyword>SPOTS</keyword>
    <keyword>XY[X]</keyword>
    <application/>
  </script>

  <script ID="608" category="Isolated Command" name="spread01.inr" title="Slicing Irradiance with SPREAD">
    <description>
      Slicing an irradiance pattern
      using the SPREAD command. SPREAD NORMAL gives
      an exact calculation of coherent energy in the
      direction given by the WINDOW command. Must have
      at least 4 parabasals and beams in the same medium.  M
      ultiple wavelengths are incoherently summed. No
      polarization or complex phase information is saved.
      The DOWN option limits the window area for
      calculation - see below.
    </description>
    <keyword>SPREAD</keyword>
    <keyword>irradiance</keyword>
    <keyword>psf</keyword>
    <application/>
  </script>

  <script ID="609" category="Isolated Command" name="spread02.inr" title="Two-Beam Interference">
    <description>ASAP model of 2 beam interference.</description>
    <keyword>SPREAD</keyword>
    <keyword>beams</keyword>
    <keyword>interference</keyword>
    <application/>
  </script>

  <script ID="610" category="Isolated Command" name="spread_normal01.inr" title="Diffraction Calculation">
    <description>
      Making a diffraction calculation
      with SPREAD NORMAL. A comparison to the incoherent
      SPOTS POSITION is shown. Note the difference in flux
      calculation. For SPREAD NORMAL, a wavelength must
      be specified and at least 4 parabasals used. If there
      are multiple wavelength raysets selected, they will
      be incoherently summed together in intensity. This is
      different from FIELD ENERGY where they are summed
      coherently. SPREAD NORMAL is also different in that
      no phase information or polarization effects are
      calculated.
    </description>
    <keyword>SPREAD</keyword>
    <keyword>Wave</keyword>
    <application/>
  </script>

  <script ID="611" category="Isolated Command" name="spread_normal02.inr" title="Diffraction of Rectangular Aperture">
    <description>
      SPREAD NORMAL on rectangular aperture
      system. A truncated rectangular plane wave is
      used to simulate the aperture.  Plots are given of
      both the source wavefront and the PSF on the
      detector.
    </description>
    <keyword>SPREAD</keyword>
    <keyword>Wave</keyword>
    <keyword>psf</keyword>
    <application/>
  </script>

  <script ID="612" category="Simple Problem" name="SQUARE_PYRAMID_ARRAY_CROSSED_ROOFS.inr" title="Square pyramid array by bounded, crossed ROOFS">
    <description>
      An ARRAY of hexagonal pyramids is made using crossed
      ROOF surfaces. The two ROOFs are mutually bounded to form the pyramids.
      Please note the possibility for ray leakage (see Help, ROOF command)
      (approx 3% measured) when directing rays on axis with the pyramids.
      This should not be a concern when intersecting with randomized ray directions.
    </description>
    <keyword>Arrays</keyword>
    <keyword>ROOF</keyword>
    <keyword>ARRAY</keyword>
    <keyword>OBLIQUE</keyword>
    <keyword>RENDER</keyword>
    <keyword>LIGHTS</keyword>
    <keyword>pyramid</keyword>
    <application/>
  </script>

  <script ID="613" category="Isolated Command" name="stats01.inr" title="STATS Command Options">
    <description>
      Various options of the
      STATS command. See below for explanations.
    </description>
    <keyword>STATS</keyword>
    <keyword>POS</keyword>
    <keyword>DIRECTION</keyword>
    <keyword>Sources</keyword>
    <application/>
  </script>

  <script ID="614" category="Isolated Command" name="stats02.inr" title="STATS Command Output">
    <description>
      Example output of the STATS
      command, using the three available options.
    </description>
    <keyword>STATS</keyword>
    <keyword>POS</keyword>
    <keyword>DIR</keyword>
    <keyword>Analysis</keyword>
    <application/>
  </script>

  <script ID="615" category="Simple Problem" name="stokes_filters.inr" title="Stokes Filters">
    <description>
      Calculates polarization state of a ray
      that passes through each of four Stokes filters. The
      Stokes results are printed along with the polarization
      states of each filter. Try different polarizations of
      the initial ray below.
    </description>
    <keyword>Polarization</keyword>
    <keyword>Stokes</keyword>
    <keyword>POLARIZ</keyword>
    <keyword>POLAR</keyword>
    <keyword>IDEAL</keyword>
    <keyword>filter</keyword>
    <application/>
  </script>

  <script ID="616" category="Isolated Command" name="String_Compare01.inr" title="Comparing Strings with $IF">
    <description>
      Comparing two literals using $IF. Note, literal
      strings may be assigned to any of the registers between A0 and Z9.
    </description>
    <keyword>$IF</keyword>
    <keyword>literal</keyword>
    <keyword>Macros_pre</keyword>
    <keyword>string</keyword>
    <application/>
  </script>

  <script ID="617" category="Simple Problem" name="String_Passing01.inr" title="Numeric String Passing">
    <description>
      An example of passing numeric values as literal
      strings to a macro for performing a calculation, without
      using the LIT operator.
    </description>
    <keyword>Scripts</keyword>
    <keyword>literal</keyword>
    <keyword>macro</keyword>
    <keyword>string</keyword>
    <keyword>register</keyword>
    <keyword>expression</keyword>
    <application/>
  </script>

  <script ID="618" category="Simple Problem" name="String_Passing02.inr" title="String Passing to Macros">
    <description>
      An example of passing strings to a macro
      for use in a command statement or plot title.
    </description>
    <keyword>Scripts</keyword>
    <keyword>literal</keyword>
    <keyword>macro</keyword>
    <keyword>string</keyword>
    <keyword>register</keyword>
    <keyword>expression</keyword>
    <application/>
  </script>

  <script ID="619" category="Simple Problem" name="String_Passing03.inr" title="Passing Strings to Macros">
    <description>
      Two methods of passing a string to a macro
      for use in an $IF..THEN string compare.
    </description>
    <keyword>Scripts</keyword>
    <keyword>literal</keyword>
    <keyword>macro</keyword>
    <keyword>string</keyword>
    <keyword>$ASK</keyword>
    <keyword>$IF</keyword>
    <application/>
  </script>

  <script ID="620" category="Simple Problem" name="Sun_Source.inr" title="Modeling the Sun's Rays">
    <description>
      Models the sun as a set of rays in a
      circular aperture that appear to come from a source
      at a specified coordinate of the celestial sphere
      (in spherical coordinates phi and theta), and
      which appear to have a specified angular size in
      the sky.  This is done with a grid of rays
      initially created parallel to one another (i.e., a  point source)
      from the specified point in the
      "sky". Then they are given a finite angle by using
      ASAP scatter models that allow us to scatter into
      a specified circular cone centered in the specular
      direction. Careful normalization of the BSDF has
      been done to recover the desired COS (Zenith Distance)
      dependence.
    </description>
    <keyword>Sources</keyword>
    <keyword>aperture</keyword>
    <keyword>SCATTER</keyword>
    <keyword>USERBSDF</keyword>
    <keyword>TOWARDS</keyword>
    <keyword>SPEC</keyword>
    <keyword>solar</keyword>
    <keyword>sun</keyword>
    <keyword>REVERSE</keyword>
    <application/>
  </script>

  <script ID="621" category="Isolated Command" name="SUPERCONIC01.inr" title="Use of the SUPERCONIC Surface">
    <description>
      Choose parameter values from the special cases.
      This example does a parabola.  The SUPERCONIC does not mesh, but the rays trace.
      Try different cases and watch the SPOTS POS on the detector.
    </description>
    <keyword>SUPERCONIC</keyword>
    <keyword>parabola</keyword>
    <application/>
  </script>

  <script ID="622" category="Isolated Command" name="surf_array01.inr" title="ARRAY Surface">
    <description>
      Two arrayed surfaces used to make
      stair steps. They are bounded to planes to define
      the tops and bottoms. A LIMITS box defines the sides.
    </description>
    <keyword>ARRAY</keyword>
    <keyword>SURFACE</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>stairs</keyword>
    <keyword>steps</keyword>
    <application/>
  </script>

  <script ID="623" category="Isolated Command" name="surf_array02.inr" title="Cassegrain Telescope with Vanes">
    <description>
      A Cassegrain telescope using vanes
      for light baffling. The ARRAY modifier creates
      additional copies of the "sample" vane surface
      which then all become one object. This reduces
      overall object count and saves raytrace time.
    </description>
    <keyword>ARRAY</keyword>
    <keyword>SURFACE</keyword>
    <keyword>Cassegrain</keyword>
    <application/>
  </script>

  <script ID="624" category="Isolated Command" name="surf_array03.inr" title="Two-Dimensional Array">
    <description>
      A 2-dimensional ARRAY of lenslet
      surfaces made with OPTICAL. A back is added so
      that the silica media may be assigned and rays
      traced through the 9 elements.
    </description>
    <keyword>ARRAY</keyword>
    <keyword>SURFACE</keyword>
    <keyword>$DO</keyword>
    <keyword>lenslet</keyword>
    <application/>
  </script>

  <script ID="625" category="Isolated Command" name="surf_axiconic01.inr" title="Axiconic Surface">
    <description>AXICONIC surface with PROFILES plot.</description>
    <keyword>AXICONIC</keyword>
    <keyword>SURFACE</keyword>
    <keyword>PROFILES</keyword>
    <application/>
  </script>

  <script ID="626" category="Isolated Command" name="surf_axiconic02.inr" title="Axiconic First Mode">
    <description>
      Axiconic surface using the first
      mode of operation where 2 foci are given.
      This example defines an axiconic surface 10 in
      diameter. The point (0,1.5,0) lies on the
      surface. The first focal point is located in
      the plane z = -30 and has a radius of 2. The
      second focal point is located in the plane
      z = -10 and has a radius of .5. The sign of s
      is positive so the sum of the distances from
      one focus to another is stationary.
    </description>
    <keyword>AXICONIC</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="627" category="Isolated Command" name="surf_axiconic03.inr" title="Axiconic Second Mode">
    <description>
      AXICONIC second mode of operation
      using only one focus (second focus moved to infinity).
      The last parameter (s) is the angle (in degrees) it
      makes to the axis of symmetry. This provides a
      simple way to make a Compound Parabolic Concentrator.
    </description>
    <keyword>AXICONIC</keyword>
    <keyword>SURFACE</keyword>
    <keyword>cpc</keyword>
    <application/>
  </script>

  <script ID="628" category="Isolated Command" name="surf_biconic01.inr" title="Biconic Surface">
    <description>
      BICONIC surface with profile
      plots. Profiles based on default 39 pixels.
    </description>
    <keyword>BICONIC</keyword>
    <keyword>SURFACE</keyword>
    <keyword>PROFILES</keyword>
    <application/>
  </script>

  <script ID="629" category="Isolated Command" name="surf_biconic02.inr" title="BICONIC with Trace">
    <description>
      A rectangular BICONIC reflector surface with
      a central hole. The hole is 0.2 times the size of the
      biconic aperture in each direction. The conic constant is
    </description>
    <keyword>BICONIC</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="630" category="Isolated Command" name="surf_cartoval01.inr" title="CARTOVAL Surface">
    <description>
      A cartesian oval surface example.
      The distance from the surface to first focus
      point=-5 and the refractive index of the first
      medium=1.0. The distance from the surface to the
      second focus point=2 and the refractive index of
      the second medium=2.5. It has a circular aperture
      of 1.
    </description>
    <keyword>CARTOVAL</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="631" category="Isolated Command" name="surf_cartoval02.inr" title="CARTOVAL Surface with Hole">
    <description>
      A cartesian oval surface with central
      hole. The distance from the surface to first focus
      point=-5 and the refractive index of the first
      medium=1.0. The distance from the surface to the
      second focus point=2 and the refractive index of
      the second medium=2.5. It has an elliptical aperture
      of X=0.8 and Y=1.2 with a central hole 0.2 of the
      aperture in both dimensions. Hole is at 0,0 offset
      from center (default).
    </description>
    <keyword>CARTOVAL</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="632" category="Isolated Command" name="surf_corner01.inr" title="Corner Cube Surface">
    <description>
      Create an axis-aligned and a circular
      corner cube. Locate a reference plane in the system
      in order to see the effects of changing CORNER parameters.
    </description>
    <keyword>CORNER</keyword>
    <keyword>SURFACE</keyword>
    <keyword>corner</keyword>
    <keyword>cube</keyword>
    <application/>
  </script>

  <script ID="633" category="Isolated Command" name="surf_ellipsoid01.inr" title="ELLIPSOID Surface">
    <description>
      An ellipsoidal surface
      with xyz semi-lengths of 2,1,3
      and center at 0,0,0.
    </description>
    <keyword>ELLIPSOID</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="634" category="Isolated Command" name="surf_general01.inr" title="GENERAL Surface">
    <description>
      An GENERAL surface made to be
      hyperbolic. There are two branches that result.
      The LOCAL box modifier may be used to limit
      boundaries to one branch or the other.
    </description>
    <keyword>GENERAL</keyword>
    <keyword>SURFACE</keyword>
    <keyword>LOCAL</keyword>
    <keyword>hyperbolic</keyword>
    <application/>
  </script>

  <script ID="635" category="Isolated Command" name="surf_horn01.inr" title="HORN Surface">
    <description>
      A horn surface using
      simple radial coefficients. In this
      case, the LOCAL command is needed to
      define its size.
    </description>
    <keyword>HORN</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="636" category="Isolated Command" name="surf_horn02.inr" title="HORN Surface #2">
    <description>Defines an OBJECT whose radial</description>
    <keyword>HORN</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="637" category="Isolated Command" name="surf_horn03.inr" title="HORN Surface with FIT">
    <description>
      Defines an OBJECT whose radial
      profile is determined by the following equation
      where z is measured from the reference point (0,0,6).
      The radial distances are computed from the function
      r(z) = 2 + COS(2 * p * z / 10). A $DO loop is used
      to generate the radial coordinate.
    </description>
    <keyword>HORN</keyword>
    <keyword>SURFACE</keyword>
    <keyword>LSQFIT</keyword>
    <application/>
  </script>

  <script ID="638" category="Isolated Command" name="surf_horn04.inr" title="Two HORN Surfaces">
    <description>
      Create two surfaces symmetric about
      the given axis with a radial profile determined
      by the following polynomial in the radial
    </description>
    <keyword>HORN</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="639" category="Isolated Command" name="surf_HYPERBOLIC.inr" title="GENERAL Surface">
    <description>
      A GENERAL surface made to be hyperbolic.
      Based on r^2/a^2-z^2/b^2=1. Put in the form
    </description>
    <keyword>GENERAL</keyword>
    <keyword>SURFACE</keyword>
    <keyword>LOCAL</keyword>
    <keyword>hyperbolic</keyword>
    <application/>
  </script>

  <script ID="640" category="Isolated Command" name="surf_optical01.inr" title="Aspheric OPTICAL Surface">
    <description>
      Defines an aspheric optical
      surface whose vertex is located at y = -2
      with a radius of curvature of -30 and a
      conic constant of -1. The 4th, 6th, 8th and
      10th order deformation coefficients are 1E-3,
    </description>
    <keyword>OPTICAL</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="641" category="Isolated Command" name="surf_optical02.inr" title="OPTICAL Surface">
    <description>
      An optical surface at Z=0,
      ROC=2 and an aperture of 1.
    </description>
    <keyword>OPTICAL</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="642" category="Isolated Command" name="surf_optical03.inr" title="Mangin Mirror using OPTICAL">
    <description>
      A Mangin mirror constructed with
      OPTICAL surfaces and a TUBE.
    </description>
    <keyword>OPTICAL</keyword>
    <keyword>SURFACE</keyword>
    <keyword>Mangin</keyword>
    <application/>
  </script>

  <script ID="643" category="Isolated Command" name="surf_redefine01.inr" title="Segmented Mirror using REDEFINE">
    <description>A Segmented mirror system as an alternate</description>
    <keyword>REDEFINE</keyword>
    <keyword>SURFACE</keyword>
    <keyword>alternate</keyword>
    <keyword>mirror</keyword>
    <application/>
  </script>

  <script ID="644" category="Isolated Command" name="surf_revolution01.inr" title="REVOLUTION Surface">
    <description>
      A surface created by a 2D curve
      spun around an axis. The 2D coefficients are
      given after specifying the axis starting position.
    </description>
    <keyword>REVOLUTION</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="645" category="Isolated Command" name="surf_sampled01.inr" title="Sampled Surface - First Form">
    <description>
      The first surface is the sampled surface.  It does
      not become an object.  It is used to deform the plane that follows
      for more efficient ray tracing.  DIFFS is an option that can be tried.
      It may give more realistic behavior of the sampled surface since it
      makes the changes more smoothly.  Note that $FAST is used.
      This will allow lines that are longer  than 344 characters,
      and greatly speeds the reading of the values.
    </description>
    <keyword>SAMPLED</keyword>
    <keyword>SURFACE</keyword>
    <keyword>$FAST</keyword>
    <application/>
  </script>

  <script ID="646" category="Isolated Command" name="surf_sampled02.inr" title="Sampled Surface - Second Form">
    <description>
      This is an example of syntax two of the SAMPLED
      command.  In this syntax, you are able to enter points on lines
      following the SAMPLED command. They will be evenly distributed
      within the bounds specifed.  This example creates a paraboloid
      of revolution based on sampled points.  The surface is created
      perpendicular to the Z axis, at 0.  The values are z values on
      an x-y grid.  The first pair of bounds is the x extent;
      the second pair is the y extent.  The end points are included.
      The x dimension is horizontal in the table of values.
      $FAST allows lines in excess of 344 characters to be read.
      The first argument is the number of values per line, and the
      second is the number of records.
    </description>
    <keyword>SAMPLED</keyword>
    <keyword>SURFACE</keyword>
    <keyword>$FAST</keyword>
    <application/>
  </script>

  <script ID="647" category="Isolated Command" name="surf_sampled03.inr" title="Sampled Surface using $ITER">
    <description>
      A sampled surface using a distribution
      file of sampled points generated by $ITER.
    </description>
    <keyword>SAMPLED</keyword>
    <keyword>SURFACE</keyword>
    <keyword>$ITER</keyword>
    <application/>
  </script>

  <script ID="648" category="Simple Problem" name="surf_SAMPLED_ARRAY_of_CAD_Element.inr" title="An Arrayed Sampled Surface from a CAD Element">
    <description>
      An example of reading in a CAD element
      representing a bump, sample it and array it.  MAP is used
      to create a DISPLAY file which is then SAMPLED.
      This SAMPLED surface is then turned into an ARRAY.
      It is assumed the array is to be at Z=0.
    </description>
    <keyword>Arrays</keyword>
    <keyword>SAMPLED</keyword>
    <keyword>SURFACE</keyword>
    <keyword>ARRAY</keyword>
    <keyword>MAP</keyword>
    <keyword>cad</keyword>
    <keyword>bumps</keyword>
    <keyword>dots</keyword>
    <keyword>backlight</keyword>
    <keyword>diffuser</keyword>
    <application/>
  </script>

  <script ID="649" category="Simple Problem" name="surf_SAMPLED_by_Bitmap.inr" title="Sampled Surface from Bitmap">
    <description>
      An example of reading in a bitmap (BMP)
      file of bumps on a planar base to make an ASAP object.
      DISPLAY is used  to create a corresponding DIS
      file, then SAMPLED is used to turn this into an
      ASAP surface entity. This entity is scaled to the
      proper user-specified size using a SCALE command,
      then bounded by a limiting plane to create different
      interface and scattering properties on the top
      portion of the bump compared to the base plane.
      The system is then RENDERed to show its appearance.
    </description>
    <keyword>SAMPLED</keyword>
    <keyword>SURFACE</keyword>
    <keyword>SCALE</keyword>
    <keyword>bitmap</keyword>
    <keyword>bmp</keyword>
    <keyword>digs</keyword>
    <keyword>scratches</keyword>
    <application/>
  </script>

  <script ID="650" category="Isolated Command" name="surf_test01.inr" title="TEST Surface Modifier">
    <description>
      One branch of a REVOLUTION surface
      is selected using the TEST modifier. The example
      demonstrates how to select each curve separately
      by specifying a test point on that curve. In
      either case below, commenting the TEST command
      out would produce both curves as one object.
    </description>
    <keyword>TEST</keyword>
    <keyword>SURFACE</keyword>
    <keyword>REVOLUTION</keyword>
    <keyword>PROFILES</keyword>
    <application/>
  </script>

  <script ID="651" category="Isolated Command" name="surf_torus01.inr" title="TORUS Surface #1">
    <description>
      A torus surface specified by its
      Z axis center, height to center of ring, and
      semi-radius of torus cross-section.
    </description>
    <keyword>TORUS</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="652" category="Isolated Command" name="surf_torus02.inr" title="TORUS Surface #2">
    <description>
      Defines a toroidal surface whose
      origin is at (3,0,0) with an outer diameter
      of 16 and an inner diameter of 12. The cross-
      sectional diameters are 2 and 4.
    </description>
    <keyword>TORUS</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="653" category="Isolated Command" name="surf_tube01.inr" title="TUBE Surface #1">
    <description>
      A circular tapered tube surface.
      Starts at Z=0 with a radius of 1 and ends at Z=2
      with a radius of 1.5. The q parameters are assumed
      0 for circular by default.
    </description>
    <keyword>TUBE</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="654" category="Isolated Command" name="surf_tube02.inr" title="TUBE Surface #2">
    <description>
      Defines a tube extending from
      z = 1 to z = -5.  At z = 1, the face of the
      tube is elliptical with semi-major lengths
      of .5 and 1.  At z = -5, the face of the tube
      is rectangular with semi-major lengths of 2 and 3.
    </description>
    <keyword>TUBE</keyword>
    <keyword>SURFACE</keyword>
    <keyword>PROFILES</keyword>
    <application/>
  </script>

  <script ID="655" category="Isolated Command" name="surf_zernike01.inr" title="ZERNIKE Surface">
    <description>
      A simple zernike surface using
      four coefficients.
    </description>
    <keyword>ZERNIKE</keyword>
    <keyword>SURFACE</keyword>
    <application/>
  </script>

  <script ID="656" category="Isolated Command" name="surf_zernike02.inr" title="ZERNIKE Surface with Trace">
    <description>
      Two different Zernike surfaces
      with different coefficients, showing raytrace results.
    </description>
    <keyword>ZERNIKE</keyword>
    <keyword>SURFACE</keyword>
    <keyword>macro</keyword>
    <keyword>LOCAL</keyword>
    <keyword>SCALE</keyword>
    <application/>
  </script>

  <script ID="657" category="Simple Problem" name="Sweep_Axis.inr" title="Partial Toroid by Swept Arc">
    <description>
      An EDGE ARC swept into a partial
      toroid with SWEEP AXIS.
    </description>
    <keyword>Edges</keyword>
    <keyword>SWEEP</keyword>
    <keyword>AXIS</keyword>
    <keyword>EDGES</keyword>
    <keyword>ARC</keyword>
    <keyword>toroid</keyword>
    <application/>
  </script>

  <script ID="658" category="Simple Problem" name="Sweep_Dir.inr" title="Arc Swept in Direction">
    <description>
      An ARC swept in direction to make a
      half tube with ends sliced at an angle.
    </description>
    <keyword>Edges</keyword>
    <keyword>EDGES</keyword>
    <keyword>ARC</keyword>
    <keyword>SWEEP</keyword>
    <keyword>DIR</keyword>
    <application/>
  </script>

  <script ID="659" category="Simple Problem" name="Sweep_Pos.inr" title="Arc Swept in Position">
    <description>
      An ARC swept along a specified distance
      to a point, makes a partial tapered tube or trough.
    </description>
    <keyword>Edges</keyword>
    <keyword>EDGES</keyword>
    <keyword>ARC</keyword>
    <keyword>SWEEP</keyword>
    <keyword>POS</keyword>
    <application/>
  </script>

  <script ID="660" category="Isolated Command" name="SWEEP_Truncated_Cone.inr" title="Truncated Cone with Swept Edge">
    <description>
      Making a truncated cone using
      an elliptical edge swept in position.  The
      faceting of the surface depends on the segments
      used to create the edge before it is swept.
    </description>
    <keyword>SWEEP</keyword>
    <keyword>cone</keyword>
    <keyword>truncated</keyword>
    <keyword>edge</keyword>
    <application/>
  </script>

  <script ID="661" category="Isolated Command" name="system01.inr" title="The SYSTEM Command">
    <description>
      Examples of how to store and
      retrieve system information.
    </description>
    <keyword>SYSTEM</keyword>
    <keyword>Geometry</keyword>
    <application/>
  </script>

  <script ID="662" category="Isolated Command" name="TABLE01.inr" title="Use of the TABLE command">
    <description>
      TABLE command with first element of Cooke Triplet
      Prints out a table of the current distribution data.
    </description>
    <keyword>TABLE</keyword>
    <keyword>triplet</keyword>
    <keyword>Analysis</keyword>
    <keyword>DISPLAY</keyword>
    <application/>
  </script>

  <script ID="663" category="Simple Problem" name="Talbot_Imaging_Grating_01.inr" title="Talbot Imaging Grating">
    <description>
      Talbot images are formed by gratings at multiples of
      a regular distance known as the Talbot length. An
      image is also formed at half the Talbot length, but
      phase-shifted by a half-period. The Talbot length,
      ZT=2*GP^2/WL, where
      GP is is the grating pitch, and
      WL is the wavelength
    </description>
    <keyword>Wave</keyword>
    <keyword>Talbot</keyword>
    <keyword>grating</keyword>
    <keyword>imaging</keyword>
    <keyword>beams</keyword>
    <keyword>FIELD</keyword>
    <keyword>periodic</keyword>
    <application/>
  </script>

  <script ID="664" category="Isolated Command" name="TERRAIN01.inr" title="Use of the TERRAIN command">
    <description>
      TERRAIN command with first element of Cooke Triplet
      Used alone, it gives the peak and valley statistics with
      FWHM at highest peak along a vertical slice of the data
      (as visualized in ASAP using DISPLAY; PICTURE) passing
      through the biased global maximum of the data.
    </description>
    <keyword>TERRAIN</keyword>
    <keyword>triplet</keyword>
    <keyword>Analysis</keyword>
    <keyword>DISPLAY</keyword>
    <application/>
  </script>

  <script ID="665" category="Simple Problem" name="Tetra_TUBE_ARRAY01.inr" title="ARRAY of Tetrahedral Prisms">
    <description>
      This example shows how to form tetrahedral prism
      structures as an arrayed surface. It involves two TUBE ARRAY
      structures to form the actual prisms, and another tube that
      is present only to bound the object to prevent artifacts
      from adjacent array rows. The ridge angle is formed by a
      SKEW operation on the ridge tube, and the back facet angle
      is formed by a SKEW operation on the back tube. A SCALE
      operation is also used on the ridge tube to narrow it
      relative to the square profile of the original tube.
      The array is shown in the 3D Viewer, first without
      the construction entities and then with them. This
      illustrates how the array is formed.
      The ARRAY ... SEARCH option is illustrated here as a way
      to make raytracing of such object more efficient. It
      restricts the intersection search to a subset of all rows.
      This can be important in very large arrays, especially in
      light pipes and guides. It must be used with due attention
      to the view factor of surrounding array rows, but it is
      very useful.  This example builds only a small array for demonstration
      purposes, but the technique may be extended to millions of
      elements. Note that the model has only three (3) objects,
      regardless of the number of repetitions of the elements.
    </description>
    <keyword>Geometry</keyword>
    <keyword>ARRAY</keyword>
    <keyword>SURFACE</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>tetrahedron</keyword>
    <keyword>prism</keyword>
    <keyword>backlight</keyword>
    <application/>
  </script>

  <script ID="666" category="Isolated Command" name="textfile01.inr" title="Outputing Formatted Display Data">
    <description>
      Create a text file of the data
      distribution from a SPOTS command. The file
      may be further formatted or can be a single
      column of numbers.
    </description>
    <keyword>TEXTFILE</keyword>
    <keyword>output</keyword>
    <keyword>data</keyword>
    <keyword>spreadsheet</keyword>
    <keyword>file</keyword>
    <keyword>formatting</keyword>
    <keyword>EOF</keyword>
    <application/>
  </script>

  <script ID="667" category="Isolated Command" name="textfile02.inr" title="Writing Out Display Data">
    <description>
      This file demonstrates the use of TEXTFILE to output
      formatted display data to a file. TEXTFILE has options for filtering
      and formatting the data and adding headers/footers to file.
    </description>
    <keyword>TEXTFILE</keyword>
    <keyword>output</keyword>
    <keyword>data</keyword>
    <keyword>spreadsheet</keyword>
    <keyword>file</keyword>
    <keyword>formatting</keyword>
    <application/>
  </script>

  <script ID="668" category="Isolated Command" name="TEXTFILE03.inr" title="Writing Out Display Data #3">
    <description>
      A modified version of example TEXTFILE02.INR illustrating
      both the output of DISPLAY flux data with spatial coordinates
      (file SPOTS2.TXT) and the same flux data arranged in a matrix
      corresponding to the physical two-dimensional plane of the
      measurement (file SPOTS3.TXT).
    </description>
    <keyword>TEXTFILE</keyword>
    <keyword>output</keyword>
    <keyword>data</keyword>
    <keyword>spreadsheet</keyword>
    <keyword>file</keyword>
    <keyword>formatting</keyword>
    <application/>
  </script>

  <script ID="669" category="Isolated Command" name="TEXTFILE04.inr" title="Writing Out Display Data #4">
    <description>
      A modified version of example TEXTFILE02.INR illustrating
      both the output of DISPLAY flux data with spatial coordinates
      (file SPOTS4.TXT) and slices of the same flux data arranged in columnar
      form corresponding to cuts along each physical dimension of the
      measurement (files SPOTS4X.TXT and SPOTS4Y.TXT).
    </description>
    <keyword>TEXTFILE</keyword>
    <keyword>output</keyword>
    <keyword>data</keyword>
    <keyword>spreadsheet</keyword>
    <keyword>file</keyword>
    <keyword>formatting</keyword>
    <keyword>REDUCE</keyword>
    <application/>
  </script>

  <script ID="670" category="Isolated Command" name="TEXTFILE05.inr" title="Default Formatting of TEXTFILE Output">
    <description>
      Create a text file of spots data
      to show default format of output file.
    </description>
    <keyword>TEXTFILE</keyword>
    <keyword>output</keyword>
    <keyword>data</keyword>
    <keyword>file</keyword>
    <keyword>formatting</keyword>
    <application/>
  </script>

  <script ID="671" category="Isolated Command" name="threshold01.inr" title="THRESHOLD Display Command">
    <description>
      Shows how to cut off data
      at a selected level to enhance other areas
      for plotting. In this example, by limiting
      the maximum value to 200, the lower data
      range is enhanced.
    </description>
    <keyword>THRESHOLD</keyword>
    <keyword>DISPLAY</keyword>
    <application/>
  </script>

  <script ID="672" category="Simple Problem" name="Tolerancing01.inr" title="Tolerancing with Scripts">
    <description>
      Lens with Gaussian variations of radius of curvature and
      position of one of the surfaces.
    </description>
    <keyword>Radiometry</keyword>
    <keyword>$ITER</keyword>
    <keyword>tolerancing</keyword>
    <keyword>$FCN</keyword>
    <application/>
  </script>

  <script ID="673" category="Simple Problem" name="TORIC_Lens_Bounding.inr" title="Make a toric lens by USERSAG and mutually bound with TUBE">
    <description>
      Creates a toric lens with a vertex radius
      and conic constant which vary azimuthally, and bounds with a TUBE
      to form an edge.
    </description>
    <keyword>Geometry</keyword>
    <keyword>conic</keyword>
    <keyword>lens</keyword>
    <keyword>TORIC</keyword>
    <keyword>USERSAG</keyword>
    <keyword>OPTICAL</keyword>
    <keyword>TUBE</keyword>
    <keyword>BOUNDS</keyword>
    <application/>
  </script>

  <script ID="674" category="Simple Problem" name="Torus_bounded.inr" title="Torus Cut with an Edge">
    <description>
      The following shows how to cut a wedge
      out of a TORUS surface between two angular positions.
      The EDGE POINTS command creates the triangular wedge of
      points which subtend a selected angle originating at
      the global origin. When the TORUS surface is bounded
      to this edge, a section of the torus is removed or
      remaining, depending on whether it was a plus or minus
      BOUNDS. Note that an edge mathematically extends forever
      perpendicular to its plane, and so will cut through the
      torus at any position in its path.
    </description>
    <keyword>Edges</keyword>
    <keyword>TORUS</keyword>
    <keyword>wedge</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>EDGES</keyword>
    <keyword>POINTS</keyword>
    <application/>
  </script>

  <script ID="675" category="Simple Problem" name="Torus_Elliptical.inr" title="Torus with Elliptical Cross-Section">
    <description>
      This shows how to make an elliptical torus
      with a circular cross-section.  A $DO loop creates 9 oval
      edges that define positions around the torus.  The second sysntax
      of the OBJECT command takes the last 9 edges and extrudes them
      along a circular path.
    </description>
    <keyword>Geometry</keyword>
    <keyword>torus</keyword>
    <keyword>macro</keyword>
    <keyword>EDGES</keyword>
    <keyword>OVAL</keyword>
    <keyword>OBJECT</keyword>
    <keyword>SMOOTH</keyword>
    <application/>
  </script>

  <script ID="676" category="Simple Problem" name="TOWARDS_EDGE_area01.inr" title="Emitting Towards a Ringed Region">
    <description>
      Using a diffuser to scatter towards an
      elliptical edge region within a ring. An emitter is defined
      which emits along the optical axis through a diffuser.  The
      diffuser kills off the specular rays and continues equivalent
      scatter rays towards a ring defined by the f and t parameters.
      This ring may define a region of baffles or vanes that need
      illuminated for study, this way avoiding tracing unwanted rays.
      It is shown how to temporarily stop the raytrace at the diffuser
      to re-establish the total flux at 100 in case that's required.
      Otherwise, ASAP will calculate the appropriate flux for that region
      based on the initial flux.
    </description>
    <keyword>Scatter</keyword>
    <keyword>MODELS</keyword>
    <keyword>SCATTER</keyword>
    <keyword>TOWARDS EDGE</keyword>
    <keyword>ring</keyword>
    <keyword>EDGES</keyword>
    <keyword>baffle</keyword>
    <keyword>vanes</keyword>
    <application/>
  </script>

  <script ID="677" category="Simple Problem" name="TOWARDS_SPEC_Options01.inr" title="Towards Spec Options">
    <description>
      Shows various options for entering scatter
      cone angle and direction. Selects each PATH for display
      by an assigned color.
    </description>
    <keyword>Scatter</keyword>
    <keyword>TOWARDS SPEC</keyword>
    <keyword>COLOR</keyword>
    <keyword>PATHS</keyword>
    <application/>
  </script>

  <script ID="678" category="Simple Problem" name="TOWARDS_TRAN_REFLECT_01.inr" title="Scatter with TOWARDS TRAN/REFLECT">
    <description>
      A demonstration of TOWARDS TRAN and TOWARDS REFL.
      Different scatter models are used for reflection and transmission.
      The transmitted scatter, Gaussian, goes into a narrow cone and shallow angle.
      The reflected scatter is Lambertian with a broader cone and steeper angle.
    </description>
    <keyword>Scatter</keyword>
    <keyword>SCATTER</keyword>
    <keyword>TOWARDS TRAN</keyword>
    <keyword>TOWARDS REFL</keyword>
    <keyword>PATHS</keyword>
    <keyword>TEXT</keyword>
    <keyword>SPLIT TRAN</keyword>
    <keyword>MODELS</keyword>
    <application/>
  </script>

  <script ID="679" category="Isolated Command" name="trace01.inr" title="TRACE Command Output">
    <description>
      Output generated from using TRACE
      with several modifiers. A trace is performed
      from the source to object 2, but without interaction
      with that object's interface (- sign). The "DIR 6"
      option lists every 6th ray (1 and 7 in this case),
      giving the objects intersected and directions at each
      interface.  The "PLOT 2" option plots every 2nd ray.
    </description>
    <keyword>TRACE</keyword>
    <keyword>Tracing</keyword>
    <keyword>warnings</keyword>
    <application/>
  </script>

  <script ID="680" category="Isolated Command" name="trace02.inr" title="TRACE Command Output">
    <description>
      Output generated from TRACE STATS.
      The total rays and flux on each object during the
      ray trace is printed, alongside the object's
      number, positional data, and name.
    </description>
    <keyword>TRACE</keyword>
    <keyword>Tracing</keyword>
    <keyword>STATS</keyword>
    <application/>
  </script>

  <script ID="681" category="Simple Problem" name="Trace_Continue.inr" title="Continuing Trace after Absorption">
    <description>
      This is the simplest method of
      continuing a trace after the rays have already  been absorbed on a surface.
      The rays are moved  off the absorbing object and the trace is continued.
      If necessary, you may need to use the CONSIDER ONLY
      command on the surface of interest and then use RAYS
      to bring up just those rays on that surface. Then
      perform the MOVE command to move those rays off that
      surface to continue tracing.
    </description>
    <keyword>Tracing</keyword>
    <keyword>MOVE</keyword>
    <keyword>BY</keyword>
    <keyword>rays</keyword>
    <keyword>TRACE</keyword>
    <application/>
  </script>

  <script ID="682" category="Simple Problem" name="Triplet_Ghost_Anal.inr" title="Ghost Analysis with Triplet Lens">
    <description>
      A Triplet lens system is used to demonstrate
      real ghost image analysis. Initially a plot of the lens system
      is shown with an on-axis and off-axis source. Then SPLIT
      is set to 2 and a single source is traced, while saving
      the history of the ray intersections along the way.
      Children and grandchildren rays are produced and generate
      alternate paths to the target.  Finally, the 1st six paths
      are plotted (in order of flux contribution), from historical
      data saved.
    </description>
    <keyword>Lenses</keyword>
    <keyword>ghost</keyword>
    <keyword>LENSES</keyword>
    <keyword>SEQUENCE</keyword>
    <keyword>triplet</keyword>
    <keyword>CUTOFF</keyword>
    <keyword>PATHS</keyword>
    <application/>
  </script>

  <script ID="683" category="Simple Problem" name="triplet_ghost_anal02.inr" title="Ghost Analysis with Triplet Lens #2">
    <description>
      A Triplet lens system is used to demonstrate
      real ghost image analysis. Initially a plot of the lens system
      is shown with an on-axis and off-axis source. Then SPLIT
      is set to 2 and a single source is traced.
      Children and grandchildren rays are produced and generate
      alternate paths to the target.  Finally, a spread function of
      imaged and ghost rays is performed showing radial
      distance using THE COLENGTH modifier or by SHAPEing the
      ghost rays first.
    </description>
    <keyword>Lenses</keyword>
    <keyword>ghost</keyword>
    <keyword>LENSES</keyword>
    <keyword>triplet</keyword>
    <keyword>SPREAD</keyword>
    <keyword>COLENGTH</keyword>
    <keyword>PATHS</keyword>
    <application/>
  </script>

  <script ID="684" category="Simple Problem" name="True_Helix.inr" title="A Real Helix Made with Extruded Ellipses">
    <description>
      This creates a real helix by extruding many equally spaced
      ellipses which are aligned perpendicular to a helical USERCURV curve.
    </description>
    <keyword>Geometry</keyword>
    <keyword>USERCURVE</keyword>
    <keyword>helix</keyword>
    <keyword>$FCN</keyword>
    <keyword>extrude</keyword>
    <keyword>curve</keyword>
    <keyword>OBJECT</keyword>
    <keyword>ALIGN</keyword>
    <keyword>PLACE</keyword>
    <application/>
  </script>

  <script ID="685" category="Simple Problem" name="Tubes_Intersecting.inr" title="Intersecting Tubes">
    <description>
      This makes a main tube with a smaller tube
      intersecting at 90° making something similar to an eyepiece
      port on a Newtonian telescope. A tube entity
      representing the real side tube uses SOLID MINUS to
      punch out the hole in the main tube, when bounded to it.
    </description>
    <keyword>Geometry</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>TUBE</keyword>
    <keyword>telescope</keyword>
    <keyword>LOCAL</keyword>
    <keyword>SOLID</keyword>
    <application/>
  </script>

  <script ID="686" category="Simple Problem" name="Tube_Sections.inr" title="Multiple Tube Sections as One Object">
    <description>
      This shows how to make multiple longitudinal sections
      of a tube in one $DO loop.  The $DO creates one straight line
      parallel to an axis and then repeats this line 6 times revolved
      around that axis, so that they are at 60° intervals. Once the loop
      is finished, a 5° SWEEP AXIS is performed on the edges around the same
      axis to produce the tube sections. This becomes only one object.
    </description>
    <keyword>Edges</keyword>
    <keyword>tube</keyword>
    <keyword>slices</keyword>
    <keyword>AXIS</keyword>
    <keyword>$DO</keyword>
    <keyword>SWEEP</keyword>
    <keyword>EDGES</keyword>
    <keyword>POINTS</keyword>
    <application/>
  </script>

  <script ID="687" category="Simple Problem" name="Tube_Side_Cutter.inr" title="Trapezoidal Hole in a Tube">
    <description>
      The following example cuts a trapezoid hole
      in one side of a tube surface by bounding an edge and a PLANE
      at the same time. The PLANE removes the back end of the tube
      while punching out a hole in the front end with EDGE; RECTANGLE.
      The EDGE; RECTANGLE has been previously scaled down at one end
      to make it trapezoidal.  Finally, the back half of the tube
      is brought back by bounding again with the PLANE surface.
    </description>
    <keyword>Edges</keyword>
    <keyword>BOUNDS</keyword>
    <keyword>TUBE</keyword>
    <keyword>hole</keyword>
    <keyword>cutting</keyword>
    <keyword>ASCALE</keyword>
    <keyword>SWEEP</keyword>
    <application/>
  </script>

  <script ID="688" category="Simple Problem" name="two_hole_baffle.inr" title="Two Hole Absorbing Baffle">
    <description>
      Simple demo of making a circular
      absorbing baffle with two offset holes.  Note
      that faceting could be a problem depending on
      relative hole sizes.  However, this does not mean
      the holes are not perfectly circular.  A high
      PIXEL count and further RENDERing will show the
      true shapes.
    </description>
    <keyword>Bounds</keyword>
    <keyword>baffle</keyword>
    <keyword>aperture</keyword>
    <application/>
  </script>

  <script ID="689" category="Simple Problem" name="Two_Wavelength_Interference.inr" title="Spatial Beats Produced by Wavelength Interference">
    <description>
      Demonstrate the capturing of beat phenomena as
      interference fringes along the propagation path (spatial beats).
      Create two sources with wavelengths of the sodium doublet
      (0.5890, 0.5896 um) at z=0, t=0, and measure the field energy
      at z=0 and at x=0, a slice along the wavefront propagation direction.
      Move the waves by one-half of a spatial beat and re-measure the
      superposed waves to show another instant in time.  Note that since
      ASAP is a time-independent code, the field will  exist at negative z
      locations for any evaluation. However, we can  displace the beam along
      its propagation path to simulate different instants in time,
      exhibiting displacement of the spatial beats.
    </description>
    <keyword>Wave</keyword>
    <keyword>interference</keyword>
    <keyword>beats</keyword>
    <keyword>fringes</keyword>
    <keyword>WAVELENGTHS</keyword>
    <application/>
  </script>

  <script ID="690" category="Simple Problem" name="twyman_green.inr" title="Twyman-Green Interferometer Analysis">
    <description>
      Single beam analysis of a Twyman-
      Green interferometer. Uses a single Gaussian
      beam to analyze a system. In this case the
      analysis is repeated by altering the beam shape
      from TEM00 to TEM10.
    </description>
    <keyword>Wave</keyword>
    <keyword>Twyman-Green</keyword>
    <keyword>diffraction</keyword>
    <keyword>Gaussian</keyword>
    <keyword>SHAPE</keyword>
    <application/>
  </script>

  <script ID="691" category="Simple Problem" name="undersampling_beams.inr" title="Undersampling with Too Few Beams">
    <description>
      Shows results of an undersampled mirror at
      focus. Compares a 9X9 grid to a 41X41 grid of beams.
    </description>
    <keyword>Wave</keyword>
    <keyword>SPREAD</keyword>
    <keyword>beams</keyword>
    <keyword>undersampling</keyword>
    <keyword>FOCUS</keyword>
    <application/>
  </script>

  <script ID="692" category="Simple Problem" name="Units_Label.inr" title="Flux Labeling with UNITS">
    <description>
      Shows an example of using the label
      option for the UNITS command.  It is only for
      plotting purposes and has no bearing on calculations.
    </description>
    <keyword>Scripts</keyword>
    <keyword>UNITS</keyword>
    <keyword>flux</keyword>
    <keyword>unit</keyword>
    <keyword>label</keyword>
    <application/>
  </script>

  <script ID="693" category="Simple Problem" name="unstable_resonator.inr" title="Confocal Unstable Resonator">
    <description>
      Confocal unstable resonator showing
      propagation of a complex beam shape.  Uses edge
      clipping for the field calculation and DECOMPOSE
      in POSITION. Allow some time to run. Note $IO pause below.
    </description>
    <keyword>Wave</keyword>
    <keyword>FIELD</keyword>
    <keyword>ENERGY</keyword>
    <keyword>CLIP</keyword>
    <keyword>DECOMPOSE</keyword>
    <keyword>SPREAD</keyword>
    <keyword>resonator</keyword>
    <application/>
  </script>

  <script ID="694" category="Isolated Command" name="USERAPOD_ANGLES.inr" title="Apodizing for Extended Source">
    <description>
      Apodizing an emitting spheroid  for an extended source.
      This is an example of using an external Usap3d file
      with a ".1" extension. It will not run this without
      such a file in the working directory. The data below
      may be used as an example.  Note, the first two numbers
      indicate the number of columns and rows, respectively.
      The first row is for azimuthal degrees, and the first column
      is polar degrees. The more data points there are, the better
      the interpolation.
    </description>
    <keyword>USERAPOD</keyword>
    <keyword>ANGLES</keyword>
    <keyword>EMITTING</keyword>
    <keyword>Sources</keyword>
    <keyword>apodizing</keyword>
    <application/>
  </script>

  <script ID="695" category="Isolated Command" name="USERAPOD_ANGLES_temp.inr" title="Apodizing for Extended Source">
    <description>
      Apodizing an emitting spheroid
      for an extended source.  This is an
      example of using an external Usap3d file
      with a ".1" extension. It will not run this without
      such a file in the working directory. The data below
      may be used as an example.  Note, the first two numbers
      indicate the number of columns and rows, respectively.
      The first row is for azimuthal degrees, and the first column
      is polar degrees. The more data points there are, the better
      the interpolation.
    </description>
    <keyword>USERAPOD</keyword>
    <keyword>ANGLES</keyword>
    <keyword>EMITTING</keyword>
    <keyword>Sources</keyword>
    <keyword>apodizing</keyword>
    <application/>
  </script>

  <script ID="696" category="Simple Problem" name="USERAPOD_BOTH.inr" title="Apodizing in Position and Direction with $FCN">
    <description>
      Demonstrates apodizing a source in position and
      direction with a user-defined function. Since the BOTH keyword
      is used, the function variables _1, _2, _3 represent positional
      values for x, y, z, and _4, _5, _6 are the direction cosines
      a, b, c, respectively. See comments below.
    </description>
    <keyword>Sources</keyword>
    <keyword>USERAPOD</keyword>
    <keyword>BOTH</keyword>
    <keyword>apodizing</keyword>
    <keyword>function</keyword>
    <keyword>$FCN</keyword>
    <keyword>EMITTING</keyword>
    <application/>
  </script>

  <script ID="697" category="Simple Problem" name="Userapod_Flux_Compare.inr" title="Turning USERAPOD On and Off">
    <description>
      Gives a comparison plot and stats of a simple
      grid source with and without a Gaussian USERAPOD applied.
    </description>
    <keyword>Sources</keyword>
    <keyword>USERAPOD</keyword>
    <keyword>flux</keyword>
    <keyword>Gaussian</keyword>
    <keyword>apodizing</keyword>
    <application/>
  </script>

  <script ID="698" category="Isolated Command" name="userapod_pos.inr" title="Positional Source Apodization">
    <description>
      Apodizing in position using an
      in-line expression or a table of data. In this
      example, both methods demonstrate an identical
      Gaussian-type apodization. The source without
      apodization is shown first.
    </description>
    <keyword>USERAPOD</keyword>
    <keyword>POSITION</keyword>
    <keyword>Sources</keyword>
    <keyword>apodizing</keyword>
    <keyword>Gaussian</keyword>
    <application/>
  </script>

  <script ID="699" category="Isolated Command" name="userbsdf01.inr" title="USERBSDF: A Phong-like Model">
    <description>
      Using a USERBSDF model to call
      a Phong function.
    </description>
    <keyword>USERBSDF</keyword>
    <keyword>$FCN</keyword>
    <keyword>Phong</keyword>
    <application/>
  </script>

  <script ID="700" category="Simple problem" name="USERBSDF02.inr" title="Dual-Peaked Scatter Model">
    <description>
      Using a USERBSDF model with a $FCN that produces
      a Harvey type scatter about the specular and the Normal.
    </description>
    <keyword>Scatter</keyword>
    <keyword>USERBSDF</keyword>
    <keyword>$FCN</keyword>
    <keyword>Harvey</keyword>
    <application/>
  </script>

  <script ID="701" category="Simple problem" name="USERBSDF03.inr" title="Angle-Dependent Harvey Model">
    <description>
      Define a Harvey function where the b and l
      parameters are a function of incident angle. the s parameter
    </description>
    <keyword>Scatter</keyword>
    <keyword>USERBSDF</keyword>
    <keyword>$FCN</keyword>
    <keyword>Harvey</keyword>
    <application/>
  </script>

  <script ID="702" category="Simple problem" name="USERBSDF04.inr" title="Dual-Peaked Henyey-Greenstein Scatter">
    <description>
      Shows a scatter model based on a
      Henyey-Greenstein function that peaks in both the
      specular and Normal directions. The $FCN is not based
      on any real data, but is loosely based on reported
      human reflectance behavior.
    </description>
    <keyword>Scatter</keyword>
    <keyword>USERBSDF</keyword>
    <keyword>$FCN</keyword>
    <keyword>MODELS</keyword>
    <application/>
  </script>

  <script ID="703" category="Simple problem" name="USERBSDF05.inr" title="Diffuser with Rectangular Scatter Pattern">
    <description>
      This uses a USERBSDF with a $FCN designed to
      limit the angular range to a rectangular pattern in direction space.
      In this case +/-15° in the alpha direction and +/-20° in the beta.
      Note that the commented out $FCN shows how to make this distribution
      using the ASAP RECT function.  The alternate $FCN, shows that the STEP
      function can perform the same task to make sharp corners, however the
      GAUS function was added here to round them out.
    </description>
    <keyword>Scatter</keyword>
    <keyword>USERBSDF</keyword>
    <keyword>$FCN</keyword>
    <keyword>diffuser</keyword>
    <keyword>math</keyword>
    <keyword>RECT</keyword>
    <keyword>STEP</keyword>
    <keyword>GAUS</keyword>
    <application/>
  </script>

  <script ID="704" category="Simple problem" name="USERBSDF06.inr" title="Creating an Isotropic Scatter Surface">
    <description>
      This uses a USERBSDF with a $FCN designed to
      create a isotropic scatter interface.  It compares this to
      a standard Lambertian result.
    </description>
    <keyword>Scatter</keyword>
    <keyword>USERBSDF</keyword>
    <keyword>$FCN</keyword>
    <keyword>isotropic</keyword>
    <keyword>MODELS</keyword>
    <keyword>Lambertian</keyword>
    <application/>
  </script>

  <script ID="705" category="Simple problem" name="USERBSDF07.INR" title="Truncated Harvey Model">
    <description>
      Define a Harvey which is band limited --
      In other words, there is a minimum and maximum value for
      q= sin(theta)-sin(theta') beyond which the BRDF is zero.
      Here, theta is the polar angle of the specular beam and
      theta' is that of the scattered beam. In this model, the
      light is scattered into a ring around the specular direction.
      This technique might be used to study the effect of scattering
      from a lens surface in detail. Due to the very narrow band
      cutoff, the individual BSDF plot files are best displayed
      with the PICTURE viewer.
    </description>
    <keyword>Scatter</keyword>
    <keyword>USERBSDF</keyword>
    <keyword>$FCN</keyword>
    <keyword>Harvey</keyword>
    <application/>
  </script>

  <script ID="706" category="Simple problem" name="USERBSDF08.INR" title="BSDF Model for Asymmetrical Gaussian">
    <description>
      Example showing the default anisotropic Gaussian
      scatter model (USERANIS) referred to in Online Help under
      USERBSDF. See third Remark under the heading Anisotropic-Surface
      Scatter Models.  The widths given for alpha and beta directions
      are different in order to make an asymmetrical Gaussian dispersion.
    </description>
    <keyword>Scatter</keyword>
    <keyword>USERBSDF</keyword>
    <keyword>USERANIS</keyword>
    <keyword>anisotropic</keyword>
    <keyword>Gaussian</keyword>
    <keyword>asymmetric</keyword>
    <application/>
  </script>

  <script ID="707" category="Simple Problem" name="usercurv01.inr" title="Making a Curve with a Function">
    <description>
      Making an edge based on a user-defined function
      using USERCURVE. This command calls the $FCN to produce the
      curve. The edge in this example takes on the form of the
      sine-wave function. It is then swept into a ribbon-like surface.
    </description>
    <keyword>Edges</keyword>
    <keyword>USERCURVE</keyword>
    <keyword>$FCN</keyword>
    <keyword>LIMITS</keyword>
    <keyword>curve</keyword>
    <keyword>SWEEP</keyword>
    <application/>
  </script>

  <script ID="708" category="Isolated Command" name="usercurv02.inr" title="Two USERCURVE Surfaces">
    <description>
      Using USERCURVE to make two very different
      type of surfaces. The first USERCURVE passes a user
      parameter (_) range to the function using 100 segments
      and SMOOTH applied to make a bumpy circle. The second
      passes polar and azimuth coordinate ranges (_1 &amp; _2)
      with only 6 segments each to make a rough sphere.
    </description>
    <keyword>USERCURVE</keyword>
    <keyword>$FCN</keyword>
    <application/>
  </script>

  <script ID="709" category="Isolated Command" name="USERCURV03.inr" title="Swept Hyperbolic Curve">
    <description>
      Create a hyperbolic curve with $FCN and USERCURVE.
      Hyperbola centered on Y axis.
      Transverse and conjugate axes specified.
    </description>
    <keyword>USERCURVE</keyword>
    <keyword>$FCN</keyword>
    <keyword>hyperbolic</keyword>
    <keyword>curve</keyword>
    <keyword>SWEEP</keyword>
    <application/>
  </script>

  <script ID="710" category="Isolated Command" name="USERCURV04.inr" title="Swept Parabolic Curve">
    <description>
      Create a parabolic curve with $FCN and USERCURVE.
      Distance from vertex to focus specified.
    </description>
    <keyword>USERCURVE</keyword>
    <keyword>$FCN</keyword>
    <keyword>parabolic</keyword>
    <keyword>curve</keyword>
    <keyword>SWEEP</keyword>
    <application/>
  </script>

  <script ID="711" category="Isolated Command" name="USERCURV05.inr" title="Swept Eliptical Curve">
    <description>
      Create an elliptical curve with $FCN and USERCURVE.
      Semi-major and semi-minor axes specified.
      Center at (H,K).
    </description>
    <keyword>USERCURVE</keyword>
    <keyword>$FCN</keyword>
    <keyword>elliptical</keyword>
    <keyword>curve</keyword>
    <keyword>SWEEP</keyword>
    <application/>
  </script>

  <script ID="712" category="Isolated Command" name="USERCURV06.inr" title="Swept User Curve about Axis">
    <description>
      Create a user curve with an 8th order $FCN
      and sweep about an axis. See USERCURV07.INR for Sweep in direction.
    </description>
    <keyword>USERCURV</keyword>
    <keyword>$FCN</keyword>
    <keyword>curve</keyword>
    <keyword>SWEEP</keyword>
    <keyword>Edges</keyword>
    <application/>
  </script>

  <script ID="713" category="Isolated Command" name="USERCURV07.inr" title="Swept User Curve in Direction">
    <description>
      Create a user curve with an 8th order $FCN
      and sweep in direction.
    </description>
    <keyword>USERCURV</keyword>
    <keyword>$FCN</keyword>
    <keyword>curve</keyword>
    <keyword>SWEEP</keyword>
    <keyword>Edges</keyword>
    <application/>
  </script>

  <script ID="714" category="Simple Problem" name="Userfunc_Fcn.inr" title="Surface Defined by a Function">
    <description>
      A surface made by a user-defined function.
      The command USERFUNC is used to call the $FCN.  In this case,
      the surface takes on the form of the sine-wave function.
    </description>
    <keyword>Geometry</keyword>
    <keyword>USERFUNC</keyword>
    <keyword>$FCN</keyword>
    <keyword>PARAMETERIZE</keyword>
    <keyword>LOCAL</keyword>
    <application/>
  </script>

  <script ID="715" category="Simple Problem" name="USERSAG_TORIC_LENS.inr" title="Make a toric lens by USERSAG and compare to reference conics">
    <description>
      Creates a toric lens with a vertex radius
      and conic constant which vary azimuthally.
    </description>
    <keyword>Geometry</keyword>
    <keyword>conic</keyword>
    <keyword>lens</keyword>
    <keyword>TORIC</keyword>
    <keyword>USERSAG</keyword>
    <keyword>OPTICAL</keyword>
    <application/>
  </script>

  <script ID="716" category="Simple Problem" name="USERSAG_VS_OPTICAL01.inr" title="Comparing USERSAG with OPTICAL">
    <description>
      Example examining OPTICAL (no EXPAND) and USERSAG
      representations of an aspheric surface above 10th order.
      Surface maps and their cross-sections are used to compare
      the representations. A user-calculated sag table, and
      the sag table created by the OPTICAL command for surfaces
      above 10th order, are stored in a file called SAGTABLE.TXT.
      Coefficients were chosen to make an interesting,
      though not necessarily useful, surface.
    </description>
    <keyword>Geometry</keyword>
    <keyword>USERSAG</keyword>
    <keyword>OPTICAL</keyword>
    <keyword>$FCN</keyword>
    <keyword>$ITER</keyword>
    <application/>
  </script>

  <script ID="717" category="Simple Problem" name="USERSAG_VS_OPTICAL02.inr" title="Comparing USERSAG with OPTICAL...EXPAND">
    <description>
      Example examining OPTICAL, OPTICAL ... EXPAND,
      and USERSAG representations of an aspheric surface above 10th order.
      Surface maps and their cross-sections are used to compare
      the representations. A user-calculated sag table, and
      the sag table created by the OPTICAL command for surfaces
      above 10th order, are stored in a file called SAGTABLE.TXT.
      Coefficients were chosen to make an interesting,
      though not necessarily useful, surface.
    </description>
    <keyword>Geometry</keyword>
    <keyword>USERSAG</keyword>
    <keyword>OPTICAL</keyword>
    <keyword>$FCN</keyword>
    <keyword>$ITER</keyword>
    <keyword>EXPAND</keyword>
    <application/>
  </script>

  <script ID="718" category="Simple Problem" name="user_display.inr" title="User-defined Display File">
    <description>
      Creating a user-defined complex
      distribution file to be stored in BRO029.DAT.
      File is not complete and may not be run as shown.
    </description>
    <keyword>Radiometry</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>distribution</keyword>
    <keyword>FIELD</keyword>
    <keyword>ENERGY</keyword>
    <application/>
  </script>

  <script ID="719" category="Isolated Command" name="values.inr" title="VALUES Display Command">
    <description>
      Shows functional values of
      current distribution data. Actual coordinates
      are supplied to retrieve values. Example
      output is shown. This is not a run-able file.
    </description>
    <keyword>VALUES</keyword>
    <keyword>DISPLAY</keyword>
    <application/>
  </script>

  <script ID="720" category="Isolated Command" name="VERSION.inr" title="VERSION Command">
    <description>Command to check ASAP version in use.</description>
    <keyword>VERSION</keyword>
    <keyword>revision</keyword>
    <application/>
  </script>

  <script ID="721" category="Isolated Command" name="VIOLATION_01.inr" title="Setting Paraxial Departure Levels with VIOLATION">
    <description>
      Setting paraxial departure warnings to
      other than default .1 waves with 1 wave termination.
      Source is set up to force paraxial invariant errors when
      calcualting a FIELD in order to demonstrate VIOLATION options.
    </description>
    <keyword>VIOLATION</keyword>
    <keyword>paraxial departure</keyword>
    <keyword>FIELD</keyword>
    <application/>
  </script>

  <script ID="722" category="Simple Problem" name="Virtual_Image01.inr" title="Finding Virtual Image of Extended Source">
    <description>
      How to find a virtual image of an
      extended source. A virtual image is found by first
      tracing a point source from the object (source)
      plane to locate the image, then the image is
      produced by tracing the extended object (source)
      itself, then moving the rays to the image location
      found using the point source trace.
      The virtual image is shown as a spot diagram
      in the 3D Viewer, along with the geometry and
      extended-source trace.
    </description>
    <keyword>Tracing</keyword>
    <keyword>Sources</keyword>
    <keyword>virtual</keyword>
    <keyword>image</keyword>
    <application/>
  </script>

  <script ID="723" category="Simple Problem" name="Volume_Data_Export_01.inr" title="Exporting VOXELS Volume Data to File">
    <description>
      How to output VOXEL absorption data to
      a single text file.  This will work for any volume distribution
      or 3D distribution that contains multiple 2D slices.
      This example takes the standard example, VOXELS_ABSORBED01.INR,
      as a starting point, and outputs the VOXELS ABSORBED data to a
      text file for further use by an external program. The data are
      output using a continued TEXTFILE command in DISPLAY mode,
      toggling out of TEXTFILE mode to load each VOXEL plane in turn,
      then resuming TEXTFILE output.
      Header lines are provided to identify the coordinates and
      their respective ranges, but these might be omitted or
      converted to appropriate comment lines to allow them to be
      read by another application or environment.
    </description>
    <keyword>Analysis</keyword>
    <keyword>TEXTFILE</keyword>
    <keyword>VOXELS</keyword>
    <keyword>volume</keyword>
    <keyword>data</keyword>
    <keyword>output</keyword>
    <keyword>text</keyword>
    <keyword>file</keyword>
    <keyword>export</keyword>
    <application/>
  </script>

  <script ID="724" category="Simple Problem" name="VOLUME_MIE_Multi-Peaked_Scatter_01.inr" title="Multi-Peaked Mie Scatter">
    <description>
      This example builds on a previous example (Volume_Scatter02.inr)
      substituting three RECT peaks with distinct particle size ranges using a $FCN.
      The particle sizes are defined in waves; each peak's particle size, variation,
      and volume density are used to determine its Fobs, which in turn is used to
      weight its peak as a component of the overall distribution with its overall Fobs,
      the sum of all the sub-Fobs. This is a starting point for investigating the value
      of such a summed model. It is presented without regard to its accuracy or
      correctness, which would require real data. Some intuitive exploration is
      possible by altering individual peaks and seeing how they interact.
    </description>
    <keyword>Scatter</keyword>
    <keyword>MIE</keyword>
    <keyword>MODELS</keyword>
    <keyword>VOLUME</keyword>
    <keyword>VOXELS FLUENCE</keyword>
    <keyword>$FCN</keyword>
    <keyword>$EVAL</keyword>
    <application/>
  </script>

  <script ID="725" category="Simple Problem" name="volume_scatter01.inr" title="Volume Scatter">
    <description>
      Demonstrates Monte Carlo volume scatter using
      the simple Henyey-Greenstein model. The model is referenced
      by the Media SCATTER option. A VOXELS FLUENCE
      distribution file is created and displayed in the 3-d viewer,
      with geometry.
    </description>
    <keyword>Interfaces</keyword>
    <keyword>Scatter</keyword>
    <keyword>MODELS</keyword>
    <keyword>VOLUME</keyword>
    <keyword>VOXELS</keyword>
    <keyword>FLUENCE</keyword>
    <application/>
  </script>

  <script ID="726" category="Simple Problem" name="Volume_Scatter02.inr" title="Volume Mie Scatter">
    <description>
      Demonstrates Monte Carlo volume scatter
      using the Mie model. The model is referenced by the
      Media SCATTER option. A VOXELS FLUENCE distribution file
      is created and displayed in the 3-d viewer, with geometry.
    </description>
    <keyword>Interfaces</keyword>
    <keyword>Scatter</keyword>
    <keyword>MODELS</keyword>
    <keyword>VOLUME</keyword>
    <keyword>VOXELS</keyword>
    <keyword>FLUENCE</keyword>
    <application/>
  </script>

  <script ID="727" category="Simple Problem" name="Volume_Scatter_Inhomogeneous_01.inr" title="Inhomogeneous Volume Scattering">
    <description>
      Using user-defined functions ($FCN and USERFUNC) to modify
      scattering and absorption properties of a volume in order to simulate
      spatially varying scattering and absorption behavior.  The homogeneous
      scattering and absorption properties are modified point-by-point using
      the weighting factors defined by the user-defined functions (via the MEDIA;
      SCATTER option.
    </description>
    <keyword>Scatter</keyword>
    <keyword>$FCN</keyword>
    <keyword>USERFUNC</keyword>
    <keyword>MEDIA</keyword>
    <keyword>inhomogeneous</keyword>
    <keyword>absorption</keyword>
    <keyword>volume</keyword>
    <keyword>VOLUME</keyword>
    <application/>
  </script>

  <script ID="728" category="Simple Problem" name="VOXELS_ABSORBED01.inr" title="Volume Absorption">
    <description>
      Demonstrates how to capture a 3-D
      representation of the energy absorbed within a volume.
      The VOXELS command specifies the range and resolution
      over which this energy is captured. In this case, the
      volume matches the space between the Front and Back
      surfaces of a complex absorbing medium. The 3-D
      viewer is used to visualize the volume file. See
      comments below.
    </description>
    <keyword>Interfaces</keyword>
    <keyword>MEDIA</keyword>
    <keyword>ABSORBED</keyword>
    <keyword>VOXELS</keyword>
    <keyword>volume</keyword>
    <application/>
  </script>

  <script ID="729" category="Simple Problem" name="VOXELS_Emission01.inr" title="Re-emission of an Absorption Volume">
    <description>
      How to capture a 3-D representation
      of absorption within a volume and use it to
      create an emitting source. The VOXELS command
      specifies the range and resolution over which this
      energy is captured. In this case, the volume matches
      the space between the Front and Back surfaces of a
      complex absorbing medium. The volume file is saved
      and turned into an emitting source using the
      EMITTING DATA command. This could be used to
      simulate fluorescence or other emission related
      phenomena. The 3-D viewer is used to visualize both
      the volume absorption file and volume source.
    </description>
    <keyword>Interfaces</keyword>
    <keyword>MEDIA</keyword>
    <keyword>ABSORBED</keyword>
    <keyword>VOXELS</keyword>
    <keyword>volume</keyword>
    <keyword>emission</keyword>
    <keyword>fluorescence</keyword>
    <application/>
  </script>

  <script ID="730" category="Simple Problem" name="VOXELS_Emission02.inr" title="Re-emission of a Spherical Absorbing Volume">
    <description>
      How to capture a 3-D representation
      of absorption within a spherical volume and use it to
      create an emitting source. This is a modification of the
      VOXELS_EMISSION01.INR for a spherical absorber.
      The VOXELS command specifies the range and resolution
      over which this energy is captured. In this case, the
      volume matches the space between the Front and Back
      surfaces of a complex absorbing medium. However, the
      voxel volume is square and the absorber is spherical.
      This would cause the re-emitted source to have rays
      outside the original sphere due to the cubic voxels.
      This can be seen by unchecking the box in the $SCR dialog.
      Therefore, a similar bounding sphere is made slightly
      smaller than the absorbing sphere to be used to trim off
      any unwanted rays from the new source.
      The effect may be easier to see by making the bounding
      sphere much smaller, using the dialog.
      The bounding must be applied before turning the saved
      absorption file into an emitting source using the
      EMITTING DATA command. This could be used to
      simulate fluorescence or other emission related
      phenomena from a spherical absorber.
    </description>
    <keyword>Interfaces</keyword>
    <keyword>MEDIA</keyword>
    <keyword>ABSORBED</keyword>
    <keyword>VOXELS</keyword>
    <keyword>volume</keyword>
    <keyword>emission</keyword>
    <keyword>fluorescence</keyword>
    <application/>
  </script>

  <script ID="731" category="Simple Problem" name="VOXELS_FLUENCE01.inr" title="Capturing Fluence Energy of a Focused Beam">
    <description>
      How to capture a 3-D representation
      of energy fluence within any volume space along
      the path of a trace. The VOXELS command specifies
      the region of fluence capture. In this case,
      a section of space at the end of a focused beam.
      Note when using the FLUENCE option, the traced
      rays must actually travel to a point beyond the
      VOXELS distribution volume. This is the reason
      for the detector plane. The 3-D viewer is used to
      visualize the geometry and the volume file.
      Finally, the volume fluence data was turned into
      a 3D volume source to show a crude example of
      making your own emitting cone.
    </description>
    <keyword>Interfaces</keyword>
    <keyword>VOXELS</keyword>
    <keyword>FLUENCE</keyword>
    <keyword>volume</keyword>
    <keyword>emission</keyword>
    <application/>
  </script>

  <script ID="732" category="Isolated Command" name="WARNINGS01.inr" title="Use of the WARNINGS command">
    <description>WARNINGS command with first element of Cooke Triplet</description>
    <keyword>WARNINGS</keyword>
    <application/>
  </script>

  <script ID="733" category="Simple Problem" name="wavefront_decompose.inr" title="Aberrated Wavefront Decomposition">
    <description>
      A perturbed wavefront decomposed by the COMBINE
      command. A grid source is perturbed by a Zernike surface
      function. A display file of the wavefront map is created
      which is then radially averaged. The COMBINE command
      produces a differential plot of the two.
    </description>
    <keyword>Radiometry</keyword>
    <keyword>ZERNIKE</keyword>
    <keyword>COMBINE</keyword>
    <keyword>OPDMAP</keyword>
    <keyword>SOURCE WAVEFUNC</keyword>
    <keyword>aberrated</keyword>
    <keyword>AVERAGE</keyword>
    <application/>
  </script>

  <script ID="734" category="Isolated Command" name="wavelen01.inr" title="Defining Wavelengths">
    <description>
      How to define wavelengths.
      Three methods of defining wavelengths
      are given.
    </description>
    <keyword>WAVELENGTHS</keyword>
    <keyword>UNITS</keyword>
    <application/>
  </script>

  <script ID="735" category="Simple Problem" name="Wavelength_Change.inr" title="Changing a Dump File Wavelength">
    <description>
      Shows how to change the wavelength on
      a DUMP dile used as a new source.  Simply specify
      the new wavelength before creating the source with
      EMITTING DATA.
    </description>
    <keyword>Tracing</keyword>
    <keyword>WAVELENGTH</keyword>
    <keyword>EMITTING</keyword>
    <keyword>DUMP</keyword>
    <keyword>GET</keyword>
    <application/>
  </script>

  <script ID="736" category="Isolated Command" name="write01.inr" title="Saving Display Files">
    <description>
      Three examples of saving display
      files with WRITE.
    </description>
    <keyword>WRITE</keyword>
    <keyword>DISPLAY</keyword>
    <keyword>output</keyword>
    <application/>
  </script>

  <script ID="737" category="Isolated Command" name="XEQ01.inr" title="Using XEQ for Immediate Matrix Transformation">
    <description>
      Using XEQ to apply an immediate
      matrix transformation.
    </description>
    <keyword>XEQ</keyword>
    <keyword>MATRIX</keyword>
    <keyword>Manipulating</keyword>
    <application/>
  </script>

  <script ID="738" category="Simple Problem" name="Youngs_Double_Slit.inr" title="Young's Double-slit Diffraction">
    <description>
      Typical Young's double slit diffraction experiment with no lenses,
      viewed in the far field.
    </description>
    <keyword>Wave</keyword>
    <keyword>Young</keyword>
    <keyword>diffraction</keyword>
    <keyword>slit</keyword>
    <keyword>FIELD</keyword>
    <keyword>ENERGY</keyword>
    <keyword>DECOMPOSE</keyword>
    <keyword>CLIP</keyword>
    <keyword>SUBSET</keyword>
    <keyword>FTSIZE</keyword>
    <application/>
  </script>

  <script ID="739" category="Simple Problem" name="Zernike_Deform.inr" title="Deforming with a Zernike Surface">
    <description>
      A demonstration of the use of the DEFORM
      command to deform another surface with a Zernike
      polynomial surface. A flat plane surface is used here
      to represent a more complex surface. Certainly, in this
      case, there would be no reason for the deform, since the
      Zernike surface itself could be made into an object and
      perform in the same way.
    </description>
    <keyword>Geometry</keyword>
    <keyword>DEFORM</keyword>
    <keyword>ZERNIKE</keyword>
    <keyword>SCALE</keyword>
    <application/>
  </script>

  <script ID="740" category="Simple Problem" name="Zernike_Surface.inr" title="Making a Zernike Surface">
    <description>
      Demonstrates the use of ZERNIKE surface in
      a Twyman-Green interferometer. Coefficients are applied
      that deform the surface with Piston, Defocus and Spherical
      deformations combined.
    </description>
    <keyword>Geometry</keyword>
    <keyword>ZERNIKE</keyword>
    <keyword>Twyman-Green</keyword>
    <keyword>deformation</keyword>
    <keyword>diffraction</keyword>
    <keyword>PICTURE</keyword>
    <application/>
  </script>

  <script ID="741" category="JScript Examples" name="Fiber_Tapered.js" title="Tapered Fiber as One Object" SubDir="JScript">
    <description>
      This creates a tapered fiber as one object
      using a set of EDGE POINTS at equal angular separation,
      which are extruded together using the second form of  the OBJECT command.
      Note that the corners of the taper can have a tendency
      to leak if rays hit there exactly on axis from a grid.  Avoid this by using a random set of rays.
    </description>
    <keyword>Edges</keyword>
    <keyword>fiber</keyword>
    <keyword>taper</keyword>
    <keyword>EDGES</keyword>
    <keyword>POINTS</keyword>
    <keyword>OBJECT</keyword>
  </script>

  <script ID="742" category="JScript Examples" name="GetSet.js" title="Get Set Example" SubDir="JScript">
    <description>
      Methods for getting and setting variables
      between the kernel and script languages
    </description>
    <keyword>JScript</keyword>
    <keyword>GET</keyword>
    <keyword>EMITTING</keyword>
    <application/>
  </script>

  <script ID="743" category="JScript Examples" name="group02.js" title="Grouping Objects for Shifting/Rotating" SubDir="JScript">
    <description>
      Select groups of objects to
      shift and/or rotate. Nine elliptical surfaces
      are created. The first 3 are shifted and rotated.
      The second 3 are shifted and rotated. The last 3
      are shifted. The plot shows the before and after.
    </description>
    <keyword>JScript</keyword>
    <keyword>GROUP</keyword>
    <keyword>Manipulating</keyword>
    <application/>
  </script>

  <script ID="744" category="JScript Examples" name="lens_array01.js" title="A Discrete Lens Array" SubDir="JScript">
    <description>
      A micro-lens array with discrete lens
      objects using nested macro/do loops. This is better
      performed with bounding and using the ARRAY command.
    </description>
    <keyword>JScript</keyword>
    <keyword>Macros_user</keyword>
    <keyword>Arrays</keyword>
    <keyword>lenslet</keyword>
    <keyword>macro</keyword>
    <application/>
  </script>

  <script ID="745" category="JScript Examples" name="Literal_Passing02.js" title="Passing Variables to Plot Titles" SubDir="JScript">
    <description>
      Passing variables to plot titles using the LIT
      operator and a macro.
    </description>
    <keyword>JScript</keyword>
    <keyword>Scripts</keyword>
    <keyword>literal</keyword>
    <keyword>string</keyword>
    <keyword>variable</keyword>
    <keyword>macro</keyword>
    <keyword>plot</keyword>
    <keyword>title</keyword>
    <application/>
  </script>

  <script ID="746" category="JScript Examples" name="points01.js" title="POINTS and Weighting" SubDir="JScript">
    <description>
      Shows the effect of varying
      weighting factors and control vertices.
    </description>
    <keyword>JScript</keyword>
    <keyword>POINTS</keyword>
    <keyword>EDGES</keyword>
    <application/>
  </script>

  <script ID="747" category="JScript Examples" name="source_wave01.js" title="SOURCE WAVEFUNC Example" SubDir="JScript">
    <description>
      Allows defining the source
      point of rays in a grid to start from a
      wavefront surface defined by a surface function.
      In this example, the rays in the grid are moved
      along Z to the nearest point on the wavefront
      surface made with the OPTICAL command.
    </description>
    <application/>
    <keyword>JScript</keyword>
    <keyword>SOURCE</keyword>
    <keyword>WAVEFUNC</keyword>
  </script>

  <script ID="748" category="VBScript Examples" name="Fiber_Tapered.vbs" title="Tapered Fiber as One Object" SubDir="VBScript">
    <description>
      This creates a tapered fiber as one object using a set
      of EDGE POINTS at equal angular separation, which
      are extruded together using the second form of the
      OBJECT command. Note that the corners of the taper
      can have a tendency to leak if rays hit there exactly
      on axis from a grid. Avoid this by using a random set of rays.
    </description>
    <keyword>JScript</keyword>
    <keyword>Edges</keyword>
    <keyword>fiber</keyword>
    <keyword>taper</keyword>
    <keyword>EDGES</keyword>
    <keyword>POINTS</keyword>
    <keyword>OBJECT</keyword>
    <application/>
  </script>

  <script ID="749" category="VBScript Examples" name="GetSet.vbs" title="Get Set Example" SubDir="VBScript">
    <description>Methods for getting and setting variables between the kernel and script languages</description>
    <keyword>JScript</keyword>
    <keyword>GET</keyword>
    <keyword>EMITTING</keyword>
    <application/>
  </script>

  <script ID="750" category="VBScript Examples" name="group02.vbs" title="Grouping Objects for Shifting/Rotating" SubDir="VBScript">
    <description>
      Select groups of objects to shift and/or rotate.
      Nine elliptical surfaces are created. The first 3 are
      shifted and rotated. The second 3 are shifted and rotated.
      The last 3 are shifted. The plot shows the before and after.
    </description>
    <keyword>VBScript</keyword>
    <keyword>GROUP</keyword>
    <keyword>Manipulating</keyword>
    <application/>
  </script>

  <script ID="751" category="VBScript Examples" name="lens_array01.vbs" title="A Discrete Lens Array" SubDir="VBScript">
    <description>
      A micro-lens array with discrete lens objects using nested macro/do loops.
      This is better performed with bounding and using the ARRAY command.
    </description>
    <keyword>VBScript</keyword>
    <keyword>Macros_user</keyword>
    <keyword>Arrays</keyword>
    <keyword>lenslet</keyword>
    <keyword>macro</keyword>
    <application/>
  </script>

  <script ID="752" category="VBScript Examples" name="Literal_Passing02.vbs" title="Passing Variables to Plot Titles" SubDir="VBScript">
    <description>Passing variables to plot titles using the LIT operator and a macro.</description>
    <keyword>VBScript</keyword>
    <keyword>Scripts</keyword>
    <keyword>literal</keyword>
    <keyword>string</keyword>
    <keyword>variable</keyword>
    <keyword>macro</keyword>
    <keyword>plot</keyword>
    <keyword>title</keyword>
    <application/>
  </script>

  <script ID="753" category="VBScript Examples" name="points01.vbs" title="POINTS and Weighting" SubDir="VBScript">
    <description>Shows the effect of varying weighting factors and control vertices.</description>
    <keyword>VBScript</keyword>
    <keyword>POINTS</keyword>
    <keyword>EDGES</keyword>
    <application/>
  </script>

  <script ID="754" category="VBScript Examples" name="Source_Bulb_Fluor_Str.vbs" title="Straight Fluorescent Tube" SubDir="VBScript">
    <description>
      This example shows a simple straight fluorescent
      tube using a volume emitting source at center
      which is the length of the tube.  An inner tube
      surrounds this emitter whose surface properties
      are set up so that only the scattered rays get
      through and no specular rays. This simulates a
      plasma. Two macros are used, one calling another,
      to create the ends of the tube.
    </description>
    <keyword>VBScript</keyword>
    <keyword>Sources</keyword>
    <keyword>Fluorescent</keyword>
    <keyword>bulb</keyword>
    <keyword>EMITTING CONE</keyword>
    <keyword>RACETRACK</keyword>
    <keyword>SCATTER</keyword>
    <keyword>random</keyword>
    <keyword>SUBSET</keyword>
    <application/>
  </script>

  <script ID="755" category="VBScript Examples" name="source_wave01.vbs" title="SOURCE WAVEFUNC Example" SubDir="VBScript">
    <description>
      Allows defining the source point of rays
      in a grid to start from a wavefront
      surface defined by a surface function.
      In this example, the rays in the grid are
      moved along Z to the nearest point on the
      wavefront surface made with the OPTICAL command.
    </description>
    <keyword>VBScript</keyword>
    <keyword>SOURCE</keyword>
    <keyword>WAVEFUNC</keyword>
    <application/>
  </script>


  <script ID="756" category="Python Examples" name="Fiber_Tapered.py" title="Tapered Fiber as One Object" SubDir="Python">
    <description>
      This creates a tapered fiber as one object using a set
      of EDGE POINTS at equal angular separation, which
      are extruded together using the second form of the
      OBJECT command. Note that the corners of the taper
      can have a tendency to leak if rays hit there exactly
      on axis from a grid. Avoid this by using a random set of rays.
    </description>
    <keyword>Python</keyword>
    <keyword>Edges</keyword>
    <keyword>fiber</keyword>
    <keyword>taper</keyword>
    <keyword>EDGES</keyword>
    <keyword>POINTS</keyword>
    <keyword>OBJECT</keyword>
    <application/>
  </script>

  <script ID="757" category="Python Examples" name="GetSet.py" title="Get Set Example" SubDir="Python">
    <description>Methods for getting and setting variables between the kernel and script languages</description>
    <keyword>Python</keyword>
    <keyword>GET</keyword>
    <keyword>EMITTING</keyword>
    <application/>
  </script>

  <script ID="758" category="Python Examples" name="group02.py" title="Grouping Objects for Shifting/Rotating" SubDir="Python">
    <description>
      Select groups of objects to shift and/or rotate.
      Nine elliptical surfaces are created. The first 3 are
      shifted and rotated. The second 3 are shifted and rotated.
      The last 3 are shifted. The plot shows the before and after.
    </description>
    <keyword>Python</keyword>
    <keyword>GROUP</keyword>
    <keyword>Manipulating</keyword>
    <application/>
  </script>

  <script ID="759" category="Python Examples" name="lens_array01.py" title="A Discrete Lens Array" SubDir="Python">
    <description>
      A micro-lens array with discrete lens objects using nested macro/do loops.
      This is better performed with bounding and using the ARRAY command.
    </description>
    <keyword>Python</keyword>
    <keyword>Macros_user</keyword>
    <keyword>Arrays</keyword>
    <keyword>lenslet</keyword>
    <keyword>macro</keyword>
    <application/>
  </script>

  <script ID="760" category="Python Examples" name="Literal_Passing02.py" title="Passing Variables to Plot Titles" SubDir="Python">
    <description>Passing variables to plot titles using the LIT operator and a macro.</description>
    <keyword>Python</keyword>
    <keyword>Scripts</keyword>
    <keyword>literal</keyword>
    <keyword>string</keyword>
    <keyword>variable</keyword>
    <keyword>macro</keyword>
    <keyword>plot</keyword>
    <keyword>title</keyword>
    <application/>
  </script>

  <script ID="761" category="Python Examples" name="points01.py" title="POINTS and Weighting" SubDir="Python">
    <description>Shows the effect of varying weighting factors and control vertices.</description>
    <keyword>Python</keyword>
    <keyword>POINTS</keyword>
    <keyword>EDGES</keyword>
    <application/>
  </script>

  <script ID="762" category="Python Examples" name="Source_Bulb_Fluor_Str.py" title="Straight Fluorescent Tube" SubDir="Python">
    <description>
      This example shows a simple straight fluorescent
      tube using a volume emitting source at center
      which is the length of the tube.  An inner tube
      surrounds this emitter whose surface properties
      are set up so that only the scattered rays get
      through and no specular rays. This simulates a
      plasma. Two macros are used, one calling another,
      to create the ends of the tube.
    </description>
    <keyword>Python</keyword>
    <keyword>Sources</keyword>
    <keyword>Fluorescent</keyword>
    <keyword>bulb</keyword>
    <keyword>EMITTING CONE</keyword>
    <keyword>RACETRACK</keyword>
    <keyword>SCATTER</keyword>
    <keyword>random</keyword>
    <keyword>SUBSET</keyword>
    <application/>
  </script>

  <script ID="763" category="Python Examples" name="source_wave01.py" title="SOURCE WAVEFUNC Example" SubDir="Python">
    <description>
      Allows defining the source point of rays
      in a grid to start from a wavefront
      surface defined by a surface function.
      In this example, the rays in the grid are
      moved along Z to the nearest point on the
      wavefront surface made with the OPTICAL command.
    </description>
    <keyword>Python</keyword>
    <keyword>SOURCE</keyword>
    <keyword>WAVEFUNC</keyword>
    <application/>
  </script>

  <script ID="764" category="CSharp Examples" name="Fiber_Tapered.cs" title="Tapered Fiber as One Object" SubDir="CSharp">
    <description>
      This creates a tapered fiber as one object using a set
      of EDGE POINTS at equal angular separation, which
      are extruded together using the second form of the
      OBJECT command. Note that the corners of the taper
      can have a tendency to leak if rays hit there exactly
      on axis from a grid. Avoid this by using a random set of rays.
    </description>
    <keyword>csharp</keyword>
    <keyword>Edges</keyword>
    <keyword>fiber</keyword>
    <keyword>taper</keyword>
    <keyword>EDGES</keyword>
    <keyword>POINTS</keyword>
    <keyword>OBJECT</keyword>
    <application/>
  </script>

  <script ID="765" category="CSharp Examples" name="GetSet.cs" title="Get Set Example" SubDir="CSharp">
    <description>Methods for getting and setting variables between the kernel and script languages</description>
    <keyword>csharp</keyword>
    <keyword>GET</keyword>
    <keyword>EMITTING</keyword>
    <application/>
  </script>

  <script ID="766" category="CSharp Examples" name="group02.cs" title="Grouping Objects for Shifting/Rotating" SubDir="CSharp">
    <description>
      Select groups of objects to shift and/or rotate.
      Nine elliptical surfaces are created. The first 3 are
      shifted and rotated. The second 3 are shifted and rotated.
      The last 3 are shifted. The plot shows the before and after.
    </description>
    <keyword>csharp</keyword>
    <keyword>GROUP</keyword>
    <keyword>Manipulating</keyword>
    <application/>
  </script>

  <script ID="767" category="CSharp Examples" name="lens_array01.cs" title="A Discrete Lens Array" SubDir="CSharp">
    <description>
      A micro-lens array with discrete lens objects using nested macro/do loops.
      This is better performed with bounding and using the ARRAY command.
    </description>
    <keyword>csharp</keyword>
    <keyword>Macros_user</keyword>
    <keyword>Arrays</keyword>
    <keyword>lenslet</keyword>
    <keyword>macro</keyword>
    <application/>
  </script>

  <script ID="768" category="CSharp Examples" name="Literal_Passing02.cs" title="Passing Variables to Plot Titles" SubDir="CSharp">
    <description>Passing variables to plot titles using the LIT operator and a macro.</description>
    <keyword>csharp</keyword>
    <keyword>Scripts</keyword>
    <keyword>literal</keyword>
    <keyword>string</keyword>
    <keyword>variable</keyword>
    <keyword>macro</keyword>
    <keyword>plot</keyword>
    <keyword>title</keyword>
    <application/>
  </script>

  <script ID="769" category="CSharp Examples" name="points01.cs" title="POINTS and Weighting" SubDir="CSharp">
    <description>Shows the effect of varying weighting factors and control vertices.</description>
    <keyword>csharp</keyword>
    <keyword>POINTS</keyword>
    <keyword>EDGES</keyword>
    <application/>
  </script>

  <script ID="770" category="CSharp Examples" name="Source_Bulb_Fluor_Str.cs" title="Straight Fluorescent Tube" SubDir="CSharp">
    <description>
      This example shows a simple straight fluorescent
      tube using a volume emitting source at center
      which is the length of the tube.  An inner tube
      surrounds this emitter whose surface properties
      are set up so that only the scattered rays get
      through and no specular rays. This simulates a
      plasma. Two macros are used, one calling another,
      to create the ends of the tube.
    </description>
    <keyword>csharp</keyword>
    <keyword>Sources</keyword>
    <keyword>Fluorescent</keyword>
    <keyword>bulb</keyword>
    <keyword>EMITTING CONE</keyword>
    <keyword>RACETRACK</keyword>
    <keyword>SCATTER</keyword>
    <keyword>random</keyword>
    <keyword>SUBSET</keyword>
    <application/>
  </script>

  <script ID="771" category="CSharp Examples" name="source_wave01.cs" title="SOURCE WAVEFUNC Example" SubDir="CSharp">
    <description>
      Allows defining the source point of rays
      in a grid to start from a wavefront
      surface defined by a surface function.
      In this example, the rays in the grid are
      moved along Z to the nearest point on the
      wavefront surface made with the OPTICAL command.
    </description>
    <keyword>csharp</keyword>
    <keyword>SOURCE</keyword>
    <keyword>WAVEFUNC</keyword>
    <application/>
  </script>

  <script ID="772" category="CSharp Examples" name="NestedLoopEx03.cs" title="Nested loop Example" SubDir="CSharp">
    <description>A micro-lens array with discrete lens objects using nested for loops.</description>
    <keyword>csharp</keyword>
    <keyword>SOURCE</keyword>
    <keyword>OPTICAL</keyword>
    <application/>
  </script>

</Scripts>


